/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _digitalbazaar_vc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @digitalbazaar/vc */ \"./node_modules/@digitalbazaar/vc/lib/index.js\");\n/* harmony import */ var _digitalbazaar_vc__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_digitalbazaar_vc__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _digitalbazaar_vc_lib_contexts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @digitalbazaar/vc/lib/contexts */ \"./node_modules/@digitalbazaar/vc/lib/contexts/index.js\");\n/* harmony import */ var _digitalbazaar_vc_lib_contexts__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_digitalbazaar_vc_lib_contexts__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var jsonld_signatures__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsonld-signatures */ \"./node_modules/jsonld-signatures/lib/jsonld-signatures.js\");\n/* harmony import */ var jsonld_signatures__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jsonld_signatures__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var ed25519_signature_2020_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ed25519-signature-2020-context */ \"./node_modules/ed25519-signature-2020-context/dist/context.esm.js\");\n/* harmony import */ var jose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! jose */ \"./node_modules/jose/dist/browser/index.js\");\n/* harmony import */ var _digitalbazaar_ed25519_verification_key_2020__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @digitalbazaar/ed25519-verification-key-2020 */ \"./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/main.js\");\n/* harmony import */ var _digitalbazaar_ed25519_signature_2020__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @digitalbazaar/ed25519-signature-2020 */ \"./node_modules/@digitalbazaar/ed25519-signature-2020/lib/main.js\");\n\n\n\n\n\n\n\n\n// append 2020 signature suite to cached contexts\n(_digitalbazaar_vc_lib_contexts__WEBPACK_IMPORTED_MODULE_1___default())[ed25519_signature_2020_context__WEBPACK_IMPORTED_MODULE_3__[\"default\"].CONTEXT_URL] = ed25519_signature_2020_context__WEBPACK_IMPORTED_MODULE_3__[\"default\"].CONTEXT;\n// setup static document loader\nconst documentLoader = (0,jsonld_signatures__WEBPACK_IMPORTED_MODULE_2__.extendContextLoader)(async function documentLoader(url) {\n  const context = (_digitalbazaar_vc_lib_contexts__WEBPACK_IMPORTED_MODULE_1___default())[url];\n  if(context !== undefined) {\n    return {\n      contextUrl: null,\n      documentUrl: url,\n      document: context\n    };\n  }\n  throw new Error(`Document loader unable to load URL \"${url}\".`);\n});\n\nasync function attachJwt({credential, iss, jwk}) {\n  const jwt = new jose__WEBPACK_IMPORTED_MODULE_4__.SignJWT({vc: credential})\n    .setProtectedHeader({ alg: 'ES256' })\n    .setIssuedAt()\n    .setIssuer(iss)\n    .sign(jwk.privateKey);\n\n  return jwt;\n};\n\nasync function attachProof({credential, suite}) {\n  const credentialCopy = JSON.parse(JSON.stringify(credential));\n  return _digitalbazaar_vc__WEBPACK_IMPORTED_MODULE_0___default().issue({credential: credentialCopy, suite, documentLoader});\n};\n\nasync function createVcExamples() {\n  // generate base keypair and signature suite\n  const keyPair = await _digitalbazaar_ed25519_verification_key_2020__WEBPACK_IMPORTED_MODULE_5__.Ed25519VerificationKey2020.generate();\n  const suite = new _digitalbazaar_ed25519_signature_2020__WEBPACK_IMPORTED_MODULE_6__.Ed25519Signature2020({\n    key: keyPair\n  });\n  const jwk = await jose__WEBPACK_IMPORTED_MODULE_4__.generateKeyPair('ES256');\n\n  // process every example that needs a vc-proof\n  const vcProofExamples = document.querySelectorAll(\".vc\");\n  for(const example of vcProofExamples) {\n    const verificationMethod =\n      example.getAttribute('data-vc-verification-method');\n    suite.verificationMethod =\n      verificationMethod || 'did:key:' + keyPair.publicKey;\n\n    // extract and sign the example\n    const originalText = example.innerHTML;\n    let credential = {};\n    try {\n      let exampleText = example.innerText;\n      exampleText = exampleText.replace(/\\/\\/ .*$/gm, '');\n      credential = JSON.parse(exampleText);\n    } catch(e) {\n      console.error('respec-vc error: Failed to create Verifiable Credential.',\n        e, example.innerText);\n      continue;\n    }\n\n    const verifiableCredentialProof = await attachProof({credential, suite});\n    const verifiableCredentialJwt =\n      await attachJwt({credential, iss: suite.verificationMethod, jwk});\n\n    // set up the unsigned button action\n    const unsignedButton = document.createElement('button');\n    unsignedButton.innerText = 'Credential';\n    unsignedButton.setAttribute(\n      'onclick', 'window.displayVcExample(this, \\'credential\\');');\n    example.classList.remove('vc');\n    example.classList.add('credential');\n\n    // set up the signed proof button action\n    const signedProofButton = document.createElement('button');\n    signedProofButton.innerText = 'Verifiable Credential (with proof)';\n    signedProofButton.setAttribute(\n      'onclick', 'window.displayVcExample(this, \\'vc-proof\\');');\n    const preProof = document.createElement('pre');\n    preProof.classList.add('vc-proof');\n    preProof.style.display = 'none';\n    preProof.innerText = JSON.stringify(verifiableCredentialProof, null, 2)\n      .match(/.{1,75}/g).join('\\n');\n\n    // set up the signed JWT button action\n    const signedJwtButton = document.createElement('button');\n    signedJwtButton.innerText = 'Verifiable Credential (as JWT)';\n    signedJwtButton.setAttribute(\n      'onclick', 'window.displayVcExample(this, \\'vc-jwt\\');');\n    const preJwt = document.createElement('pre');\n    preJwt.classList.add('vc-jwt');\n    preJwt.style.display = 'none';\n    preJwt.innerText = verifiableCredentialJwt.match(/.{1,75}/g).join('\\n');\n\n    // set up the tab separator\n    const tabSeparator = document.createElement('div');\n    tabSeparator.style.background = 'gray';\n    tabSeparator.style.height = '1px';\n    tabSeparator.style.border = '1px';\n    tabSeparator.style.margin = '-2px 0px';\n\n    // prepend the buttons before the preformatted example\n    example.before(unsignedButton);\n    example.before(signedProofButton);\n    example.before(signedJwtButton);\n    example.before(tabSeparator);\n\n    // append the examples\n    example.after(preJwt);\n    example.after(preProof);\n  }\n}\n\n// setup exports on window\nwindow.respecVc = {\n  createVcExamples\n}\n\n\n//# sourceURL=webpack://respec-vc/./index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-signature-2020/lib/Ed25519Signature2020.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-signature-2020/lib/Ed25519Signature2020.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ed25519Signature2020\": () => (/* binding */ Ed25519Signature2020)\n/* harmony export */ });\n/* harmony import */ var jsonld_signatures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsonld-signatures */ \"./node_modules/jsonld-signatures/lib/jsonld-signatures.js\");\n/* harmony import */ var jsonld_signatures__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jsonld_signatures__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _digitalbazaar_ed25519_verification_key_2020__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @digitalbazaar/ed25519-verification-key-2020 */ \"./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/main.js\");\n/* harmony import */ var ed25519_signature_2020_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ed25519-signature-2020-context */ \"./node_modules/ed25519-signature-2020-context/dist/context.esm.js\");\n/* harmony import */ var ed25519_signature_2018_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ed25519-signature-2018-context */ \"./node_modules/ed25519-signature-2018-context/dist/context.esm.js\");\n/*!\n * Copyright (c) 2020-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\nconst {suites: {LinkedDataSignature}} = (jsonld_signatures__WEBPACK_IMPORTED_MODULE_0___default());\nconst base58btc = __webpack_require__(/*! base58-universal */ \"./node_modules/base58-universal/main.js\");\n\n\n\n\n// 'https://w3id.org/security/suites/ed25519-2020/v1'\nconst SUITE_CONTEXT_URL = ed25519_signature_2020_context__WEBPACK_IMPORTED_MODULE_2__[\"default\"].constants.CONTEXT_URL;\n// 'https://w3id.org/security/suites/ed25519-2018/v1'\nconst SUITE_CONTEXT_URL_2018 = ed25519_signature_2018_context__WEBPACK_IMPORTED_MODULE_3__[\"default\"].constants.CONTEXT_URL;\n// multibase base58-btc header\nconst MULTIBASE_BASE58BTC_HEADER = 'z';\n\nclass Ed25519Signature2020 extends LinkedDataSignature {\n  /**\n   * @param {object} options - Options hashmap.\n   *\n   * Either a `key` OR at least one of `signer`/`verifier` is required:\n   *\n   * @param {object} [options.key] - An optional key object (containing an\n   *   `id` property, and either `signer` or `verifier`, depending on the\n   *   intended operation. Useful for when the application is managing keys\n   *   itself (when using a KMS, you never have access to the private key,\n   *   and so should use the `signer` param instead).\n   * @param {Function} [options.signer] - Signer function that returns an\n   *   object with an async sign() method. This is useful when interfacing\n   *   with a KMS (since you don't get access to the private key and its\n   *   `signer()`, the KMS client gives you only the signer function to use).\n   * @param {Function} [options.verifier] - Verifier function that returns\n   *   an object with an async `verify()` method. Useful when working with a\n   *   KMS-provided verifier function.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {object} [options.proof] - A JSON-LD document with options to use\n   *   for the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2).\n   * @param {string|Date} [options.date] - Signing date to use if not passed.\n   * @param {boolean} [options.useNativeCanonize] - Whether to use a native\n   *   canonize algorithm.\n   */\n  constructor({\n    key, signer, verifier, proof, date, useNativeCanonize\n  } = {}) {\n    super({\n      type: 'Ed25519Signature2020', LDKeyClass: _digitalbazaar_ed25519_verification_key_2020__WEBPACK_IMPORTED_MODULE_1__.Ed25519VerificationKey2020,\n      contextUrl: SUITE_CONTEXT_URL,\n      key, signer, verifier, proof, date, useNativeCanonize\n    });\n    // Some operations may be performed with Ed25519VerificationKey2018.\n    // So, Ed25519VerificationKey2020 is recommended, but not strictly required.\n    this.requiredKeyType = 'Ed25519VerificationKey2020';\n  }\n\n  /**\n   * Adds a signature (proofValue) field to the proof object. Called by\n   * LinkedDataSignature.createProof().\n   *\n   * @param {object} options - The options to use.\n   * @param {Uint8Array} options.verifyData - Data to be signed (extracted\n   *   from document, according to the suite's spec).\n   * @param {object} options.proof - Proof object (containing the proofPurpose,\n   *   verificationMethod, etc).\n   *\n   * @returns {Promise<object>} Resolves with the proof containing the signature\n   *   value.\n   */\n  async sign({verifyData, proof}) {\n    if(!(this.signer && typeof this.signer.sign === 'function')) {\n      throw new Error('A signer API has not been specified.');\n    }\n\n    const signatureBytes = await this.signer.sign({data: verifyData});\n    proof.proofValue =\n      MULTIBASE_BASE58BTC_HEADER + base58btc.encode(signatureBytes);\n\n    return proof;\n  }\n\n  /**\n   * Verifies the proof signature against the given data.\n   *\n   * @param {object} options - The options to use.\n   * @param {Uint8Array} options.verifyData - Canonicalized hashed data.\n   * @param {object} options.verificationMethod - Key object.\n   * @param {object} options.proof - The proof to be verified.\n   *\n   * @returns {Promise<boolean>} Resolves with the verification result.\n   */\n  async verifySignature({verifyData, verificationMethod, proof}) {\n    const {proofValue} = proof;\n    if(!(proofValue && typeof proofValue === 'string')) {\n      throw new TypeError(\n        'The proof does not include a valid \"proofValue\" property.');\n    }\n    if(proofValue[0] !== MULTIBASE_BASE58BTC_HEADER) {\n      throw new Error('Only base58btc multibase encoding is supported.');\n    }\n    const signatureBytes = base58btc.decode(proofValue.substr(1));\n\n    let {verifier} = this;\n    if(!verifier) {\n      const key = await this.LDKeyClass.from(verificationMethod);\n      verifier = key.verifier();\n    }\n    return verifier.verify({data: verifyData, signature: signatureBytes});\n  }\n\n  async assertVerificationMethod({verificationMethod}) {\n    let contextUrl;\n    if(verificationMethod.type === 'Ed25519VerificationKey2020') {\n      contextUrl = SUITE_CONTEXT_URL;\n    } else if(verificationMethod.type === 'Ed25519VerificationKey2018') {\n      contextUrl = SUITE_CONTEXT_URL_2018;\n    } else {\n      throw new Error(`Unsupported key type \"${verificationMethod.type}\".`);\n    }\n    if(!_includesContext({\n      document: verificationMethod, contextUrl\n    })) {\n      // For DID Documents, since keys do not have their own contexts,\n      // the suite context is usually provided by the documentLoader logic\n      throw new TypeError(\n        `The verification method (key) must contain \"${contextUrl}\" context.`\n      );\n    }\n\n    // ensure verification method has not been revoked\n    if(verificationMethod.revoked !== undefined) {\n      throw new Error('The verification method has been revoked.');\n    }\n  }\n\n  async getVerificationMethod({proof, documentLoader}) {\n    if(this.key) {\n      // This happens most often during sign() operations. For verify(),\n      // the expectation is that the verification method will be fetched\n      // by the documentLoader (below), not provided as a `key` parameter.\n      return this.key.export({publicKey: true});\n    }\n\n    let {verificationMethod} = proof;\n\n    if(typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n\n    if(!verificationMethod) {\n      throw new Error('No \"verificationMethod\" found in proof.');\n    }\n\n    const {document} = await documentLoader(verificationMethod);\n\n    verificationMethod = typeof document === 'string' ?\n      JSON.parse(document) : document;\n\n    await this.assertVerificationMethod({verificationMethod});\n    if(verificationMethod.type === 'Ed25519VerificationKey2018') {\n      verificationMethod = (await _digitalbazaar_ed25519_verification_key_2020__WEBPACK_IMPORTED_MODULE_1__.Ed25519VerificationKey2020.fromEd25519VerificationKey2018({keyPair: verificationMethod}))\n        .export({publicKey: true, includeContext: true});\n    }\n    return verificationMethod;\n  }\n\n  async matchProof({proof, document, purpose, documentLoader, expansionMap}) {\n    if(!_includesContext({document, contextUrl: SUITE_CONTEXT_URL})) {\n      return false;\n    }\n\n    if(!await super.matchProof({proof, document, purpose, documentLoader,\n      expansionMap})) {\n      return false;\n    }\n    if(!this.key) {\n      // no key specified, so assume this suite matches and it can be retrieved\n      return true;\n    }\n\n    const {verificationMethod} = proof;\n\n    // only match if the key specified matches the one in the proof\n    if(typeof verificationMethod === 'object') {\n      return verificationMethod.id === this.key.id;\n    }\n    return verificationMethod === this.key.id;\n  }\n}\n\n/**\n * Tests whether a provided JSON-LD document includes a context url in its\n * `@context` property.\n *\n * @param {object} options - Options hashmap.\n * @param {object} options.document - A JSON-LD document.\n * @param {string} options.contextUrl - A context url.\n *\n * @returns {boolean} Returns true if document includes context.\n */\nfunction _includesContext({document, contextUrl}) {\n  const context = document['@context'];\n  return context === contextUrl ||\n    (Array.isArray(context) && context.includes(contextUrl));\n}\n\nEd25519Signature2020.CONTEXT_URL = SUITE_CONTEXT_URL;\nEd25519Signature2020.CONTEXT = ed25519_signature_2020_context__WEBPACK_IMPORTED_MODULE_2__[\"default\"].contexts.get(SUITE_CONTEXT_URL);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-signature-2020/lib/Ed25519Signature2020.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-signature-2020/lib/main.js":
/*!************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-signature-2020/lib/main.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ed25519Signature2020\": () => (/* reexport safe */ _Ed25519Signature2020_js__WEBPACK_IMPORTED_MODULE_1__.Ed25519Signature2020),\n/* harmony export */   \"suiteContext\": () => (/* reexport safe */ ed25519_signature_2020_context__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var ed25519_signature_2020_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ed25519-signature-2020-context */ \"./node_modules/ed25519-signature-2020-context/dist/context.esm.js\");\n/* harmony import */ var _Ed25519Signature2020_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Ed25519Signature2020.js */ \"./node_modules/@digitalbazaar/ed25519-signature-2020/lib/Ed25519Signature2020.js\");\n/*!\n * Copyright (c) 2020-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-signature-2020/lib/main.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/Ed25519VerificationKey2020.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/Ed25519VerificationKey2020.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ed25519VerificationKey2020\": () => (/* binding */ Ed25519VerificationKey2020)\n/* harmony export */ });\n/* harmony import */ var base58_universal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base58-universal */ \"./node_modules/base58-universal/main.js\");\n/* harmony import */ var base64url_universal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! base64url-universal */ \"./node_modules/base64url-universal/lib/browser.js\");\n/* harmony import */ var base64url_universal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(base64url_universal__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ed25519_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ed25519.js */ \"./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/ed25519-browser.js\");\n/* harmony import */ var crypto_ld__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! crypto-ld */ \"./node_modules/crypto-ld/lib/index.js\");\n/* harmony import */ var crypto_ld__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(crypto_ld__WEBPACK_IMPORTED_MODULE_3__);\n/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\nconst SUITE_ID = 'Ed25519VerificationKey2020';\n// multibase base58-btc header\nconst MULTIBASE_BASE58BTC_HEADER = 'z';\n// multicodec ed25519-pub header as varint\nconst MULTICODEC_ED25519_PUB_HEADER = new Uint8Array([0xed, 0x01]);\n// multicodec ed25519-priv header as varint\nconst MULTICODEC_ED25519_PRIV_HEADER = new Uint8Array([0x80, 0x26]);\n\nclass Ed25519VerificationKey2020 extends crypto_ld__WEBPACK_IMPORTED_MODULE_3__.LDKeyPair {\n  /**\n   * An implementation of the Ed25519VerificationKey2020 spec, for use with\n   * Linked Data Proofs.\n   *\n   * @see https://w3c-ccg.github.io/lds-ed25519-2020/#ed25519verificationkey2020\n   * @see https://github.com/digitalbazaar/jsonld-signatures\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.controller - Controller DID or document url.\n   * @param {string} [options.id] - The key ID. If not provided, will be\n   *   composed of controller and key fingerprint as hash fragment.\n   * @param {string} options.publicKeyMultibase - Multibase encoded public key\n   *   with a multicodec ed25519-pub varint header [0xed, 0x01].\n   * @param {string} [options.privateKeyMultibase] - Multibase private key\n   *   with a multicodec ed25519-priv varint header [0x80, 0x26].\n   * @param {string} [options.revoked] - Timestamp of when the key has been\n   *   revoked, in RFC3339 format. If not present, the key itself is considered\n   *   not revoked. Note that this mechanism is slightly different than DID\n   *   Document key revocation, where a DID controller can revoke a key from\n   *   that DID by removing it from the DID Document.\n   */\n  constructor(options = {}) {\n    super(options);\n    this.type = SUITE_ID;\n    const {publicKeyMultibase, privateKeyMultibase} = options;\n\n    if(!publicKeyMultibase) {\n      throw new TypeError('The \"publicKeyMultibase\" property is required.');\n    }\n\n    if(!publicKeyMultibase || !_isValidKeyHeader(\n      publicKeyMultibase, MULTICODEC_ED25519_PUB_HEADER)) {\n      throw new Error(\n        '\"publicKeyMultibase\" has invalid header bytes: ' +\n        `\"${publicKeyMultibase}\".`);\n    }\n\n    if(privateKeyMultibase && !_isValidKeyHeader(\n      privateKeyMultibase, MULTICODEC_ED25519_PRIV_HEADER)) {\n      throw new Error('\"privateKeyMultibase\" has invalid header bytes.');\n    }\n\n    // assign valid key values\n    this.publicKeyMultibase = publicKeyMultibase;\n    this.privateKeyMultibase = privateKeyMultibase;\n\n    // set key identifier if controller is provided\n    if(this.controller && !this.id) {\n      this.id = `${this.controller}#${this.fingerprint()}`;\n    }\n  }\n\n  /**\n   * Creates an Ed25519 Key Pair from an existing serialized key pair.\n   *\n   * @param {object} options - Key pair options (see constructor).\n   * @example\n   * > const keyPair = await Ed25519VerificationKey2020.from({\n   * controller: 'did:ex:1234',\n   * type: 'Ed25519VerificationKey2020',\n   * publicKeyMultibase,\n   * privateKeyMultibase\n   * });\n   *\n   * @returns {Promise<Ed25519VerificationKey2020>} An Ed25519 Key Pair.\n   */\n  static async from(options) {\n    if(options.type === 'Ed25519VerificationKey2018') {\n      return Ed25519VerificationKey2020.fromEd25519VerificationKey2018(options);\n    }\n    if(options.type === 'JsonWebKey2020') {\n      return Ed25519VerificationKey2020.fromJsonWebKey2020(options);\n    }\n    return new Ed25519VerificationKey2020(options);\n  }\n\n  /**\n   * Instance creation method for backwards compatibility with the\n   * `Ed25519VerificationKey2018` key suite.\n   *\n   * @see https://github.com/digitalbazaar/ed25519-verification-key-2018\n   * @typedef {object} Ed25519VerificationKey2018\n   * @param {Ed25519VerificationKey2018} keyPair - Ed25519 2018 suite key pair.\n   *\n   * @returns {Ed25519VerificationKey2020} - 2020 suite instance.\n   */\n  static fromEd25519VerificationKey2018({keyPair} = {}) {\n    const publicKeyMultibase = _encodeMbKey(\n      MULTICODEC_ED25519_PUB_HEADER, base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(keyPair.publicKeyBase58));\n    const keyPair2020 = new Ed25519VerificationKey2020({\n      id: keyPair.id,\n      controller: keyPair.controller,\n      publicKeyMultibase\n    });\n\n    if(keyPair.privateKeyBase58) {\n      keyPair2020.privateKeyMultibase = _encodeMbKey(\n        MULTICODEC_ED25519_PRIV_HEADER,\n        base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(keyPair.privateKeyBase58));\n    }\n\n    return keyPair2020;\n  }\n\n  /**\n   * Creates a key pair instance (public key only) from a JsonWebKey2020\n   * object.\n   *\n   * @see https://w3c-ccg.github.io/lds-jws2020/#json-web-key-2020\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.id - Key id.\n   * @param {string} options.type - Key suite type.\n   * @param {string} options.controller - Key controller.\n   * @param {object} options.publicKeyJwk - JWK object.\n   *\n   * @returns {Promise<Ed25519VerificationKey2020>} Resolves with key pair.\n   */\n  static fromJsonWebKey2020({id, type, controller, publicKeyJwk} = {}) {\n    if(type !== 'JsonWebKey2020') {\n      throw new TypeError(`Invalid key type: \"${type}\".`);\n    }\n    if(!publicKeyJwk) {\n      throw new TypeError('\"publicKeyJwk\" property is required.');\n    }\n    const {kty, crv} = publicKeyJwk;\n    if(kty !== 'OKP') {\n      throw new TypeError('\"kty\" is required to be \"OKP\".');\n    }\n    if(crv !== 'Ed25519') {\n      throw new TypeError('\"crv\" is required to be \"Ed25519\".');\n    }\n    const {x: publicKeyBase64Url} = publicKeyJwk;\n    const publicKeyMultibase = _encodeMbKey(\n      MULTICODEC_ED25519_PUB_HEADER,\n      base64url_universal__WEBPACK_IMPORTED_MODULE_1__.decode(publicKeyBase64Url));\n\n    return Ed25519VerificationKey2020.from({\n      id, controller, publicKeyMultibase\n    });\n  }\n\n  /**\n   * Generates a KeyPair with an optional deterministic seed.\n   *\n   * @param {object} [options={}] - Options hashmap.\n   * @param {Uint8Array} [options.seed] - A 32-byte array seed for a\n   *   deterministic key.\n   *\n   * @returns {Promise<Ed25519VerificationKey2020>} Resolves with generated\n   *   public/private key pair.\n   */\n  static async generate({seed, ...keyPairOptions} = {}) {\n    let keyObject;\n    if(seed) {\n      keyObject = await _ed25519_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].generateKeyPairFromSeed(seed);\n    } else {\n      keyObject = await _ed25519_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].generateKeyPair();\n    }\n    const publicKeyMultibase =\n      _encodeMbKey(MULTICODEC_ED25519_PUB_HEADER, keyObject.publicKey);\n\n    const privateKeyMultibase =\n      _encodeMbKey(MULTICODEC_ED25519_PRIV_HEADER, keyObject.secretKey);\n\n    return new Ed25519VerificationKey2020({\n      publicKeyMultibase,\n      privateKeyMultibase,\n      ...keyPairOptions\n    });\n  }\n\n  /**\n   * Creates an instance of Ed25519VerificationKey2020 from a key fingerprint.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.fingerprint - Multibase encoded key fingerprint.\n   *\n   * @returns {Ed25519VerificationKey2020} Returns key pair instance (with\n   *   public key only).\n   */\n  static fromFingerprint({fingerprint} = {}) {\n    return new Ed25519VerificationKey2020({publicKeyMultibase: fingerprint});\n  }\n\n  /**\n   * @returns {Uint8Array} Public key bytes.\n   */\n  get _publicKeyBuffer() {\n    if(!this.publicKeyMultibase) {\n      return;\n    }\n    // remove multibase header\n    const publicKeyMulticodec =\n      base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(this.publicKeyMultibase.substr(1));\n    // remove multicodec header\n    const publicKeyBytes =\n      publicKeyMulticodec.slice(MULTICODEC_ED25519_PUB_HEADER.length);\n\n    return publicKeyBytes;\n  }\n\n  /**\n   * @returns {Uint8Array} Private key bytes.\n   */\n  get _privateKeyBuffer() {\n    if(!this.privateKeyMultibase) {\n      return;\n    }\n    // remove multibase header\n    const privateKeyMulticodec =\n      base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(this.privateKeyMultibase.substr(1));\n    // remove multicodec header\n    const privateKeyBytes =\n      privateKeyMulticodec.slice(MULTICODEC_ED25519_PRIV_HEADER.length);\n\n    return privateKeyBytes;\n  }\n\n  /**\n   * Generates and returns a multiformats encoded\n   * ed25519 public key fingerprint (for use with cryptonyms, for example).\n   *\n   * @see https://github.com/multiformats/multicodec\n   *\n   * @returns {string} The fingerprint.\n   */\n  fingerprint() {\n    return this.publicKeyMultibase;\n  }\n\n  /**\n   * Exports the serialized representation of the KeyPair\n   * and other information that JSON-LD Signatures can use to form a proof.\n   *\n   * @param {object} [options={}] - Options hashmap.\n   * @param {boolean} [options.publicKey] - Export public key material?\n   * @param {boolean} [options.privateKey] - Export private key material?\n   * @param {boolean} [options.includeContext] - Include JSON-LD context?\n   *\n   * @returns {object} A plain js object that's ready for serialization\n   *   (to JSON, etc), for use in DIDs, Linked Data Proofs, etc.\n   */\n  export({publicKey = false, privateKey = false, includeContext = false} = {}) {\n    if(!(publicKey || privateKey)) {\n      throw new TypeError(\n        'Export requires specifying either \"publicKey\" or \"privateKey\".');\n    }\n    const exportedKey = {\n      id: this.id,\n      type: this.type\n    };\n    if(includeContext) {\n      exportedKey['@context'] = Ed25519VerificationKey2020.SUITE_CONTEXT;\n    }\n    if(this.controller) {\n      exportedKey.controller = this.controller;\n    }\n    if(publicKey) {\n      exportedKey.publicKeyMultibase = this.publicKeyMultibase;\n    }\n    if(privateKey) {\n      exportedKey.privateKeyMultibase = this.privateKeyMultibase;\n    }\n    if(this.revoked) {\n      exportedKey.revoked = this.revoked;\n    }\n    return exportedKey;\n  }\n\n  /**\n   * Returns the JWK representation of this key pair.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc8037\n   *\n   * @param {object} [options={}] - Options hashmap.\n   * @param {boolean} [options.publicKey] - Include public key?\n   * @param {boolean} [options.privateKey] - Include private key?\n   *\n   * @returns {{kty: string, crv: string, x: string, d: string}} JWK\n   *   representation.\n   */\n  toJwk({publicKey = true, privateKey = false} = {}) {\n    if(!(publicKey || privateKey)) {\n      throw TypeError('Either a \"publicKey\" or a \"privateKey\" is required.');\n    }\n    const jwk = {crv: 'Ed25519', kty: 'OKP'};\n    if(publicKey) {\n      jwk.x = base64url_universal__WEBPACK_IMPORTED_MODULE_1__.encode(this._publicKeyBuffer);\n    }\n    if(privateKey) {\n      jwk.d = base64url_universal__WEBPACK_IMPORTED_MODULE_1__.encode(this._privateKeyBuffer);\n    }\n    return jwk;\n  }\n\n  /**\n   * @see https://datatracker.ietf.org/doc/html/rfc8037#appendix-A.3\n   *\n   * @returns {Promise<string>} JWK Thumbprint.\n   */\n  async jwkThumbprint() {\n    const publicKey = base64url_universal__WEBPACK_IMPORTED_MODULE_1__.encode(this._publicKeyBuffer);\n    const serialized = `{\"crv\":\"Ed25519\",\"kty\":\"OKP\",\"x\":\"${publicKey}\"}`;\n    const data = new TextEncoder().encode(serialized);\n    return base64url_universal__WEBPACK_IMPORTED_MODULE_1__.encode(\n      new Uint8Array(await _ed25519_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sha256digest({data})));\n  }\n\n  /**\n   * Returns the JsonWebKey2020 representation of this key pair.\n   *\n   * @see https://w3c-ccg.github.io/lds-jws2020/#json-web-key-2020\n   *\n   * @returns {Promise<object>} JsonWebKey2020 representation.\n   */\n  async toJsonWebKey2020() {\n    return {\n      '@context': 'https://w3id.org/security/jws/v1',\n      id: this.controller + '#' + await this.jwkThumbprint(),\n      type: 'JsonWebKey2020',\n      controller: this.controller,\n      publicKeyJwk: this.toJwk({publicKey: true})\n    };\n  }\n\n  /**\n   * Tests whether the fingerprint was generated from a given key pair.\n   *\n   * @example\n   * > edKeyPair.verifyFingerprint({fingerprint: 'z6Mk2S2Q...6MkaFJewa'});\n   * {valid: true};\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.fingerprint - A public key fingerprint.\n   *\n   * @returns {{valid: boolean, error: *}} Result of verification.\n   */\n  verifyFingerprint({fingerprint} = {}) {\n    // fingerprint should have multibase base58-btc header\n    if(!(typeof fingerprint === 'string' &&\n      fingerprint[0] === MULTIBASE_BASE58BTC_HEADER)) {\n      return {\n        error: new Error('\"fingerprint\" must be a multibase encoded string.'),\n        valid: false\n      };\n    }\n    let fingerprintBuffer;\n    try {\n      fingerprintBuffer = base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(fingerprint.substr(1));\n      if(!fingerprintBuffer) {\n        throw new TypeError('Invalid encoding of fingerprint.');\n      }\n    } catch(e) {\n      return {error: e, valid: false};\n    }\n\n    const buffersEqual = _isEqualBuffer(this._publicKeyBuffer,\n      fingerprintBuffer.slice(2));\n\n    // validate the first two multicodec bytes\n    const valid =\n      fingerprintBuffer[0] === MULTICODEC_ED25519_PUB_HEADER[0] &&\n      fingerprintBuffer[1] === MULTICODEC_ED25519_PUB_HEADER[1] &&\n      buffersEqual;\n    if(!valid) {\n      return {\n        error: new Error('The fingerprint does not match the public key.'),\n        valid: false\n      };\n    }\n    return {valid};\n  }\n\n  signer() {\n    const privateKeyBuffer = this._privateKeyBuffer;\n\n    return {\n      async sign({data}) {\n        if(!privateKeyBuffer) {\n          throw new Error('A private key is not available for signing.');\n        }\n        return _ed25519_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sign(privateKeyBuffer, data);\n      },\n      id: this.id\n    };\n  }\n\n  verifier() {\n    const publicKeyBuffer = this._publicKeyBuffer;\n\n    return {\n      async verify({data, signature}) {\n        if(!publicKeyBuffer) {\n          throw new Error('A public key is not available for verifying.');\n        }\n        return _ed25519_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].verify(publicKeyBuffer, data, signature);\n      },\n      id: this.id\n    };\n  }\n}\n// Used by CryptoLD harness for dispatching.\nEd25519VerificationKey2020.suite = SUITE_ID;\n// Used by CryptoLD harness's fromKeyId() method.\nEd25519VerificationKey2020.SUITE_CONTEXT =\n  'https://w3id.org/security/suites/ed25519-2020/v1';\n\n// check to ensure that two buffers are byte-for-byte equal\n// WARNING: this function must only be used to check public information as\n//          timing attacks can be used for non-constant time checks on\n//          secret information.\nfunction _isEqualBuffer(buf1, buf2) {\n  if(buf1.length !== buf2.length) {\n    return false;\n  }\n  for(let i = 0; i < buf1.length; i++) {\n    if(buf1[i] !== buf2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// check a multibase key for an expected header\nfunction _isValidKeyHeader(multibaseKey, expectedHeader) {\n  if(!(typeof multibaseKey === 'string' &&\n    multibaseKey[0] === MULTIBASE_BASE58BTC_HEADER)) {\n    return false;\n  }\n\n  const keyBytes = base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(multibaseKey.slice(1));\n  return expectedHeader.every((val, i) => keyBytes[i] === val);\n}\n\n// encode a multibase base58-btc multicodec key\nfunction _encodeMbKey(header, key) {\n  const mbKey = new Uint8Array(header.length + key.length);\n\n  mbKey.set(header);\n  mbKey.set(key, header.length);\n\n  return MULTIBASE_BASE58BTC_HEADER + base58_universal__WEBPACK_IMPORTED_MODULE_0__.encode(mbKey);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/Ed25519VerificationKey2020.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/ed25519-browser.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/ed25519-browser.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _stablelib_ed25519__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stablelib/ed25519 */ \"./node_modules/@stablelib/ed25519/lib/ed25519.js\");\n/*!\n * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n// browser MUST provide \"crypto.getRandomValues\"\nconst crypto = self && (self.crypto || self.msCrypto);\nif(!crypto.getRandomValues) {\n  throw new Error('Browser does not provide \"crypto.getRandomValues\".');\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  ..._stablelib_ed25519__WEBPACK_IMPORTED_MODULE_0__,\n  async generateKeyPair() {\n    const seed = new Uint8Array(32);\n    crypto.getRandomValues(seed);\n    return _stablelib_ed25519__WEBPACK_IMPORTED_MODULE_0__.generateKeyPairFromSeed(seed);\n  },\n  async sha256digest({data}) {\n    return crypto.subtle.digest('SHA-256', data);\n  }\n});\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/ed25519-browser.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/main.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/main.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ed25519VerificationKey2020\": () => (/* reexport safe */ _Ed25519VerificationKey2020_js__WEBPACK_IMPORTED_MODULE_0__.Ed25519VerificationKey2020)\n/* harmony export */ });\n/* harmony import */ var _Ed25519VerificationKey2020_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Ed25519VerificationKey2020.js */ \"./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/Ed25519VerificationKey2020.js\");\n/*!\n * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/main.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/vc/lib/CredentialIssuancePurpose.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/vc/lib/CredentialIssuancePurpose.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2019-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\nconst jsonld = __webpack_require__(/*! jsonld */ \"./node_modules/jsonld/lib/jsonld.js\");\nconst {AssertionProofPurpose} = (__webpack_require__(/*! jsonld-signatures */ \"./node_modules/jsonld-signatures/lib/jsonld-signatures.js\").purposes);\n\n/**\n * Creates a proof purpose that will validate whether or not the verification\n * method in a proof was authorized by its declared controller for the\n * proof's purpose.\n */\nclass CredentialIssuancePurpose extends AssertionProofPurpose {\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} [options.controller] - The description of the controller,\n   *   if it is not to be dereferenced via a `documentLoader`.\n   * @param {string|Date|number} [options.date] - The expected date for\n   *   the creation of the proof.\n   * @param {number} [options.maxTimestampDelta=Infinity] - A maximum number\n   *   of seconds that the date on the signature can deviate from.\n   */\n  constructor({controller, date, maxTimestampDelta} = {}) {\n    super({controller, date, maxTimestampDelta});\n  }\n\n  /**\n   * Validates the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param {object} proof - The proof to validate.\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document whose signature is\n   *   being verified.\n   * @param {object} options.suite - Signature suite used in\n   *   the proof.\n   * @param {string} options.verificationMethod - Key id URL to the paired\n   *   public key.\n   * @param {object} [options.documentLoader] - A document loader.\n   * @param {object} [options.expansionMap] - An expansion map.\n   *\n   * @throws {Error} If verification method not authorized by controller.\n   * @throws {Error} If proof's created timestamp is out of range.\n   *\n   * @returns {Promise<{valid: boolean, error: Error}>} Resolves on completion.\n   */\n  async validate(proof, {\n    document, suite, verificationMethod, documentLoader, expansionMap\n  }) {\n    try {\n      const result = await super.validate(proof, {\n        document, suite, verificationMethod, documentLoader, expansionMap\n      });\n\n      if(!result.valid) {\n        throw result.error;\n      }\n\n      const issuer = jsonld.getValues(document, 'issuer');\n\n      if(!issuer || issuer.length === 0) {\n        throw new Error('Credential issuer is required.');\n      }\n\n      const issuerId = typeof issuer[0] === 'string' ? issuer[0] : issuer[0].id;\n\n      if(result.controller.id !== issuerId) {\n        throw new Error(\n          'Credential issuer must match the verification method controller.');\n      }\n\n      return {valid: true};\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n}\n\nmodule.exports = CredentialIssuancePurpose;\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/vc/lib/CredentialIssuancePurpose.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/vc/lib/contexts/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@digitalbazaar/vc/lib/contexts/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2019-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {contexts, constants: contextConstants} = __webpack_require__(/*! credentials-context */ \"./node_modules/credentials-context/dist/context.esm.js\");\n\nconst exportedContexts = module.exports = {\n  'https://www.w3.org/2018/credentials/examples/v1':\n    __webpack_require__(/*! ./vc-examples-v1 */ \"./node_modules/@digitalbazaar/vc/lib/contexts/vc-examples-v1.js\"),\n  'https://www.w3.org/ns/odrl.jsonld': __webpack_require__(/*! ./odrl */ \"./node_modules/@digitalbazaar/vc/lib/contexts/odrl.js\")\n};\n\nfor(const c in contextConstants) {\n  const contextUrl = contextConstants[c];\n  exportedContexts[contextUrl] = contexts.get(contextUrl);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/vc/lib/contexts/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/vc/lib/contexts/odrl.js":
/*!*************************************************************!*\
  !*** ./node_modules/@digitalbazaar/vc/lib/contexts/odrl.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2019-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n/* eslint-disable quote-props, key-spacing, max-len */\nmodule.exports = {\n  '@context': {\n    'odrl':    'http://www.w3.org/ns/odrl/2/',\n    'rdf':     'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n    'rdfs':    'http://www.w3.org/2000/01/rdf-schema#',\n    'owl':     'http://www.w3.org/2002/07/owl#',\n    'skos':    'http://www.w3.org/2004/02/skos/core#',\n    'dct':     'http://purl.org/dc/terms/',\n    'xsd':     'http://www.w3.org/2001/XMLSchema#',\n    'vcard':   'http://www.w3.org/2006/vcard/ns#',\n    'foaf':    'http://xmlns.com/foaf/0.1/',\n    'schema':  'http://schema.org/',\n    'cc':      'http://creativecommons.org/ns#',\n\n    'uid':     '@id',\n    'type':    '@type',\n\n    'Policy':           'odrl:Policy',\n    'Rule':             'odrl:Rule',\n    'profile':          {'@type': '@id', '@id': 'odrl:profile'},\n\n    'inheritFrom':      {'@type': '@id', '@id': 'odrl:inheritFrom'},\n\n    'ConflictTerm':     'odrl:ConflictTerm',\n    'conflict':         {'@type': '@vocab', '@id': 'odrl:conflict'},\n    'perm':             'odrl:perm',\n    'prohibit':         'odrl:prohibit',\n    'invalid':          'odrl:invalid',\n\n    'Agreement':           'odrl:Agreement',\n    'Assertion':           'odrl:Assertion',\n    'Offer':               'odrl:Offer',\n    'Privacy':             'odrl:Privacy',\n    'Request':             'odrl:Request',\n    'Set':                 'odrl:Set',\n    'Ticket':              'odrl:Ticket',\n\n    'Asset':               'odrl:Asset',\n    'AssetCollection':     'odrl:AssetCollection',\n    'relation':            {'@type': '@id', '@id': 'odrl:relation'},\n    'hasPolicy':           {'@type': '@id', '@id': 'odrl:hasPolicy'},\n\n    'target':             {'@type': '@id', '@id': 'odrl:target'},\n    'output':             {'@type': '@id', '@id': 'odrl:output'},\n\n    'partOf':            {'@type': '@id', '@id': 'odrl:partOf'},\n    'source':            {'@type': '@id', '@id': 'odrl:source'},\n\n    'Party':              'odrl:Party',\n    'PartyCollection':    'odrl:PartyCollection',\n    'function':           {'@type': '@vocab', '@id': 'odrl:function'},\n    'PartyScope':         'odrl:PartyScope',\n\n    'assignee':             {'@type': '@id', '@id': 'odrl:assignee'},\n    'assigner':             {'@type': '@id', '@id': 'odrl:assigner'},\n    'assigneeOf':           {'@type': '@id', '@id': 'odrl:assigneeOf'},\n    'assignerOf':           {'@type': '@id', '@id': 'odrl:assignerOf'},\n    'attributedParty':      {'@type': '@id', '@id': 'odrl:attributedParty'},\n    'attributingParty':     {'@type': '@id', '@id': 'odrl:attributingParty'},\n    'compensatedParty':     {'@type': '@id', '@id': 'odrl:compensatedParty'},\n    'compensatingParty':    {'@type': '@id', '@id': 'odrl:compensatingParty'},\n    'consentingParty':      {'@type': '@id', '@id': 'odrl:consentingParty'},\n    'consentedParty':       {'@type': '@id', '@id': 'odrl:consentedParty'},\n    'informedParty':        {'@type': '@id', '@id': 'odrl:informedParty'},\n    'informingParty':       {'@type': '@id', '@id': 'odrl:informingParty'},\n    'trackingParty':        {'@type': '@id', '@id': 'odrl:trackingParty'},\n    'trackedParty':         {'@type': '@id', '@id': 'odrl:trackedParty'},\n    'contractingParty':     {'@type': '@id', '@id': 'odrl:contractingParty'},\n    'contractedParty':      {'@type': '@id', '@id': 'odrl:contractedParty'},\n\n    'Action':                'odrl:Action',\n    'action':                {'@type': '@vocab', '@id': 'odrl:action'},\n    'includedIn':            {'@type': '@id', '@id': 'odrl:includedIn'},\n    'implies':               {'@type': '@id', '@id': 'odrl:implies'},\n\n    'Permission':            'odrl:Permission',\n    'permission':            {'@type': '@id', '@id': 'odrl:permission'},\n\n    'Prohibition':           'odrl:Prohibition',\n    'prohibition':           {'@type': '@id', '@id': 'odrl:prohibition'},\n\n    'obligation':            {'@type': '@id', '@id': 'odrl:obligation'},\n\n    'use':                   'odrl:use',\n    'grantUse':              'odrl:grantUse',\n    'aggregate':             'odrl:aggregate',\n    'annotate':              'odrl:annotate',\n    'anonymize':             'odrl:anonymize',\n    'archive':               'odrl:archive',\n    'concurrentUse':         'odrl:concurrentUse',\n    'derive':                'odrl:derive',\n    'digitize':              'odrl:digitize',\n    'display':               'odrl:display',\n    'distribute':            'odrl:distribute',\n    'execute':               'odrl:execute',\n    'extract':               'odrl:extract',\n    'give':                  'odrl:give',\n    'index':                 'odrl:index',\n    'install':               'odrl:install',\n    'modify':                'odrl:modify',\n    'move':                  'odrl:move',\n    'play':                  'odrl:play',\n    'present':               'odrl:present',\n    'print':                 'odrl:print',\n    'read':                  'odrl:read',\n    'reproduce':             'odrl:reproduce',\n    'sell':                  'odrl:sell',\n    'stream':                'odrl:stream',\n    'textToSpeech':          'odrl:textToSpeech',\n    'transfer':              'odrl:transfer',\n    'transform':             'odrl:transform',\n    'translate':             'odrl:translate',\n\n    'Duty':                 'odrl:Duty',\n    'duty':                 {'@type': '@id', '@id': 'odrl:duty'},\n    'consequence':          {'@type': '@id', '@id': 'odrl:consequence'},\n    'remedy':               {'@type': '@id', '@id': 'odrl:remedy'},\n\n    'acceptTracking':       'odrl:acceptTracking',\n    'attribute':            'odrl:attribute',\n    'compensate':           'odrl:compensate',\n    'delete':               'odrl:delete',\n    'ensureExclusivity':    'odrl:ensureExclusivity',\n    'include':              'odrl:include',\n    'inform':               'odrl:inform',\n    'nextPolicy':           'odrl:nextPolicy',\n    'obtainConsent':        'odrl:obtainConsent',\n    'reviewPolicy':         'odrl:reviewPolicy',\n    'uninstall':            'odrl:uninstall',\n    'watermark':            'odrl:watermark',\n\n    'Constraint':           'odrl:Constraint',\n    'LogicalConstraint':    'odrl:LogicalConstraint',\n    'constraint':           {'@type': '@id', '@id': 'odrl:constraint'},\n    'refinement':           {'@type': '@id', '@id': 'odrl:refinement'},\n    'Operator':             'odrl:Operator',\n    'operator':             {'@type': '@vocab', '@id': 'odrl:operator'},\n    'RightOperand':         'odrl:RightOperand',\n    'rightOperand':         'odrl:rightOperand',\n    'rightOperandReference':{'@type': 'xsd:anyURI', '@id': 'odrl:rightOperandReference'},\n    'LeftOperand':          'odrl:LeftOperand',\n    'leftOperand':          {'@type': '@vocab', '@id': 'odrl:leftOperand'},\n    'unit':                 'odrl:unit',\n    'dataType':             {'@type': 'xsd:anyType', '@id': 'odrl:datatype'},\n    'status':               'odrl:status',\n\n    'absolutePosition':        'odrl:absolutePosition',\n    'absoluteSpatialPosition': 'odrl:absoluteSpatialPosition',\n    'absoluteTemporalPosition':'odrl:absoluteTemporalPosition',\n    'absoluteSize':            'odrl:absoluteSize',\n    'count':                   'odrl:count',\n    'dateTime':                'odrl:dateTime',\n    'delayPeriod':             'odrl:delayPeriod',\n    'deliveryChannel':         'odrl:deliveryChannel',\n    'elapsedTime':             'odrl:elapsedTime',\n    'event':                   'odrl:event',\n    'fileFormat':              'odrl:fileFormat',\n    'industry':                'odrl:industry:',\n    'language':                'odrl:language',\n    'media':                   'odrl:media',\n    'meteredTime':             'odrl:meteredTime',\n    'payAmount':               'odrl:payAmount',\n    'percentage':              'odrl:percentage',\n    'product':                 'odrl:product',\n    'purpose':                 'odrl:purpose',\n    'recipient':               'odrl:recipient',\n    'relativePosition':        'odrl:relativePosition',\n    'relativeSpatialPosition': 'odrl:relativeSpatialPosition',\n    'relativeTemporalPosition':'odrl:relativeTemporalPosition',\n    'relativeSize':            'odrl:relativeSize',\n    'resolution':              'odrl:resolution',\n    'spatial':                 'odrl:spatial',\n    'spatialCoordinates':      'odrl:spatialCoordinates',\n    'systemDevice':            'odrl:systemDevice',\n    'timeInterval':            'odrl:timeInterval',\n    'unitOfCount':             'odrl:unitOfCount',\n    'version':                 'odrl:version',\n    'virtualLocation':         'odrl:virtualLocation',\n\n    'eq':                   'odrl:eq',\n    'gt':                   'odrl:gt',\n    'gteq':                 'odrl:gteq',\n    'lt':                   'odrl:lt',\n    'lteq':                 'odrl:lteq',\n    'neq':                  'odrl:neg',\n    'isA':                  'odrl:isA',\n    'hasPart':              'odrl:hasPart',\n    'isPartOf':             'odrl:isPartOf',\n    'isAllOf':              'odrl:isAllOf',\n    'isAnyOf':              'odrl:isAnyOf',\n    'isNoneOf':             'odrl:isNoneOf',\n    'or':                   'odrl:or',\n    'xone':                 'odrl:xone',\n    'and':                  'odrl:and',\n    'andSequence':          'odrl:andSequence',\n\n    'policyUsage':                'odrl:policyUsage'\n\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/vc/lib/contexts/odrl.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/vc/lib/contexts/vc-examples-v1.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/vc/lib/contexts/vc-examples-v1.js ***!
  \***********************************************************************/
/***/ ((module) => {

eval("/*!\n * Copyright (c) 2019-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n/* eslint-disable quote-props */\nmodule.exports = {\n  '@context': [\n    {\n      '@version': 1.1\n    },\n    'https://www.w3.org/ns/odrl.jsonld',\n    {\n      'ex': 'https://example.org/examples#',\n      'schema': 'http://schema.org/',\n      'rdf': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n\n      '3rdPartyCorrelation': 'ex:3rdPartyCorrelation',\n      'AllVerifiers': 'ex:AllVerifiers',\n      'Archival': 'ex:Archival',\n      'BachelorDegree': 'ex:BachelorDegree',\n      'Child': 'ex:Child',\n      'CLCredentialDefinition2019': 'ex:CLCredentialDefinition2019',\n      'CLSignature2019': 'ex:CLSignature2019',\n      'IssuerPolicy': 'ex:IssuerPolicy',\n      'HolderPolicy': 'ex:HolderPolicy',\n      'Mother': 'ex:Mother',\n      'RelationshipCredential': 'ex:RelationshipCredential',\n      'UniversityDegreeCredential': 'ex:UniversityDegreeCredential',\n      'ZkpExampleSchema2018': 'ex:ZkpExampleSchema2018',\n\n      'alumniOf': {'@id': 'schema:alumniOf', '@type': 'rdf:HTML'},\n      'child': {'@id': 'ex:child', '@type': '@id'},\n      'degree': 'ex:degree',\n      'name': {'@id': 'schema:name', '@type': 'rdf:HTML'},\n      'parent': {'@id': 'ex:parent', '@type': '@id'},\n      'referenceId': 'ex:referenceId',\n      'documentPresence': 'ex:documentPresence',\n      'evidenceDocument': 'ex:evidenceDocument',\n      'subjectPresence': 'ex:subjectPresence',\n      'verifier': {'@id': 'ex:verifier', '@type': '@id'},\n    }\n  ]\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/vc/lib/contexts/vc-examples-v1.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/vc/lib/documentLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/@digitalbazaar/vc/lib/documentLoader.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2019-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n// load locally embedded contexts\nconst contexts = __webpack_require__(/*! ./contexts */ \"./node_modules/@digitalbazaar/vc/lib/contexts/index.js\");\n\nmodule.exports = async function documentLoader(url) {\n  const context = contexts[url];\n  if(context !== undefined) {\n    return {\n      contextUrl: null,\n      documentUrl: url,\n      document: context\n    };\n  }\n  throw new Error(`Document loader unable to load URL \"${url}\".`);\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/vc/lib/documentLoader.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/vc/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@digitalbazaar/vc/lib/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * A library for working with verifiable credentials - vc library.\n *\n * @author David I. Lehn\n *\n * Copyright 2017-2021 Digital Bazaar, Inc.\n */\nmodule.exports = __webpack_require__(/*! ./vc.js */ \"./node_modules/@digitalbazaar/vc/lib/vc.js\");\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/vc/lib/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/vc/lib/vc.js":
/*!**************************************************!*\
  !*** ./node_modules/@digitalbazaar/vc/lib/vc.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * A JavaScript implementation of Verifiable Credentials.\n *\n * @author Dave Longley\n * @author David I. Lehn\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2017-2021 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\nconst jsonld = __webpack_require__(/*! jsonld */ \"./node_modules/jsonld/lib/jsonld.js\");\nconst jsigs = __webpack_require__(/*! jsonld-signatures */ \"./node_modules/jsonld-signatures/lib/jsonld-signatures.js\");\nconst {AuthenticationProofPurpose} = (__webpack_require__(/*! jsonld-signatures */ \"./node_modules/jsonld-signatures/lib/jsonld-signatures.js\").purposes);\nconst CredentialIssuancePurpose = __webpack_require__(/*! ./CredentialIssuancePurpose */ \"./node_modules/@digitalbazaar/vc/lib/CredentialIssuancePurpose.js\");\nconst defaultDocumentLoader = jsigs.extendContextLoader(\n  __webpack_require__(/*! ./documentLoader */ \"./node_modules/@digitalbazaar/vc/lib/documentLoader.js\"));\nconst {constants: {CREDENTIALS_CONTEXT_V1_URL}} =\n  __webpack_require__(/*! credentials-context */ \"./node_modules/credentials-context/dist/context.esm.js\");\n\n// Z and T can be lowercase\n// RFC3339 regex\nconst dateRegex = new RegExp('^(\\\\d{4})-(0[1-9]|1[0-2])-' +\n    '(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):' +\n    '([0-5][0-9]):([0-5][0-9]|60)' +\n    '(\\\\.[0-9]+)?(Z|(\\\\+|-)([01][0-9]|2[0-3]):' +\n    '([0-5][0-9]))$', 'i');\n\nmodule.exports = {\n  issue,\n  createPresentation,\n  signPresentation,\n  verify,\n  verifyCredential,\n  CredentialIssuancePurpose,\n  defaultDocumentLoader,\n  // export for testing:\n  _checkCredential,\n  _checkPresentation,\n  dateRegex\n};\n\n/**\n * @typedef {object} VerifyPresentationResult\n * @property {boolean} verified - True if verified, false if not.\n * @property {object} presentationResult\n * @property {Array} credentialResults\n * @property {object} error\n */\n\n/**\n * @typedef {object} VerifyCredentialResult\n * @property {boolean} verified - True if verified, false if not.\n * @property {object} statusResult\n * @property {Array} results\n * @property {object} error\n */\n\n/**\n * Issues a verifiable credential (by taking a base credential document,\n * and adding a digital signature to it).\n *\n * @param {object} [options={}] - The options to use.\n *\n * @param {object} options.credential - Base credential document.\n * @param {LinkedDataSignature} options.suite - Signature suite (with private\n *   key material), passed in to sign().\n *\n * Either pass in a ProofPurpose, or a default one will be created:\n * @param {ProofPurpose} [options.purpose]\n *\n * Other optional params passed to `sign()`:\n * @param {object} [options.documentLoader] - A document loader.\n * @param {object} [options.expansionMap] - An expansion map.\n *\n * @throws {Error} If missing required properties.\n *\n * @returns {Promise<VerifiableCredential>} Resolves on completion.\n */\nasync function issue({\n  credential, suite, expansionMap,\n  purpose = new CredentialIssuancePurpose(),\n  documentLoader = defaultDocumentLoader\n} = {}) {\n  // check to make sure the `suite` has required params\n  // Note: verificationMethod defaults to publicKey.id, in suite constructor\n  if(!suite) {\n    throw new TypeError('\"suite\" parameter is required for issuing.');\n  }\n  if(!suite.verificationMethod) {\n    throw new TypeError('\"suite.verificationMethod\" property is required.');\n  }\n\n  if(!credential) {\n    throw new TypeError('\"credential\" parameter is required for issuing.');\n  }\n\n  // Set the issuance date to now(), if missing\n  if(!credential.issuanceDate) {\n    const now = (new Date()).toJSON();\n    credential.issuanceDate = `${now.substr(0, now.length - 5)}Z`;\n  }\n\n  // run common credential checks\n  _checkCredential(credential);\n\n  return jsigs.sign(credential, {purpose, documentLoader, suite, expansionMap});\n}\n\n/**\n * Verifies a verifiable presentation:\n *   - Checks that the presentation is well-formed\n *   - Checks the proofs (for example, checks digital signatures against the\n *     provided public keys).\n *\n * @param {object} [options={}] - The options to use.\n *\n * @param {VerifiablePresentation} options.presentation - Verifiable\n *   presentation, signed or unsigned, that may contain within it a\n *   verifiable credential.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} suite - One or more\n *   signature suites that are supported by the caller's use case. This is\n *   an explicit design decision -- the calling code must specify which\n *   signature types (ed25519, RSA, etc) are allowed.\n *   Although it is expected that the secure resolution/fetching of the public\n *   key material (to verify against) is to be handled by the documentLoader,\n *   the suite param can optionally include the key directly.\n *\n * @param {boolean} [options.unsignedPresentation=false] - By default, this\n *   function assumes that a presentation is signed (and will return an error if\n *   a `proof` section is missing). Set this to `true` if you're using an\n *   unsigned presentation.\n *\n * Either pass in a proof purpose,\n * @param {AuthenticationProofPurpose} [options.presentationPurpose] - Optional\n *   proof purpose (a default one will be created if not passed in).\n *\n * or a default purpose will be created with params:\n * @param {string} [options.challenge] - Required if purpose is not passed in.\n * @param {string} [options.controller]\n * @param {string} [options.domain]\n *\n * @param {Function} [options.documentLoader]\n * @param {Function} [options.checkStatus]\n *\n * @returns {Promise<VerifyPresentationResult>} The verification result.\n */\nasync function verify(options = {}) {\n  const {presentation} = options;\n  try {\n    if(!presentation) {\n      throw new TypeError(\n        'A \"presentation\" property is required for verifying.');\n    }\n    return _verifyPresentation(options);\n  } catch(error) {\n    return {\n      verified: false,\n      results: [{presentation, verified: false, error}],\n      error\n    };\n  }\n}\n\n/**\n * Verifies a verifiable credential:\n *   - Checks that the credential is well-formed\n *   - Checks the proofs (for example, checks digital signatures against the\n *     provided public keys).\n *\n * @param {object} [options={}]\n *\n * @param {object} options.credential - Verifiable credential.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} suite - One or more\n *   signature suites that are supported by the caller's use case. This is\n *   an explicit design decision -- the calling code must specify which\n *   signature types (ed25519, RSA, etc) are allowed.\n *   Although it is expected that the secure resolution/fetching of the public\n *   key material (to verify against) is to be handled by the documentLoader,\n *   the suite param can optionally include the key directly.\n *\n * @param {CredentialIssuancePurpose} [options.purpose] - Optional\n *   proof purpose (a default one will be created if not passed in).\n * @param {Function} [options.documentLoader]\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n *\n * @returns {Promise<VerifyCredentialResult>} The verification result.\n */\nasync function verifyCredential(options = {}) {\n  const {credential} = options;\n  try {\n    if(!credential) {\n      throw new TypeError(\n        'A \"credential\" property is required for verifying.');\n    }\n    return _verifyCredential(options);\n  } catch(error) {\n    return {\n      verified: false,\n      results: [{credential, verified: false, error}],\n      error\n    };\n  }\n}\n\n/**\n * Verifies a verifiable credential.\n *\n * @private\n * @param {object} [options={}]\n *\n * @param {object} options.credential - Verifiable credential.\n * @param {LinkedDataSignature|LinkedDataSignature[]} suite - See the definition\n *   in the `verify()` docstring, for this param.\n *\n * @throws {Error} If required parameters are missing (in `_checkCredential`).\n *\n * @param {CredentialIssuancePurpose} [options.purpose]\n * @param {Function} [options.documentLoader]\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n *\n * @returns {Promise<VerifyCredentialResult>} The verification result.\n */\nasync function _verifyCredential(options = {}) {\n  const {credential, checkStatus} = options;\n\n  // run common credential checks\n  _checkCredential(credential);\n\n  // if credential status is provided, a `checkStatus` function must be given\n  if(credential.credentialStatus && typeof options.checkStatus !== 'function') {\n    throw new TypeError(\n      'A \"checkStatus\" function must be given to verify credentials with ' +\n      '\"credentialStatus\".');\n  }\n\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n\n  const {controller} = options;\n  const purpose = options.purpose || new CredentialIssuancePurpose({\n    controller\n  });\n\n  const result = await jsigs.verify(\n    credential, {purpose, documentLoader, ...options});\n\n  // if verification has already failed, skip status check\n  if(!result.verified) {\n    return result;\n  }\n\n  if(credential.credentialStatus) {\n    result.statusResult = await checkStatus(options);\n    if(!result.statusResult.verified) {\n      result.verified = false;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Creates an unsigned presentation from a given verifiable credential.\n *\n * @param {object} options - Options to use.\n * @param {object|Array<object>} [options.verifiableCredential] - One or more\n *   verifiable credential.\n * @param {string} [options.id] - Optional VP id.\n * @param {string} [options.holder] - Optional presentation holder url.\n *\n * @throws {TypeError} If verifiableCredential param is missing.\n * @throws {Error} If the credential (or the presentation params) are missing\n *   required properties.\n *\n * @returns {Presentation} The credential wrapped inside of a\n *   VerifiablePresentation.\n */\nfunction createPresentation({verifiableCredential, id, holder} = {}) {\n  const presentation = {\n    '@context': [CREDENTIALS_CONTEXT_V1_URL],\n    type: ['VerifiablePresentation']\n  };\n  if(verifiableCredential) {\n    const credentials = [].concat(verifiableCredential);\n    // ensure all credentials are valid\n    for(const credential of credentials) {\n      _checkCredential(credential);\n    }\n    presentation.verifiableCredential = credentials;\n  }\n  if(id) {\n    presentation.id = id;\n  }\n  if(holder) {\n    presentation.holder = holder;\n  }\n\n  _checkPresentation(presentation);\n\n  return presentation;\n}\n\n/**\n * Signs a given presentation.\n *\n * @param {object} [options={}] - Options to use.\n *\n * Required:\n * @param {Presentation} options.presentation\n * @param {LinkedDataSignature} options.suite - passed in to sign()\n *\n * Either pass in a ProofPurpose, or a default one will be created with params:\n * @param {ProofPurpose} [options.purpose]\n * @param {string} [options.domain]\n * @param {string} options.challenge - Required.\n *\n * @param {Function} [options.documentLoader]\n *\n * @returns {Promise<{VerifiablePresentation}>} A VerifiablePresentation with\n *   a proof.\n */\nasync function signPresentation(options = {}) {\n  const {presentation, domain, challenge} = options;\n  const purpose = options.purpose || new AuthenticationProofPurpose({\n    domain,\n    challenge\n  });\n\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n\n  return jsigs.sign(presentation, {purpose, documentLoader, ...options});\n}\n\n/**\n * Verifies that the VerifiablePresentation is well formed, and checks the\n * proof signature if it's present. Also verifies all the VerifiableCredentials\n * that are present in the presentation, if any.\n *\n * @param {object} [options={}]\n * @param {VerifiablePresentation} options.presentation\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite - See the\n *   definition in the `verify()` docstring, for this param.\n *\n * @param {boolean} [options.unsignedPresentation=false] - By default, this\n *   function assumes that a presentation is signed (and will return an error if\n *   a `proof` section is missing). Set this to `true` if you're using an\n *   unsigned presentation.\n *\n * Either pass in a proof purpose,\n * @param {AuthenticationProofPurpose} [options.presentationPurpose]\n *\n * or a default purpose will be created with params:\n * @param {string} [options.challenge] - Required if purpose is not passed in.\n * @param {string} [options.controller]\n * @param {string} [options.domain]\n *\n * @param {Function} [options.documentLoader]\n * @param {Function} [options.checkStatus]\n *\n * @throws {Error} If presentation is missing required params.\n *\n * @returns {Promise<VerifyPresentationResult>} The verification result.\n */\nasync function _verifyPresentation(options = {}) {\n  const {presentation, unsignedPresentation} = options;\n\n  _checkPresentation(presentation);\n\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n\n  // FIXME: verify presentation first, then each individual credential\n  // only if that proof is verified\n\n  // if verifiableCredentials are present, verify them, individually\n  let credentialResults;\n  let verified = true;\n  const credentials = jsonld.getValues(presentation, 'verifiableCredential');\n  if(credentials.length > 0) {\n    // verify every credential in `verifiableCredential`\n    credentialResults = await Promise.all(credentials.map(credential => {\n      return verifyCredential({credential, documentLoader, ...options});\n    }));\n\n    for(const [i, credentialResult] of credentialResults.entries()) {\n      credentialResult.credentialId = credentials[i].id;\n    }\n\n    const allCredentialsVerified = credentialResults.every(r => r.verified);\n    if(!allCredentialsVerified) {\n      verified = false;\n    }\n  }\n\n  if(unsignedPresentation) {\n    // No need to verify the proof section of this presentation\n    return {verified, results: [presentation], credentialResults};\n  }\n\n  const {controller, domain, challenge} = options;\n  if(!options.presentationPurpose && !challenge) {\n    throw new Error(\n      'A \"challenge\" param is required for AuthenticationProofPurpose.');\n  }\n\n  const purpose = options.presentationPurpose ||\n    new AuthenticationProofPurpose({controller, domain, challenge});\n\n  const presentationResult = await jsigs.verify(\n    presentation, {purpose, documentLoader, ...options});\n\n  return {\n    presentationResult,\n    verified: verified && presentationResult.verified,\n    credentialResults,\n    error: presentationResult.error\n  };\n}\n\n/**\n * @param {string|object} obj - Either an object with an id property\n *   or a string that is an id.\n * @returns {string|undefined} Either an id or undefined.\n * @private\n *\n */\nfunction _getId(obj) {\n  if(typeof obj === 'string') {\n    return obj;\n  }\n\n  if(!('id' in obj)) {\n    return;\n  }\n\n  return obj.id;\n}\n\n/**\n * @param {object} presentation - An object that could be a presentation.\n * @throws {Error}\n * @private\n */\nfunction _checkPresentation(presentation) {\n  // normalize to an array to allow the common case of context being a string\n  const context = Array.isArray(presentation['@context']) ?\n    presentation['@context'] : [presentation['@context']];\n\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  if(context[0] !== CREDENTIALS_CONTEXT_V1_URL) {\n    throw new Error(\n      `\"${CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` +\n      'list of contexts.');\n  }\n\n  const types = jsonld.getValues(presentation, 'type');\n\n  // check type presence\n  if(!types.includes('VerifiablePresentation')) {\n    throw new Error('\"type\" must include \"VerifiablePresentation\".');\n  }\n}\n\n/**\n * @param {object} credential - An object that could be a VerifiableCredential.\n * @throws {Error}\n * @private\n */\nfunction _checkCredential(credential) {\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  if(credential['@context'][0] !== CREDENTIALS_CONTEXT_V1_URL) {\n    throw new Error(\n      `\"${CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` +\n      'list of contexts.');\n  }\n\n  // check type presence and cardinality\n  if(!credential.type) {\n    throw new Error('\"type\" property is required.');\n  }\n\n  if(!jsonld.getValues(credential, 'type').includes('VerifiableCredential')) {\n    throw new Error('\"type\" must include `VerifiableCredential`.');\n  }\n\n  if(!credential.credentialSubject) {\n    throw new Error('\"credentialSubject\" property is required.');\n  }\n\n  // If credentialSubject.id is present and is not a URI, reject it\n  if(credential.credentialSubject.id) {\n    _validateUriId({\n      id: credential.credentialSubject.id, propertyName: 'credentialSubject.id'\n    });\n  }\n\n  if(!credential.issuer) {\n    throw new Error('\"issuer\" property is required.');\n  }\n\n  // check issuanceDate cardinality\n  if(jsonld.getValues(credential, 'issuanceDate').length > 1) {\n    throw new Error('\"issuanceDate\" property can only have one value.');\n  }\n\n  // check issued is a date\n  if(!credential.issuanceDate) {\n    throw new Error('\"issuanceDate\" property is required.');\n  }\n\n  if('issuanceDate' in credential) {\n    if(!dateRegex.test(credential.issuanceDate)) {\n      throw new Error(\n        `\"issuanceDate\" must be a valid date: ${credential.issuanceDate}`);\n    }\n  }\n\n  // check issuer cardinality\n  if(jsonld.getValues(credential, 'issuer').length > 1) {\n    throw new Error('\"issuer\" property can only have one value.');\n  }\n\n  // check issuer is a URL\n  if('issuer' in credential) {\n    const issuer = _getId(credential.issuer);\n    if(!issuer) {\n      throw new Error(`\"issuer\" id is required.`);\n    }\n    _validateUriId({id: issuer, propertyName: 'issuer'});\n  }\n\n  if('credentialStatus' in credential) {\n    if(!credential.credentialStatus.id) {\n      throw new Error('\"credentialStatus\" must include an id.');\n    }\n    if(!credential.credentialStatus.type) {\n      throw new Error('\"credentialStatus\" must include a type.');\n    }\n  }\n\n  // check evidences are URLs\n  jsonld.getValues(credential, 'evidence').forEach(evidence => {\n    const evidenceId = _getId(evidence);\n    if(evidenceId) {\n      _validateUriId({id: evidenceId, propertyName: 'evidence'});\n    }\n  });\n\n  // check expires is a date\n  if('expirationDate' in credential &&\n      !dateRegex.test(credential.expirationDate)) {\n    throw new Error(\n      `\"expirationDate\" must be a valid date: ${credential.expirationDate}`);\n  }\n}\n\nfunction _validateUriId({id, propertyName}) {\n  let parsed;\n  try {\n    parsed = new URL(id);\n  } catch(e) {\n    const error = new TypeError(`\"${propertyName}\" must be a URI: \"${id}\".`);\n    error.cause = e;\n    throw error;\n  }\n\n  if(!parsed.protocol) {\n    throw new TypeError(`\"${propertyName}\" must be a URI: \"${id}\".`);\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/vc/lib/vc.js?");

/***/ }),

/***/ "./node_modules/@stablelib/binary/lib/binary.js":
/*!******************************************************!*\
  !*** ./node_modules/@stablelib/binary/lib/binary.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Package binary provides functions for encoding and decoding numbers in byte arrays.\n */\nvar int_1 = __webpack_require__(/*! @stablelib/int */ \"./node_modules/@stablelib/int/lib/int.js\");\n// TODO(dchest): add asserts for correct value ranges and array offsets.\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * signed 16-bit integer and returns it.\n */\nfunction readInt16BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (((array[offset + 0] << 8) | array[offset + 1]) << 16) >> 16;\n}\nexports.readInt16BE = readInt16BE;\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * unsigned 16-bit integer and returns it.\n */\nfunction readUint16BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset + 0] << 8) | array[offset + 1]) >>> 0;\n}\nexports.readUint16BE = readUint16BE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * signed 16-bit integer and returns it.\n */\nfunction readInt16LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (((array[offset + 1] << 8) | array[offset]) << 16) >> 16;\n}\nexports.readInt16LE = readInt16LE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * unsigned 16-bit integer and returns it.\n */\nfunction readUint16LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset + 1] << 8) | array[offset]) >>> 0;\n}\nexports.readUint16LE = readUint16LE;\n/**\n * Writes 2-byte big-endian representation of 16-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint16BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(2); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 8;\n    out[offset + 1] = value >>> 0;\n    return out;\n}\nexports.writeUint16BE = writeUint16BE;\nexports.writeInt16BE = writeUint16BE;\n/**\n * Writes 2-byte little-endian representation of 16-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint16LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(2); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    return out;\n}\nexports.writeUint16LE = writeUint16LE;\nexports.writeInt16LE = writeUint16LE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * signed 32-bit integer and returns it.\n */\nfunction readInt32BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3];\n}\nexports.readInt32BE = readInt32BE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * unsigned 32-bit integer and returns it.\n */\nfunction readUint32BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3]) >>> 0;\n}\nexports.readUint32BE = readUint32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * signed 32-bit integer and returns it.\n */\nfunction readInt32LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset];\n}\nexports.readInt32LE = readInt32LE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * unsigned 32-bit integer and returns it.\n */\nfunction readUint32LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset]) >>> 0;\n}\nexports.readUint32LE = readUint32LE;\n/**\n * Writes 4-byte big-endian representation of 32-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint32BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 24;\n    out[offset + 1] = value >>> 16;\n    out[offset + 2] = value >>> 8;\n    out[offset + 3] = value >>> 0;\n    return out;\n}\nexports.writeUint32BE = writeUint32BE;\nexports.writeInt32BE = writeUint32BE;\n/**\n * Writes 4-byte little-endian representation of 32-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint32LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    out[offset + 2] = value >>> 16;\n    out[offset + 3] = value >>> 24;\n    return out;\n}\nexports.writeUint32LE = writeUint32LE;\nexports.writeInt32LE = writeUint32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nfunction readInt64BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var hi = readInt32BE(array, offset);\n    var lo = readInt32BE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);\n}\nexports.readInt64BE = readInt64BE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nfunction readUint64BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var hi = readUint32BE(array, offset);\n    var lo = readUint32BE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\nexports.readUint64BE = readUint64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nfunction readInt64LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var lo = readInt32LE(array, offset);\n    var hi = readInt32LE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);\n}\nexports.readInt64LE = readInt64LE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nfunction readUint64LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var lo = readUint32LE(array, offset);\n    var hi = readUint32LE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\nexports.readUint64LE = readUint64LE;\n/**\n * Writes 8-byte big-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint64BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    writeUint32BE(value / 0x100000000 >>> 0, out, offset);\n    writeUint32BE(value >>> 0, out, offset + 4);\n    return out;\n}\nexports.writeUint64BE = writeUint64BE;\nexports.writeInt64BE = writeUint64BE;\n/**\n * Writes 8-byte little-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint64LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    writeUint32LE(value >>> 0, out, offset);\n    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);\n    return out;\n}\nexports.writeUint64LE = writeUint64LE;\nexports.writeInt64LE = writeUint64LE;\n/**\n * Reads bytes from array starting at offset as big-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nfunction readUintBE(bitLength, array, offset) {\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintBE: array is too short for the given bitLength\");\n    }\n    var result = 0;\n    var mul = 1;\n    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\nexports.readUintBE = readUintBE;\n/**\n * Reads bytes from array starting at offset as little-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nfunction readUintLE(bitLength, array, offset) {\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintLE: array is too short for the given bitLength\");\n    }\n    var result = 0;\n    var mul = 1;\n    for (var i = offset; i < offset + bitLength / 8; i++) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\nexports.readUintLE = readUintLE;\n/**\n * Writes a big-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nfunction writeUintBE(bitLength, value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(bitLength / 8); }\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n    }\n    if (!int_1.isSafeInteger(value)) {\n        throw new Error(\"writeUintBE value must be an integer\");\n    }\n    var div = 1;\n    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\nexports.writeUintBE = writeUintBE;\n/**\n * Writes a little-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nfunction writeUintLE(bitLength, value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(bitLength / 8); }\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n    }\n    if (!int_1.isSafeInteger(value)) {\n        throw new Error(\"writeUintLE value must be an integer\");\n    }\n    var div = 1;\n    for (var i = offset; i < offset + bitLength / 8; i++) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\nexports.writeUintLE = writeUintLE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * 32-bit floating-point number and returns it.\n */\nfunction readFloat32BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset);\n}\nexports.readFloat32BE = readFloat32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * 32-bit floating-point number and returns it.\n */\nfunction readFloat32LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset, true);\n}\nexports.readFloat32LE = readFloat32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nfunction readFloat64BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset);\n}\nexports.readFloat64BE = readFloat64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nfunction readFloat64LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset, true);\n}\nexports.readFloat64LE = readFloat64LE;\n/**\n * Writes 4-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat32BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value);\n    return out;\n}\nexports.writeFloat32BE = writeFloat32BE;\n/**\n * Writes 4-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat32LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value, true);\n    return out;\n}\nexports.writeFloat32LE = writeFloat32LE;\n/**\n * Writes 8-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat64BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value);\n    return out;\n}\nexports.writeFloat64BE = writeFloat64BE;\n/**\n * Writes 8-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat64LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value, true);\n    return out;\n}\nexports.writeFloat64LE = writeFloat64LE;\n//# sourceMappingURL=binary.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@stablelib/binary/lib/binary.js?");

/***/ }),

/***/ "./node_modules/@stablelib/ed25519/lib/ed25519.js":
/*!********************************************************!*\
  !*** ./node_modules/@stablelib/ed25519/lib/ed25519.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Package ed25519 implements Ed25519 public-key signature algorithm.\n */\nvar random_1 = __webpack_require__(/*! @stablelib/random */ \"./node_modules/@stablelib/random/lib/random.js\");\nvar sha512_1 = __webpack_require__(/*! @stablelib/sha512 */ \"./node_modules/@stablelib/sha512/lib/sha512.js\");\nvar wipe_1 = __webpack_require__(/*! @stablelib/wipe */ \"./node_modules/@stablelib/wipe/lib/wipe.js\");\nexports.SIGNATURE_LENGTH = 64;\nexports.PUBLIC_KEY_LENGTH = 32;\nexports.SECRET_KEY_LENGTH = 64;\nexports.SEED_LENGTH = 32;\n// Returns new zero-filled 16-element GF (Float64Array).\n// If passed an array of numbers, prefills the returned\n// array with them.\n//\n// We use Float64Array, because we need 48-bit numbers\n// for this implementation.\nfunction gf(init) {\n    var r = new Float64Array(16);\n    if (init) {\n        for (var i = 0; i < init.length; i++) {\n            r[i] = init[i];\n        }\n    }\n    return r;\n}\n// Base point.\nvar _9 = new Uint8Array(32);\n_9[0] = 9;\nvar gf0 = gf();\nvar gf1 = gf([1]);\nvar D = gf([\n    0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070,\n    0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203\n]);\nvar D2 = gf([\n    0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0,\n    0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406\n]);\nvar X = gf([\n    0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c,\n    0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169\n]);\nvar Y = gf([\n    0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666,\n    0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666\n]);\nvar I = gf([\n    0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43,\n    0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83\n]);\nfunction set25519(r, a) {\n    for (var i = 0; i < 16; i++) {\n        r[i] = a[i] | 0;\n    }\n}\nfunction car25519(o) {\n    var c = 1;\n    for (var i = 0; i < 16; i++) {\n        var v = o[i] + c + 65535;\n        c = Math.floor(v / 65536);\n        o[i] = v - c * 65536;\n    }\n    o[0] += c - 1 + 37 * (c - 1);\n}\nfunction sel25519(p, q, b) {\n    var c = ~(b - 1);\n    for (var i = 0; i < 16; i++) {\n        var t = c & (p[i] ^ q[i]);\n        p[i] ^= t;\n        q[i] ^= t;\n    }\n}\nfunction pack25519(o, n) {\n    var m = gf();\n    var t = gf();\n    for (var i = 0; i < 16; i++) {\n        t[i] = n[i];\n    }\n    car25519(t);\n    car25519(t);\n    car25519(t);\n    for (var j = 0; j < 2; j++) {\n        m[0] = t[0] - 0xffed;\n        for (var i = 1; i < 15; i++) {\n            m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);\n            m[i - 1] &= 0xffff;\n        }\n        m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);\n        var b = (m[15] >> 16) & 1;\n        m[14] &= 0xffff;\n        sel25519(t, m, 1 - b);\n    }\n    for (var i = 0; i < 16; i++) {\n        o[2 * i] = t[i] & 0xff;\n        o[2 * i + 1] = t[i] >> 8;\n    }\n}\nfunction verify32(x, y) {\n    var d = 0;\n    for (var i = 0; i < 32; i++) {\n        d |= x[i] ^ y[i];\n    }\n    return (1 & ((d - 1) >>> 8)) - 1;\n}\nfunction neq25519(a, b) {\n    var c = new Uint8Array(32);\n    var d = new Uint8Array(32);\n    pack25519(c, a);\n    pack25519(d, b);\n    return verify32(c, d);\n}\nfunction par25519(a) {\n    var d = new Uint8Array(32);\n    pack25519(d, a);\n    return d[0] & 1;\n}\nfunction unpack25519(o, n) {\n    for (var i = 0; i < 16; i++) {\n        o[i] = n[2 * i] + (n[2 * i + 1] << 8);\n    }\n    o[15] &= 0x7fff;\n}\nfunction add(o, a, b) {\n    for (var i = 0; i < 16; i++) {\n        o[i] = a[i] + b[i];\n    }\n}\nfunction sub(o, a, b) {\n    for (var i = 0; i < 16; i++) {\n        o[i] = a[i] - b[i];\n    }\n}\nfunction mul(o, a, b) {\n    var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];\n    v = a[0];\n    t0 += v * b0;\n    t1 += v * b1;\n    t2 += v * b2;\n    t3 += v * b3;\n    t4 += v * b4;\n    t5 += v * b5;\n    t6 += v * b6;\n    t7 += v * b7;\n    t8 += v * b8;\n    t9 += v * b9;\n    t10 += v * b10;\n    t11 += v * b11;\n    t12 += v * b12;\n    t13 += v * b13;\n    t14 += v * b14;\n    t15 += v * b15;\n    v = a[1];\n    t1 += v * b0;\n    t2 += v * b1;\n    t3 += v * b2;\n    t4 += v * b3;\n    t5 += v * b4;\n    t6 += v * b5;\n    t7 += v * b6;\n    t8 += v * b7;\n    t9 += v * b8;\n    t10 += v * b9;\n    t11 += v * b10;\n    t12 += v * b11;\n    t13 += v * b12;\n    t14 += v * b13;\n    t15 += v * b14;\n    t16 += v * b15;\n    v = a[2];\n    t2 += v * b0;\n    t3 += v * b1;\n    t4 += v * b2;\n    t5 += v * b3;\n    t6 += v * b4;\n    t7 += v * b5;\n    t8 += v * b6;\n    t9 += v * b7;\n    t10 += v * b8;\n    t11 += v * b9;\n    t12 += v * b10;\n    t13 += v * b11;\n    t14 += v * b12;\n    t15 += v * b13;\n    t16 += v * b14;\n    t17 += v * b15;\n    v = a[3];\n    t3 += v * b0;\n    t4 += v * b1;\n    t5 += v * b2;\n    t6 += v * b3;\n    t7 += v * b4;\n    t8 += v * b5;\n    t9 += v * b6;\n    t10 += v * b7;\n    t11 += v * b8;\n    t12 += v * b9;\n    t13 += v * b10;\n    t14 += v * b11;\n    t15 += v * b12;\n    t16 += v * b13;\n    t17 += v * b14;\n    t18 += v * b15;\n    v = a[4];\n    t4 += v * b0;\n    t5 += v * b1;\n    t6 += v * b2;\n    t7 += v * b3;\n    t8 += v * b4;\n    t9 += v * b5;\n    t10 += v * b6;\n    t11 += v * b7;\n    t12 += v * b8;\n    t13 += v * b9;\n    t14 += v * b10;\n    t15 += v * b11;\n    t16 += v * b12;\n    t17 += v * b13;\n    t18 += v * b14;\n    t19 += v * b15;\n    v = a[5];\n    t5 += v * b0;\n    t6 += v * b1;\n    t7 += v * b2;\n    t8 += v * b3;\n    t9 += v * b4;\n    t10 += v * b5;\n    t11 += v * b6;\n    t12 += v * b7;\n    t13 += v * b8;\n    t14 += v * b9;\n    t15 += v * b10;\n    t16 += v * b11;\n    t17 += v * b12;\n    t18 += v * b13;\n    t19 += v * b14;\n    t20 += v * b15;\n    v = a[6];\n    t6 += v * b0;\n    t7 += v * b1;\n    t8 += v * b2;\n    t9 += v * b3;\n    t10 += v * b4;\n    t11 += v * b5;\n    t12 += v * b6;\n    t13 += v * b7;\n    t14 += v * b8;\n    t15 += v * b9;\n    t16 += v * b10;\n    t17 += v * b11;\n    t18 += v * b12;\n    t19 += v * b13;\n    t20 += v * b14;\n    t21 += v * b15;\n    v = a[7];\n    t7 += v * b0;\n    t8 += v * b1;\n    t9 += v * b2;\n    t10 += v * b3;\n    t11 += v * b4;\n    t12 += v * b5;\n    t13 += v * b6;\n    t14 += v * b7;\n    t15 += v * b8;\n    t16 += v * b9;\n    t17 += v * b10;\n    t18 += v * b11;\n    t19 += v * b12;\n    t20 += v * b13;\n    t21 += v * b14;\n    t22 += v * b15;\n    v = a[8];\n    t8 += v * b0;\n    t9 += v * b1;\n    t10 += v * b2;\n    t11 += v * b3;\n    t12 += v * b4;\n    t13 += v * b5;\n    t14 += v * b6;\n    t15 += v * b7;\n    t16 += v * b8;\n    t17 += v * b9;\n    t18 += v * b10;\n    t19 += v * b11;\n    t20 += v * b12;\n    t21 += v * b13;\n    t22 += v * b14;\n    t23 += v * b15;\n    v = a[9];\n    t9 += v * b0;\n    t10 += v * b1;\n    t11 += v * b2;\n    t12 += v * b3;\n    t13 += v * b4;\n    t14 += v * b5;\n    t15 += v * b6;\n    t16 += v * b7;\n    t17 += v * b8;\n    t18 += v * b9;\n    t19 += v * b10;\n    t20 += v * b11;\n    t21 += v * b12;\n    t22 += v * b13;\n    t23 += v * b14;\n    t24 += v * b15;\n    v = a[10];\n    t10 += v * b0;\n    t11 += v * b1;\n    t12 += v * b2;\n    t13 += v * b3;\n    t14 += v * b4;\n    t15 += v * b5;\n    t16 += v * b6;\n    t17 += v * b7;\n    t18 += v * b8;\n    t19 += v * b9;\n    t20 += v * b10;\n    t21 += v * b11;\n    t22 += v * b12;\n    t23 += v * b13;\n    t24 += v * b14;\n    t25 += v * b15;\n    v = a[11];\n    t11 += v * b0;\n    t12 += v * b1;\n    t13 += v * b2;\n    t14 += v * b3;\n    t15 += v * b4;\n    t16 += v * b5;\n    t17 += v * b6;\n    t18 += v * b7;\n    t19 += v * b8;\n    t20 += v * b9;\n    t21 += v * b10;\n    t22 += v * b11;\n    t23 += v * b12;\n    t24 += v * b13;\n    t25 += v * b14;\n    t26 += v * b15;\n    v = a[12];\n    t12 += v * b0;\n    t13 += v * b1;\n    t14 += v * b2;\n    t15 += v * b3;\n    t16 += v * b4;\n    t17 += v * b5;\n    t18 += v * b6;\n    t19 += v * b7;\n    t20 += v * b8;\n    t21 += v * b9;\n    t22 += v * b10;\n    t23 += v * b11;\n    t24 += v * b12;\n    t25 += v * b13;\n    t26 += v * b14;\n    t27 += v * b15;\n    v = a[13];\n    t13 += v * b0;\n    t14 += v * b1;\n    t15 += v * b2;\n    t16 += v * b3;\n    t17 += v * b4;\n    t18 += v * b5;\n    t19 += v * b6;\n    t20 += v * b7;\n    t21 += v * b8;\n    t22 += v * b9;\n    t23 += v * b10;\n    t24 += v * b11;\n    t25 += v * b12;\n    t26 += v * b13;\n    t27 += v * b14;\n    t28 += v * b15;\n    v = a[14];\n    t14 += v * b0;\n    t15 += v * b1;\n    t16 += v * b2;\n    t17 += v * b3;\n    t18 += v * b4;\n    t19 += v * b5;\n    t20 += v * b6;\n    t21 += v * b7;\n    t22 += v * b8;\n    t23 += v * b9;\n    t24 += v * b10;\n    t25 += v * b11;\n    t26 += v * b12;\n    t27 += v * b13;\n    t28 += v * b14;\n    t29 += v * b15;\n    v = a[15];\n    t15 += v * b0;\n    t16 += v * b1;\n    t17 += v * b2;\n    t18 += v * b3;\n    t19 += v * b4;\n    t20 += v * b5;\n    t21 += v * b6;\n    t22 += v * b7;\n    t23 += v * b8;\n    t24 += v * b9;\n    t25 += v * b10;\n    t26 += v * b11;\n    t27 += v * b12;\n    t28 += v * b13;\n    t29 += v * b14;\n    t30 += v * b15;\n    t0 += 38 * t16;\n    t1 += 38 * t17;\n    t2 += 38 * t18;\n    t3 += 38 * t19;\n    t4 += 38 * t20;\n    t5 += 38 * t21;\n    t6 += 38 * t22;\n    t7 += 38 * t23;\n    t8 += 38 * t24;\n    t9 += 38 * t25;\n    t10 += 38 * t26;\n    t11 += 38 * t27;\n    t12 += 38 * t28;\n    t13 += 38 * t29;\n    t14 += 38 * t30;\n    // t15 left as is\n    // first car\n    c = 1;\n    v = t0 + c + 65535;\n    c = Math.floor(v / 65536);\n    t0 = v - c * 65536;\n    v = t1 + c + 65535;\n    c = Math.floor(v / 65536);\n    t1 = v - c * 65536;\n    v = t2 + c + 65535;\n    c = Math.floor(v / 65536);\n    t2 = v - c * 65536;\n    v = t3 + c + 65535;\n    c = Math.floor(v / 65536);\n    t3 = v - c * 65536;\n    v = t4 + c + 65535;\n    c = Math.floor(v / 65536);\n    t4 = v - c * 65536;\n    v = t5 + c + 65535;\n    c = Math.floor(v / 65536);\n    t5 = v - c * 65536;\n    v = t6 + c + 65535;\n    c = Math.floor(v / 65536);\n    t6 = v - c * 65536;\n    v = t7 + c + 65535;\n    c = Math.floor(v / 65536);\n    t7 = v - c * 65536;\n    v = t8 + c + 65535;\n    c = Math.floor(v / 65536);\n    t8 = v - c * 65536;\n    v = t9 + c + 65535;\n    c = Math.floor(v / 65536);\n    t9 = v - c * 65536;\n    v = t10 + c + 65535;\n    c = Math.floor(v / 65536);\n    t10 = v - c * 65536;\n    v = t11 + c + 65535;\n    c = Math.floor(v / 65536);\n    t11 = v - c * 65536;\n    v = t12 + c + 65535;\n    c = Math.floor(v / 65536);\n    t12 = v - c * 65536;\n    v = t13 + c + 65535;\n    c = Math.floor(v / 65536);\n    t13 = v - c * 65536;\n    v = t14 + c + 65535;\n    c = Math.floor(v / 65536);\n    t14 = v - c * 65536;\n    v = t15 + c + 65535;\n    c = Math.floor(v / 65536);\n    t15 = v - c * 65536;\n    t0 += c - 1 + 37 * (c - 1);\n    // second car\n    c = 1;\n    v = t0 + c + 65535;\n    c = Math.floor(v / 65536);\n    t0 = v - c * 65536;\n    v = t1 + c + 65535;\n    c = Math.floor(v / 65536);\n    t1 = v - c * 65536;\n    v = t2 + c + 65535;\n    c = Math.floor(v / 65536);\n    t2 = v - c * 65536;\n    v = t3 + c + 65535;\n    c = Math.floor(v / 65536);\n    t3 = v - c * 65536;\n    v = t4 + c + 65535;\n    c = Math.floor(v / 65536);\n    t4 = v - c * 65536;\n    v = t5 + c + 65535;\n    c = Math.floor(v / 65536);\n    t5 = v - c * 65536;\n    v = t6 + c + 65535;\n    c = Math.floor(v / 65536);\n    t6 = v - c * 65536;\n    v = t7 + c + 65535;\n    c = Math.floor(v / 65536);\n    t7 = v - c * 65536;\n    v = t8 + c + 65535;\n    c = Math.floor(v / 65536);\n    t8 = v - c * 65536;\n    v = t9 + c + 65535;\n    c = Math.floor(v / 65536);\n    t9 = v - c * 65536;\n    v = t10 + c + 65535;\n    c = Math.floor(v / 65536);\n    t10 = v - c * 65536;\n    v = t11 + c + 65535;\n    c = Math.floor(v / 65536);\n    t11 = v - c * 65536;\n    v = t12 + c + 65535;\n    c = Math.floor(v / 65536);\n    t12 = v - c * 65536;\n    v = t13 + c + 65535;\n    c = Math.floor(v / 65536);\n    t13 = v - c * 65536;\n    v = t14 + c + 65535;\n    c = Math.floor(v / 65536);\n    t14 = v - c * 65536;\n    v = t15 + c + 65535;\n    c = Math.floor(v / 65536);\n    t15 = v - c * 65536;\n    t0 += c - 1 + 37 * (c - 1);\n    o[0] = t0;\n    o[1] = t1;\n    o[2] = t2;\n    o[3] = t3;\n    o[4] = t4;\n    o[5] = t5;\n    o[6] = t6;\n    o[7] = t7;\n    o[8] = t8;\n    o[9] = t9;\n    o[10] = t10;\n    o[11] = t11;\n    o[12] = t12;\n    o[13] = t13;\n    o[14] = t14;\n    o[15] = t15;\n}\nfunction square(o, a) {\n    mul(o, a, a);\n}\nfunction inv25519(o, i) {\n    var c = gf();\n    var a;\n    for (a = 0; a < 16; a++) {\n        c[a] = i[a];\n    }\n    for (a = 253; a >= 0; a--) {\n        square(c, c);\n        if (a !== 2 && a !== 4) {\n            mul(c, c, i);\n        }\n    }\n    for (a = 0; a < 16; a++) {\n        o[a] = c[a];\n    }\n}\nfunction pow2523(o, i) {\n    var c = gf();\n    var a;\n    for (a = 0; a < 16; a++) {\n        c[a] = i[a];\n    }\n    for (a = 250; a >= 0; a--) {\n        square(c, c);\n        if (a !== 1) {\n            mul(c, c, i);\n        }\n    }\n    for (a = 0; a < 16; a++) {\n        o[a] = c[a];\n    }\n}\nfunction edadd(p, q) {\n    var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();\n    sub(a, p[1], p[0]);\n    sub(t, q[1], q[0]);\n    mul(a, a, t);\n    add(b, p[0], p[1]);\n    add(t, q[0], q[1]);\n    mul(b, b, t);\n    mul(c, p[3], q[3]);\n    mul(c, c, D2);\n    mul(d, p[2], q[2]);\n    add(d, d, d);\n    sub(e, b, a);\n    sub(f, d, c);\n    add(g, d, c);\n    add(h, b, a);\n    mul(p[0], e, f);\n    mul(p[1], h, g);\n    mul(p[2], g, f);\n    mul(p[3], e, h);\n}\nfunction cswap(p, q, b) {\n    for (var i = 0; i < 4; i++) {\n        sel25519(p[i], q[i], b);\n    }\n}\nfunction pack(r, p) {\n    var tx = gf(), ty = gf(), zi = gf();\n    inv25519(zi, p[2]);\n    mul(tx, p[0], zi);\n    mul(ty, p[1], zi);\n    pack25519(r, ty);\n    r[31] ^= par25519(tx) << 7;\n}\nfunction scalarmult(p, q, s) {\n    set25519(p[0], gf0);\n    set25519(p[1], gf1);\n    set25519(p[2], gf1);\n    set25519(p[3], gf0);\n    for (var i = 255; i >= 0; --i) {\n        var b = (s[(i / 8) | 0] >> (i & 7)) & 1;\n        cswap(p, q, b);\n        edadd(q, p);\n        edadd(p, p);\n        cswap(p, q, b);\n    }\n}\nfunction scalarbase(p, s) {\n    var q = [gf(), gf(), gf(), gf()];\n    set25519(q[0], X);\n    set25519(q[1], Y);\n    set25519(q[2], gf1);\n    mul(q[3], X, Y);\n    scalarmult(p, q, s);\n}\n// Generates key pair from secret 32-byte seed.\nfunction generateKeyPairFromSeed(seed) {\n    if (seed.length !== exports.SEED_LENGTH) {\n        throw new Error(\"ed25519: seed must be \" + exports.SEED_LENGTH + \" bytes\");\n    }\n    var d = sha512_1.hash(seed);\n    d[0] &= 248;\n    d[31] &= 127;\n    d[31] |= 64;\n    var publicKey = new Uint8Array(32);\n    var p = [gf(), gf(), gf(), gf()];\n    scalarbase(p, d);\n    pack(publicKey, p);\n    var secretKey = new Uint8Array(64);\n    secretKey.set(seed);\n    secretKey.set(publicKey, 32);\n    return {\n        publicKey: publicKey,\n        secretKey: secretKey\n    };\n}\nexports.generateKeyPairFromSeed = generateKeyPairFromSeed;\nfunction generateKeyPair(prng) {\n    var seed = random_1.randomBytes(32, prng);\n    var result = generateKeyPairFromSeed(seed);\n    wipe_1.wipe(seed);\n    return result;\n}\nexports.generateKeyPair = generateKeyPair;\nfunction extractPublicKeyFromSecretKey(secretKey) {\n    if (secretKey.length !== exports.SECRET_KEY_LENGTH) {\n        throw new Error(\"ed25519: secret key must be \" + exports.SECRET_KEY_LENGTH + \" bytes\");\n    }\n    return new Uint8Array(secretKey.subarray(32));\n}\nexports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;\nvar L = new Float64Array([\n    0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2,\n    0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10\n]);\nfunction modL(r, x) {\n    var carry;\n    var i;\n    var j;\n    var k;\n    for (i = 63; i >= 32; --i) {\n        carry = 0;\n        for (j = i - 32, k = i - 12; j < k; ++j) {\n            x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n            carry = Math.floor((x[j] + 128) / 256);\n            x[j] -= carry * 256;\n        }\n        x[j] += carry;\n        x[i] = 0;\n    }\n    carry = 0;\n    for (j = 0; j < 32; j++) {\n        x[j] += carry - (x[31] >> 4) * L[j];\n        carry = x[j] >> 8;\n        x[j] &= 255;\n    }\n    for (j = 0; j < 32; j++) {\n        x[j] -= carry * L[j];\n    }\n    for (i = 0; i < 32; i++) {\n        x[i + 1] += x[i] >> 8;\n        r[i] = x[i] & 255;\n    }\n}\nfunction reduce(r) {\n    var x = new Float64Array(64);\n    for (var i = 0; i < 64; i++) {\n        x[i] = r[i];\n    }\n    for (var i = 0; i < 64; i++) {\n        r[i] = 0;\n    }\n    modL(r, x);\n}\n// Returns 64-byte signature of the message under the 64-byte secret key.\nfunction sign(secretKey, message) {\n    var x = new Float64Array(64);\n    var p = [gf(), gf(), gf(), gf()];\n    var d = sha512_1.hash(secretKey.subarray(0, 32));\n    d[0] &= 248;\n    d[31] &= 127;\n    d[31] |= 64;\n    var signature = new Uint8Array(64);\n    signature.set(d.subarray(32), 32);\n    var hs = new sha512_1.SHA512();\n    hs.update(signature.subarray(32));\n    hs.update(message);\n    var r = hs.digest();\n    hs.clean();\n    reduce(r);\n    scalarbase(p, r);\n    pack(signature, p);\n    hs.reset();\n    hs.update(signature.subarray(0, 32));\n    hs.update(secretKey.subarray(32));\n    hs.update(message);\n    var h = hs.digest();\n    reduce(h);\n    for (var i = 0; i < 32; i++) {\n        x[i] = r[i];\n    }\n    for (var i = 0; i < 32; i++) {\n        for (var j = 0; j < 32; j++) {\n            x[i + j] += h[i] * d[j];\n        }\n    }\n    modL(signature.subarray(32), x);\n    return signature;\n}\nexports.sign = sign;\nfunction unpackneg(r, p) {\n    var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();\n    set25519(r[2], gf1);\n    unpack25519(r[1], p);\n    square(num, r[1]);\n    mul(den, num, D);\n    sub(num, num, r[2]);\n    add(den, r[2], den);\n    square(den2, den);\n    square(den4, den2);\n    mul(den6, den4, den2);\n    mul(t, den6, num);\n    mul(t, t, den);\n    pow2523(t, t);\n    mul(t, t, num);\n    mul(t, t, den);\n    mul(t, t, den);\n    mul(r[0], t, den);\n    square(chk, r[0]);\n    mul(chk, chk, den);\n    if (neq25519(chk, num)) {\n        mul(r[0], r[0], I);\n    }\n    square(chk, r[0]);\n    mul(chk, chk, den);\n    if (neq25519(chk, num)) {\n        return -1;\n    }\n    if (par25519(r[0]) === (p[31] >> 7)) {\n        sub(r[0], gf0, r[0]);\n    }\n    mul(r[3], r[0], r[1]);\n    return 0;\n}\nfunction verify(publicKey, message, signature) {\n    var t = new Uint8Array(32);\n    var p = [gf(), gf(), gf(), gf()];\n    var q = [gf(), gf(), gf(), gf()];\n    if (signature.length !== exports.SIGNATURE_LENGTH) {\n        throw new Error(\"ed25519: signature must be \" + exports.SIGNATURE_LENGTH + \" bytes\");\n    }\n    if (unpackneg(q, publicKey)) {\n        return false;\n    }\n    var hs = new sha512_1.SHA512();\n    hs.update(signature.subarray(0, 32));\n    hs.update(publicKey);\n    hs.update(message);\n    var h = hs.digest();\n    reduce(h);\n    scalarmult(p, q, h);\n    scalarbase(q, signature.subarray(32));\n    edadd(p, q);\n    pack(t, p);\n    if (verify32(signature, t)) {\n        return false;\n    }\n    return true;\n}\nexports.verify = verify;\n/**\n * Convert Ed25519 public key to X25519 public key.\n *\n * Throws if given an invalid public key.\n */\nfunction convertPublicKeyToX25519(publicKey) {\n    var q = [gf(), gf(), gf(), gf()];\n    if (unpackneg(q, publicKey)) {\n        throw new Error(\"Ed25519: invalid public key\");\n    }\n    // Formula: montgomeryX = (edwardsY + 1)*inverse(1 - edwardsY) mod p\n    var a = gf();\n    var b = gf();\n    var y = q[1];\n    add(a, gf1, y);\n    sub(b, gf1, y);\n    inv25519(b, b);\n    mul(a, a, b);\n    var z = new Uint8Array(32);\n    pack25519(z, a);\n    return z;\n}\nexports.convertPublicKeyToX25519 = convertPublicKeyToX25519;\n/**\n *  Convert Ed25519 secret (private) key to X25519 secret key.\n */\nfunction convertSecretKeyToX25519(secretKey) {\n    var d = sha512_1.hash(secretKey.subarray(0, 32));\n    d[0] &= 248;\n    d[31] &= 127;\n    d[31] |= 64;\n    var o = new Uint8Array(d.subarray(0, 32));\n    wipe_1.wipe(d);\n    return o;\n}\nexports.convertSecretKeyToX25519 = convertSecretKeyToX25519;\n//# sourceMappingURL=ed25519.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@stablelib/ed25519/lib/ed25519.js?");

/***/ }),

/***/ "./node_modules/@stablelib/int/lib/int.js":
/*!************************************************!*\
  !*** ./node_modules/@stablelib/int/lib/int.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Package int provides helper functions for integerss.\n */\n// Shim using 16-bit pieces.\nfunction imulShim(a, b) {\n    var ah = (a >>> 16) & 0xffff, al = a & 0xffff;\n    var bh = (b >>> 16) & 0xffff, bl = b & 0xffff;\n    return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);\n}\n/** 32-bit integer multiplication.  */\n// Use system Math.imul if available, otherwise use our shim.\nexports.mul = Math.imul || imulShim;\n/** 32-bit integer addition.  */\nfunction add(a, b) {\n    return (a + b) | 0;\n}\nexports.add = add;\n/**  32-bit integer subtraction.  */\nfunction sub(a, b) {\n    return (a - b) | 0;\n}\nexports.sub = sub;\n/** 32-bit integer left rotation */\nfunction rotl(x, n) {\n    return x << n | x >>> (32 - n);\n}\nexports.rotl = rotl;\n/** 32-bit integer left rotation */\nfunction rotr(x, n) {\n    return x << (32 - n) | x >>> n;\n}\nexports.rotr = rotr;\nfunction isIntegerShim(n) {\n    return typeof n === \"number\" && isFinite(n) && Math.floor(n) === n;\n}\n/**\n * Returns true if the argument is an integer number.\n *\n * In ES2015, Number.isInteger.\n */\nexports.isInteger = Number.isInteger || isIntegerShim;\n/**\n *  Math.pow(2, 53) - 1\n *\n *  In ES2015 Number.MAX_SAFE_INTEGER.\n */\nexports.MAX_SAFE_INTEGER = 9007199254740991;\n/**\n * Returns true if the argument is a safe integer number\n * (-MIN_SAFE_INTEGER < number <= MAX_SAFE_INTEGER)\n *\n * In ES2015, Number.isSafeInteger.\n */\nexports.isSafeInteger = function (n) {\n    return exports.isInteger(n) && (n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER);\n};\n//# sourceMappingURL=int.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@stablelib/int/lib/int.js?");

/***/ }),

/***/ "./node_modules/@stablelib/random/lib/random.js":
/*!******************************************************!*\
  !*** ./node_modules/@stablelib/random/lib/random.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar system_1 = __webpack_require__(/*! ./source/system */ \"./node_modules/@stablelib/random/lib/source/system.js\");\nvar binary_1 = __webpack_require__(/*! @stablelib/binary */ \"./node_modules/@stablelib/binary/lib/binary.js\");\nvar wipe_1 = __webpack_require__(/*! @stablelib/wipe */ \"./node_modules/@stablelib/wipe/lib/wipe.js\");\nexports.defaultRandomSource = new system_1.SystemRandomSource();\nfunction randomBytes(length, prng) {\n    if (prng === void 0) { prng = exports.defaultRandomSource; }\n    return prng.randomBytes(length);\n}\nexports.randomBytes = randomBytes;\n/**\n * Returns a uniformly random unsigned 32-bit integer.\n */\nfunction randomUint32(prng) {\n    if (prng === void 0) { prng = exports.defaultRandomSource; }\n    // Generate 4-byte random buffer.\n    var buf = randomBytes(4, prng);\n    // Convert bytes from buffer into a 32-bit integer.\n    // It's not important which byte order to use, since\n    // the result is random.\n    var result = binary_1.readUint32LE(buf);\n    // Clean the buffer.\n    wipe_1.wipe(buf);\n    return result;\n}\nexports.randomUint32 = randomUint32;\n/** 62 alphanumeric characters for default charset of randomString() */\nvar ALPHANUMERIC = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n/**\n * Returns a uniform random string of the given length\n * with characters from the given charset.\n *\n * Charset must not have more than 256 characters.\n *\n * Default charset generates case-sensitive alphanumeric\n * strings (0-9, A-Z, a-z).\n */\nfunction randomString(length, charset, prng) {\n    if (charset === void 0) { charset = ALPHANUMERIC; }\n    if (prng === void 0) { prng = exports.defaultRandomSource; }\n    if (charset.length < 2) {\n        throw new Error(\"randomString charset is too short\");\n    }\n    if (charset.length > 256) {\n        throw new Error(\"randomString charset is too long\");\n    }\n    var out = '';\n    var charsLen = charset.length;\n    var maxByte = 256 - (256 % charsLen);\n    while (length > 0) {\n        var buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);\n        for (var i = 0; i < buf.length && length > 0; i++) {\n            var randomByte = buf[i];\n            if (randomByte < maxByte) {\n                out += charset.charAt(randomByte % charsLen);\n                length--;\n            }\n        }\n        wipe_1.wipe(buf);\n    }\n    return out;\n}\nexports.randomString = randomString;\n/**\n * Returns uniform random string containing at least the given\n * number of bits of entropy.\n *\n * For example, randomStringForEntropy(128) will return a 22-character\n * alphanumeric string, while randomStringForEntropy(128, \"0123456789\")\n * will return a 39-character numeric string, both will contain at\n * least 128 bits of entropy.\n *\n * Default charset generates case-sensitive alphanumeric\n * strings (0-9, A-Z, a-z).\n */\nfunction randomStringForEntropy(bits, charset, prng) {\n    if (charset === void 0) { charset = ALPHANUMERIC; }\n    if (prng === void 0) { prng = exports.defaultRandomSource; }\n    var length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));\n    return randomString(length, charset, prng);\n}\nexports.randomStringForEntropy = randomStringForEntropy;\n//# sourceMappingURL=random.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@stablelib/random/lib/random.js?");

/***/ }),

/***/ "./node_modules/@stablelib/random/lib/source/browser.js":
/*!**************************************************************!*\
  !*** ./node_modules/@stablelib/random/lib/source/browser.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar QUOTA = 65536;\nvar BrowserRandomSource = /** @class */ (function () {\n    function BrowserRandomSource() {\n        this.isAvailable = false;\n        this.isInstantiated = false;\n        var browserCrypto = typeof self !== 'undefined'\n            ? (self.crypto || self.msCrypto) // IE11 has msCrypto\n            : null;\n        if (browserCrypto && browserCrypto.getRandomValues) {\n            this._crypto = browserCrypto;\n            this.isAvailable = true;\n            this.isInstantiated = true;\n        }\n    }\n    BrowserRandomSource.prototype.randomBytes = function (length) {\n        if (!this.isAvailable || !this._crypto) {\n            throw new Error(\"Browser random byte generator is not available.\");\n        }\n        var out = new Uint8Array(length);\n        for (var i = 0; i < out.length; i += QUOTA) {\n            this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));\n        }\n        return out;\n    };\n    return BrowserRandomSource;\n}());\nexports.BrowserRandomSource = BrowserRandomSource;\n//# sourceMappingURL=browser.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@stablelib/random/lib/source/browser.js?");

/***/ }),

/***/ "./node_modules/@stablelib/random/lib/source/node.js":
/*!***********************************************************!*\
  !*** ./node_modules/@stablelib/random/lib/source/node.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar wipe_1 = __webpack_require__(/*! @stablelib/wipe */ \"./node_modules/@stablelib/wipe/lib/wipe.js\");\nvar NodeRandomSource = /** @class */ (function () {\n    function NodeRandomSource() {\n        this.isAvailable = false;\n        this.isInstantiated = false;\n        if (true) {\n            var nodeCrypto = __webpack_require__(/*! crypto */ \"?25ed\");\n            if (nodeCrypto && nodeCrypto.randomBytes) {\n                this._crypto = nodeCrypto;\n                this.isAvailable = true;\n                this.isInstantiated = true;\n            }\n        }\n    }\n    NodeRandomSource.prototype.randomBytes = function (length) {\n        if (!this.isAvailable || !this._crypto) {\n            throw new Error(\"Node.js random byte generator is not available.\");\n        }\n        // Get random bytes (result is Buffer).\n        var buffer = this._crypto.randomBytes(length);\n        // Make sure we got the length that we requested.\n        if (buffer.length !== length) {\n            throw new Error(\"NodeRandomSource: got fewer bytes than requested\");\n        }\n        // Allocate output array.\n        var out = new Uint8Array(length);\n        // Copy bytes from buffer to output.\n        for (var i = 0; i < out.length; i++) {\n            out[i] = buffer[i];\n        }\n        // Cleanup.\n        wipe_1.wipe(buffer);\n        return out;\n    };\n    return NodeRandomSource;\n}());\nexports.NodeRandomSource = NodeRandomSource;\n//# sourceMappingURL=node.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@stablelib/random/lib/source/node.js?");

/***/ }),

/***/ "./node_modules/@stablelib/random/lib/source/system.js":
/*!*************************************************************!*\
  !*** ./node_modules/@stablelib/random/lib/source/system.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar browser_1 = __webpack_require__(/*! ./browser */ \"./node_modules/@stablelib/random/lib/source/browser.js\");\nvar node_1 = __webpack_require__(/*! ./node */ \"./node_modules/@stablelib/random/lib/source/node.js\");\nvar SystemRandomSource = /** @class */ (function () {\n    function SystemRandomSource() {\n        this.isAvailable = false;\n        this.name = \"\";\n        // Try browser.\n        this._source = new browser_1.BrowserRandomSource();\n        if (this._source.isAvailable) {\n            this.isAvailable = true;\n            this.name = \"Browser\";\n            return;\n        }\n        // If no browser source, try Node.\n        this._source = new node_1.NodeRandomSource();\n        if (this._source.isAvailable) {\n            this.isAvailable = true;\n            this.name = \"Node\";\n            return;\n        }\n        // No sources, we're out of options.\n    }\n    SystemRandomSource.prototype.randomBytes = function (length) {\n        if (!this.isAvailable) {\n            throw new Error(\"System random byte generator is not available.\");\n        }\n        return this._source.randomBytes(length);\n    };\n    return SystemRandomSource;\n}());\nexports.SystemRandomSource = SystemRandomSource;\n//# sourceMappingURL=system.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@stablelib/random/lib/source/system.js?");

/***/ }),

/***/ "./node_modules/@stablelib/sha512/lib/sha512.js":
/*!******************************************************!*\
  !*** ./node_modules/@stablelib/sha512/lib/sha512.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar binary_1 = __webpack_require__(/*! @stablelib/binary */ \"./node_modules/@stablelib/binary/lib/binary.js\");\nvar wipe_1 = __webpack_require__(/*! @stablelib/wipe */ \"./node_modules/@stablelib/wipe/lib/wipe.js\");\nexports.DIGEST_LENGTH = 64;\nexports.BLOCK_SIZE = 128;\n/**\n * SHA-2-512 cryptographic hash algorithm.\n */\nvar SHA512 = /** @class */ (function () {\n    function SHA512() {\n        /** Length of hash output */\n        this.digestLength = exports.DIGEST_LENGTH;\n        /** Block size */\n        this.blockSize = exports.BLOCK_SIZE;\n        // Note: Int32Array is used instead of Uint32Array for performance reasons.\n        this._stateHi = new Int32Array(8); // hash state, high bytes\n        this._stateLo = new Int32Array(8); // hash state, low bytes\n        this._tempHi = new Int32Array(16); // temporary state, high bytes\n        this._tempLo = new Int32Array(16); // temporary state, low bytes\n        this._buffer = new Uint8Array(256); // buffer for data to hash\n        this._bufferLength = 0; // number of bytes in buffer\n        this._bytesHashed = 0; // number of total bytes hashed\n        this._finished = false; // indicates whether the hash was finalized\n        this.reset();\n    }\n    SHA512.prototype._initState = function () {\n        this._stateHi[0] = 0x6a09e667;\n        this._stateHi[1] = 0xbb67ae85;\n        this._stateHi[2] = 0x3c6ef372;\n        this._stateHi[3] = 0xa54ff53a;\n        this._stateHi[4] = 0x510e527f;\n        this._stateHi[5] = 0x9b05688c;\n        this._stateHi[6] = 0x1f83d9ab;\n        this._stateHi[7] = 0x5be0cd19;\n        this._stateLo[0] = 0xf3bcc908;\n        this._stateLo[1] = 0x84caa73b;\n        this._stateLo[2] = 0xfe94f82b;\n        this._stateLo[3] = 0x5f1d36f1;\n        this._stateLo[4] = 0xade682d1;\n        this._stateLo[5] = 0x2b3e6c1f;\n        this._stateLo[6] = 0xfb41bd6b;\n        this._stateLo[7] = 0x137e2179;\n    };\n    /**\n     * Resets hash state making it possible\n     * to re-use this instance to hash other data.\n     */\n    SHA512.prototype.reset = function () {\n        this._initState();\n        this._bufferLength = 0;\n        this._bytesHashed = 0;\n        this._finished = false;\n        return this;\n    };\n    /**\n     * Cleans internal buffers and resets hash state.\n     */\n    SHA512.prototype.clean = function () {\n        wipe_1.wipe(this._buffer);\n        wipe_1.wipe(this._tempHi);\n        wipe_1.wipe(this._tempLo);\n        this.reset();\n    };\n    /**\n     * Updates hash state with the given data.\n     *\n     * Throws error when trying to update already finalized hash:\n     * instance must be reset to update it again.\n     */\n    SHA512.prototype.update = function (data, dataLength) {\n        if (dataLength === void 0) { dataLength = data.length; }\n        if (this._finished) {\n            throw new Error(\"SHA512: can't update because hash was finished.\");\n        }\n        var dataPos = 0;\n        this._bytesHashed += dataLength;\n        if (this._bufferLength > 0) {\n            while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {\n                this._buffer[this._bufferLength++] = data[dataPos++];\n                dataLength--;\n            }\n            if (this._bufferLength === this.blockSize) {\n                hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);\n                this._bufferLength = 0;\n            }\n        }\n        if (dataLength >= this.blockSize) {\n            dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data, dataPos, dataLength);\n            dataLength %= this.blockSize;\n        }\n        while (dataLength > 0) {\n            this._buffer[this._bufferLength++] = data[dataPos++];\n            dataLength--;\n        }\n        return this;\n    };\n    /**\n     * Finalizes hash state and puts hash into out.\n     * If hash was already finalized, puts the same value.\n     */\n    SHA512.prototype.finish = function (out) {\n        if (!this._finished) {\n            var bytesHashed = this._bytesHashed;\n            var left = this._bufferLength;\n            var bitLenHi = (bytesHashed / 0x20000000) | 0;\n            var bitLenLo = bytesHashed << 3;\n            var padLength = (bytesHashed % 128 < 112) ? 128 : 256;\n            this._buffer[left] = 0x80;\n            for (var i = left + 1; i < padLength - 8; i++) {\n                this._buffer[i] = 0;\n            }\n            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);\n            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);\n            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);\n            this._finished = true;\n        }\n        for (var i = 0; i < this.digestLength / 8; i++) {\n            binary_1.writeUint32BE(this._stateHi[i], out, i * 8);\n            binary_1.writeUint32BE(this._stateLo[i], out, i * 8 + 4);\n        }\n        return this;\n    };\n    /**\n     * Returns the final hash digest.\n     */\n    SHA512.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    /**\n     * Function useful for HMAC/PBKDF2 optimization. Returns hash state to be\n     * used with restoreState(). Only chain value is saved, not buffers or\n     * other state variables.\n     */\n    SHA512.prototype.saveState = function () {\n        if (this._finished) {\n            throw new Error(\"SHA256: cannot save finished state\");\n        }\n        return {\n            stateHi: new Int32Array(this._stateHi),\n            stateLo: new Int32Array(this._stateLo),\n            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : undefined,\n            bufferLength: this._bufferLength,\n            bytesHashed: this._bytesHashed\n        };\n    };\n    /**\n     * Function useful for HMAC/PBKDF2 optimization. Restores state saved by\n     * saveState() and sets bytesHashed to the given value.\n     */\n    SHA512.prototype.restoreState = function (savedState) {\n        this._stateHi.set(savedState.stateHi);\n        this._stateLo.set(savedState.stateLo);\n        this._bufferLength = savedState.bufferLength;\n        if (savedState.buffer) {\n            this._buffer.set(savedState.buffer);\n        }\n        this._bytesHashed = savedState.bytesHashed;\n        this._finished = false;\n        return this;\n    };\n    /**\n     * Cleans state returned by saveState().\n     */\n    SHA512.prototype.cleanSavedState = function (savedState) {\n        wipe_1.wipe(savedState.stateHi);\n        wipe_1.wipe(savedState.stateLo);\n        if (savedState.buffer) {\n            wipe_1.wipe(savedState.buffer);\n        }\n        savedState.bufferLength = 0;\n        savedState.bytesHashed = 0;\n    };\n    return SHA512;\n}());\nexports.SHA512 = SHA512;\n// Constants\nvar K = new Int32Array([\n    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n]);\nfunction hashBlocks(wh, wl, hh, hl, m, pos, len) {\n    var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];\n    var h, l;\n    var th, tl;\n    var a, b, c, d;\n    while (len >= 128) {\n        for (var i = 0; i < 16; i++) {\n            var j = 8 * i + pos;\n            wh[i] = binary_1.readUint32BE(m, j);\n            wl[i] = binary_1.readUint32BE(m, j + 4);\n        }\n        for (var i = 0; i < 80; i++) {\n            var bh0 = ah0;\n            var bh1 = ah1;\n            var bh2 = ah2;\n            var bh3 = ah3;\n            var bh4 = ah4;\n            var bh5 = ah5;\n            var bh6 = ah6;\n            var bh7 = ah7;\n            var bl0 = al0;\n            var bl1 = al1;\n            var bl2 = al2;\n            var bl3 = al3;\n            var bl4 = al4;\n            var bl5 = al5;\n            var bl6 = al6;\n            var bl7 = al7;\n            // add\n            h = ah7;\n            l = al7;\n            a = l & 0xffff;\n            b = l >>> 16;\n            c = h & 0xffff;\n            d = h >>> 16;\n            // Sigma1\n            h = ((ah4 >>> 14) | (al4 << (32 - 14))) ^ ((ah4 >>> 18) |\n                (al4 << (32 - 18))) ^ ((al4 >>> (41 - 32)) | (ah4 << (32 - (41 - 32))));\n            l = ((al4 >>> 14) | (ah4 << (32 - 14))) ^ ((al4 >>> 18) |\n                (ah4 << (32 - 18))) ^ ((ah4 >>> (41 - 32)) | (al4 << (32 - (41 - 32))));\n            a += l & 0xffff;\n            b += l >>> 16;\n            c += h & 0xffff;\n            d += h >>> 16;\n            // Ch\n            h = (ah4 & ah5) ^ (~ah4 & ah6);\n            l = (al4 & al5) ^ (~al4 & al6);\n            a += l & 0xffff;\n            b += l >>> 16;\n            c += h & 0xffff;\n            d += h >>> 16;\n            // K\n            h = K[i * 2];\n            l = K[i * 2 + 1];\n            a += l & 0xffff;\n            b += l >>> 16;\n            c += h & 0xffff;\n            d += h >>> 16;\n            // w\n            h = wh[i % 16];\n            l = wl[i % 16];\n            a += l & 0xffff;\n            b += l >>> 16;\n            c += h & 0xffff;\n            d += h >>> 16;\n            b += a >>> 16;\n            c += b >>> 16;\n            d += c >>> 16;\n            th = c & 0xffff | d << 16;\n            tl = a & 0xffff | b << 16;\n            // add\n            h = th;\n            l = tl;\n            a = l & 0xffff;\n            b = l >>> 16;\n            c = h & 0xffff;\n            d = h >>> 16;\n            // Sigma0\n            h = ((ah0 >>> 28) | (al0 << (32 - 28))) ^ ((al0 >>> (34 - 32)) |\n                (ah0 << (32 - (34 - 32)))) ^ ((al0 >>> (39 - 32)) | (ah0 << (32 - (39 - 32))));\n            l = ((al0 >>> 28) | (ah0 << (32 - 28))) ^ ((ah0 >>> (34 - 32)) |\n                (al0 << (32 - (34 - 32)))) ^ ((ah0 >>> (39 - 32)) | (al0 << (32 - (39 - 32))));\n            a += l & 0xffff;\n            b += l >>> 16;\n            c += h & 0xffff;\n            d += h >>> 16;\n            // Maj\n            h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);\n            l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);\n            a += l & 0xffff;\n            b += l >>> 16;\n            c += h & 0xffff;\n            d += h >>> 16;\n            b += a >>> 16;\n            c += b >>> 16;\n            d += c >>> 16;\n            bh7 = (c & 0xffff) | (d << 16);\n            bl7 = (a & 0xffff) | (b << 16);\n            // add\n            h = bh3;\n            l = bl3;\n            a = l & 0xffff;\n            b = l >>> 16;\n            c = h & 0xffff;\n            d = h >>> 16;\n            h = th;\n            l = tl;\n            a += l & 0xffff;\n            b += l >>> 16;\n            c += h & 0xffff;\n            d += h >>> 16;\n            b += a >>> 16;\n            c += b >>> 16;\n            d += c >>> 16;\n            bh3 = (c & 0xffff) | (d << 16);\n            bl3 = (a & 0xffff) | (b << 16);\n            ah1 = bh0;\n            ah2 = bh1;\n            ah3 = bh2;\n            ah4 = bh3;\n            ah5 = bh4;\n            ah6 = bh5;\n            ah7 = bh6;\n            ah0 = bh7;\n            al1 = bl0;\n            al2 = bl1;\n            al3 = bl2;\n            al4 = bl3;\n            al5 = bl4;\n            al6 = bl5;\n            al7 = bl6;\n            al0 = bl7;\n            if (i % 16 === 15) {\n                for (var j = 0; j < 16; j++) {\n                    // add\n                    h = wh[j];\n                    l = wl[j];\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = wh[(j + 9) % 16];\n                    l = wl[(j + 9) % 16];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    // sigma0\n                    th = wh[(j + 1) % 16];\n                    tl = wl[(j + 1) % 16];\n                    h = ((th >>> 1) | (tl << (32 - 1))) ^ ((th >>> 8) |\n                        (tl << (32 - 8))) ^ (th >>> 7);\n                    l = ((tl >>> 1) | (th << (32 - 1))) ^ ((tl >>> 8) |\n                        (th << (32 - 8))) ^ ((tl >>> 7) | (th << (32 - 7)));\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    // sigma1\n                    th = wh[(j + 14) % 16];\n                    tl = wl[(j + 14) % 16];\n                    h = ((th >>> 19) | (tl << (32 - 19))) ^ ((tl >>> (61 - 32)) |\n                        (th << (32 - (61 - 32)))) ^ (th >>> 6);\n                    l = ((tl >>> 19) | (th << (32 - 19))) ^ ((th >>> (61 - 32)) |\n                        (tl << (32 - (61 - 32)))) ^ ((tl >>> 6) | (th << (32 - 6)));\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    wh[j] = (c & 0xffff) | (d << 16);\n                    wl[j] = (a & 0xffff) | (b << 16);\n                }\n            }\n        }\n        // add\n        h = ah0;\n        l = al0;\n        a = l & 0xffff;\n        b = l >>> 16;\n        c = h & 0xffff;\n        d = h >>> 16;\n        h = hh[0];\n        l = hl[0];\n        a += l & 0xffff;\n        b += l >>> 16;\n        c += h & 0xffff;\n        d += h >>> 16;\n        b += a >>> 16;\n        c += b >>> 16;\n        d += c >>> 16;\n        hh[0] = ah0 = (c & 0xffff) | (d << 16);\n        hl[0] = al0 = (a & 0xffff) | (b << 16);\n        h = ah1;\n        l = al1;\n        a = l & 0xffff;\n        b = l >>> 16;\n        c = h & 0xffff;\n        d = h >>> 16;\n        h = hh[1];\n        l = hl[1];\n        a += l & 0xffff;\n        b += l >>> 16;\n        c += h & 0xffff;\n        d += h >>> 16;\n        b += a >>> 16;\n        c += b >>> 16;\n        d += c >>> 16;\n        hh[1] = ah1 = (c & 0xffff) | (d << 16);\n        hl[1] = al1 = (a & 0xffff) | (b << 16);\n        h = ah2;\n        l = al2;\n        a = l & 0xffff;\n        b = l >>> 16;\n        c = h & 0xffff;\n        d = h >>> 16;\n        h = hh[2];\n        l = hl[2];\n        a += l & 0xffff;\n        b += l >>> 16;\n        c += h & 0xffff;\n        d += h >>> 16;\n        b += a >>> 16;\n        c += b >>> 16;\n        d += c >>> 16;\n        hh[2] = ah2 = (c & 0xffff) | (d << 16);\n        hl[2] = al2 = (a & 0xffff) | (b << 16);\n        h = ah3;\n        l = al3;\n        a = l & 0xffff;\n        b = l >>> 16;\n        c = h & 0xffff;\n        d = h >>> 16;\n        h = hh[3];\n        l = hl[3];\n        a += l & 0xffff;\n        b += l >>> 16;\n        c += h & 0xffff;\n        d += h >>> 16;\n        b += a >>> 16;\n        c += b >>> 16;\n        d += c >>> 16;\n        hh[3] = ah3 = (c & 0xffff) | (d << 16);\n        hl[3] = al3 = (a & 0xffff) | (b << 16);\n        h = ah4;\n        l = al4;\n        a = l & 0xffff;\n        b = l >>> 16;\n        c = h & 0xffff;\n        d = h >>> 16;\n        h = hh[4];\n        l = hl[4];\n        a += l & 0xffff;\n        b += l >>> 16;\n        c += h & 0xffff;\n        d += h >>> 16;\n        b += a >>> 16;\n        c += b >>> 16;\n        d += c >>> 16;\n        hh[4] = ah4 = (c & 0xffff) | (d << 16);\n        hl[4] = al4 = (a & 0xffff) | (b << 16);\n        h = ah5;\n        l = al5;\n        a = l & 0xffff;\n        b = l >>> 16;\n        c = h & 0xffff;\n        d = h >>> 16;\n        h = hh[5];\n        l = hl[5];\n        a += l & 0xffff;\n        b += l >>> 16;\n        c += h & 0xffff;\n        d += h >>> 16;\n        b += a >>> 16;\n        c += b >>> 16;\n        d += c >>> 16;\n        hh[5] = ah5 = (c & 0xffff) | (d << 16);\n        hl[5] = al5 = (a & 0xffff) | (b << 16);\n        h = ah6;\n        l = al6;\n        a = l & 0xffff;\n        b = l >>> 16;\n        c = h & 0xffff;\n        d = h >>> 16;\n        h = hh[6];\n        l = hl[6];\n        a += l & 0xffff;\n        b += l >>> 16;\n        c += h & 0xffff;\n        d += h >>> 16;\n        b += a >>> 16;\n        c += b >>> 16;\n        d += c >>> 16;\n        hh[6] = ah6 = (c & 0xffff) | (d << 16);\n        hl[6] = al6 = (a & 0xffff) | (b << 16);\n        h = ah7;\n        l = al7;\n        a = l & 0xffff;\n        b = l >>> 16;\n        c = h & 0xffff;\n        d = h >>> 16;\n        h = hh[7];\n        l = hl[7];\n        a += l & 0xffff;\n        b += l >>> 16;\n        c += h & 0xffff;\n        d += h >>> 16;\n        b += a >>> 16;\n        c += b >>> 16;\n        d += c >>> 16;\n        hh[7] = ah7 = (c & 0xffff) | (d << 16);\n        hl[7] = al7 = (a & 0xffff) | (b << 16);\n        pos += 128;\n        len -= 128;\n    }\n    return pos;\n}\nfunction hash(data) {\n    var h = new SHA512();\n    h.update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hash = hash;\n//# sourceMappingURL=sha512.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@stablelib/sha512/lib/sha512.js?");

/***/ }),

/***/ "./node_modules/@stablelib/wipe/lib/wipe.js":
/*!**************************************************!*\
  !*** ./node_modules/@stablelib/wipe/lib/wipe.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Sets all values in the given array to zero and returns it.\n *\n * The fact that it sets bytes to zero can be relied on.\n *\n * There is no guarantee that this function makes data disappear from memory,\n * as runtime implementation can, for example, have copying garbage collector\n * that will make copies of sensitive data before we wipe it. Or that an\n * operating system will write our data to swap or sleep image. Another thing\n * is that an optimizing compiler can remove calls to this function or make it\n * no-op. There's nothing we can do with it, so we just do our best and hope\n * that everything will be okay and good will triumph over evil.\n */\nfunction wipe(array) {\n    // Right now it's similar to array.fill(0). If it turns\n    // out that runtimes optimize this call away, maybe\n    // we can try something else.\n    for (var i = 0; i < array.length; i++) {\n        array[i] = 0;\n    }\n    return array;\n}\nexports.wipe = wipe;\n//# sourceMappingURL=wipe.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@stablelib/wipe/lib/wipe.js?");

/***/ }),

/***/ "./node_modules/base58-universal/baseN.js":
/*!************************************************!*\
  !*** ./node_modules/base58-universal/baseN.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"encode\": () => (/* binding */ encode),\n/* harmony export */   \"decode\": () => (/* binding */ decode)\n/* harmony export */ });\n/**\n * Base-N/Base-X encoding/decoding functions.\n *\n * Original implementation from base-x:\n * https://github.com/cryptocoinjs/base-x\n *\n * Which is MIT licensed:\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n\n// baseN alphabet indexes\nconst _reverseAlphabets = {};\n\n/**\n * BaseN-encodes a Uint8Array using the given alphabet.\n *\n * @param {Uint8Array} input the bytes to encode in a Uint8Array.\n * @param {number} maxline the maximum number of encoded characters per line to\n *          use, defaults to none.\n *\n * @return {string} the baseN-encoded output string.\n */\nfunction encode(input, alphabet, maxline) {\n  if(!(input instanceof Uint8Array)) {\n    throw new TypeError('\"input\" must be a Uint8Array.');\n  }\n  if(typeof alphabet !== 'string') {\n    throw new TypeError('\"alphabet\" must be a string.');\n  }\n  if(maxline !== undefined && typeof maxline !== 'number') {\n    throw new TypeError('\"maxline\" must be a number.');\n  }\n  if(input.length === 0) {\n    return '';\n  }\n\n  let output = '';\n\n  let i = 0;\n  const base = alphabet.length;\n  const first = alphabet.charAt(0);\n  const digits = [0];\n  for(i = 0; i < input.length; ++i) {\n    let carry = input[i];\n    for(let j = 0; j < digits.length; ++j) {\n      carry += digits[j] << 8;\n      digits[j] = carry % base;\n      carry = (carry / base) | 0;\n    }\n\n    while(carry > 0) {\n      digits.push(carry % base);\n      carry = (carry / base) | 0;\n    }\n  }\n\n  // deal with leading zeros\n  for(i = 0; input[i] === 0 && i < input.length - 1; ++i) {\n    output += first;\n  }\n  // convert digits to a string\n  for(i = digits.length - 1; i >= 0; --i) {\n    output += alphabet[digits[i]];\n  }\n\n  if(maxline) {\n    const regex = new RegExp('.{1,' + maxline + '}', 'g');\n    output = output.match(regex).join('\\r\\n');\n  }\n\n  return output;\n}\n\n/**\n * Decodes a baseN-encoded (using the given alphabet) string to a\n * Uint8Array.\n *\n * @param {string} input the baseN-encoded input string.\n *\n * @return {Uint8Array} the decoded bytes in a Uint8Array.\n */\nfunction decode(input, alphabet) {\n  if(typeof input !== 'string') {\n    throw new TypeError('\"input\" must be a string.');\n  }\n  if(typeof alphabet !== 'string') {\n    throw new TypeError('\"alphabet\" must be a string.');\n  }\n  if(input.length === 0) {\n    return new Uint8Array();\n  }\n\n  let table = _reverseAlphabets[alphabet];\n  if(!table) {\n    // compute reverse alphabet\n    table = _reverseAlphabets[alphabet] = [];\n    for(let i = 0; i < alphabet.length; ++i) {\n      table[alphabet.charCodeAt(i)] = i;\n    }\n  }\n\n  // remove whitespace characters\n  input = input.replace(/\\s/g, '');\n\n  const base = alphabet.length;\n  const first = alphabet.charAt(0);\n  const bytes = [0];\n  for(let i = 0; i < input.length; i++) {\n    const value = table[input.charCodeAt(i)];\n    if(value === undefined) {\n      return;\n    }\n\n    let carry = value;\n    for(let j = 0; j < bytes.length; ++j) {\n      carry += bytes[j] * base;\n      bytes[j] = carry & 0xff;\n      carry >>= 8;\n    }\n\n    while(carry > 0) {\n      bytes.push(carry & 0xff);\n      carry >>= 8;\n    }\n  }\n\n  // deal with leading zeros\n  for(let k = 0; input[k] === first && k < input.length - 1; ++k) {\n    bytes.push(0);\n  }\n\n  return new Uint8Array(bytes.reverse());\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/base58-universal/baseN.js?");

/***/ }),

/***/ "./node_modules/base58-universal/main.js":
/*!***********************************************!*\
  !*** ./node_modules/base58-universal/main.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"encode\": () => (/* binding */ encode),\n/* harmony export */   \"decode\": () => (/* binding */ decode)\n/* harmony export */ });\n/* harmony import */ var _baseN_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./baseN.js */ \"./node_modules/base58-universal/baseN.js\");\n/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n// base58 characters (Bitcoin alphabet)\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\nfunction encode(input, maxline) {\n  return (0,_baseN_js__WEBPACK_IMPORTED_MODULE_0__.encode)(input, alphabet, maxline);\n}\n\nfunction decode(input) {\n  return (0,_baseN_js__WEBPACK_IMPORTED_MODULE_0__.decode)(input, alphabet);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/base58-universal/main.js?");

/***/ }),

/***/ "./node_modules/base64url-universal/lib/base64url.js":
/*!***********************************************************!*\
  !*** ./node_modules/base64url-universal/lib/base64url.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n/**\n * Encode/Decode input according to the \"Base64url Encoding\" format as specified\n * in JSON Web Signature (JWS) RFC7517. A URL safe character set is used and\n * trailing '=', line breaks, whitespace, and other characters are omitted.\n * @module base64url-universal\n */\n\nconst _alphabet =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\nconst _alphabetIdx = [\n  62, -1, -1,\n  52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\n  -1, -1, -1, 64, -1, -1, -1,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\n  13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n  -1, -1, -1, -1, 63, -1,\n  26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\n  39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n];\n\n/**\n * Encodes input according to the \"Base64url Encoding\" format as specified\n * in JSON Web Signature (JWS) RFC7517. A URL safe character set is used and\n * trailing '=', line breaks, whitespace, and other characters are omitted.\n *\n * @alias module:base64url-universal\n * @param {(Uint8Array | string)} input the data to encode.\n *\n * @return {string} the encoded value.\n */\nfunction encode(input) {\n  if(!((input instanceof Uint8Array) || (typeof input === 'string'))) {\n    throw new TypeError('\"input\" be a string or Uint8Array.');\n  }\n  if(typeof input === 'string') {\n    // convert input to Uint8Array\n    input = new TextEncoder().encode(input);\n  }\n  let output = '';\n  let chr1, chr2, chr3;\n  let i = 0;\n  while(i < input.byteLength) {\n    chr1 = input[i++];\n    chr2 = input[i++];\n    chr3 = input[i++];\n\n    // encode 4 character group\n    output += _alphabet.charAt(chr1 >> 2);\n    output += _alphabet.charAt(((chr1 & 3) << 4) | (chr2 >> 4));\n    if(!isNaN(chr2)) {\n      output += _alphabet.charAt(((chr2 & 15) << 2) | (chr3 >> 6));\n      if(!isNaN(chr3)) {\n        output += _alphabet.charAt(chr3 & 63);\n      }\n    }\n  }\n  return output;\n}\n\n/**\n * Decodes input according to the \"Base64url Encoding\" format as specified\n * in JSON Web Signature (JWS) RFC7517. A URL safe character set is used and\n * trailing '=', line breaks, whitespace, and other characters are omitted.\n *\n * @alias module:base64url-universal\n * @param {string} input the data to decode.\n *\n * @return {Uint8Array} the decoded value.\n */\nfunction decode(input) {\n  let length = input.length;\n  const mod4 = length % 4;\n  if(mod4 === 1) {\n    throw new Error('Illegal base64 string.');\n  }\n  let diff = 0;\n  if(mod4 > 0) {\n    diff = 4 - mod4;\n    length += diff;\n  }\n\n  const output = new Uint8Array(length / 4 * 3 - diff);\n\n  let enc1, enc2, enc3, enc4;\n  let i = 0, j = 0;\n\n  while(i < length) {\n    enc1 = _alphabetIdx[input.charCodeAt(i++) - 45];\n    enc2 = _alphabetIdx[input.charCodeAt(i++) - 45];\n\n    output[j++] = (enc1 << 2) | (enc2 >> 4);\n    if(i < input.length) {\n      // can decode at least 2 bytes\n      enc3 = _alphabetIdx[input.charCodeAt(i++) - 45];\n      output[j++] = ((enc2 & 15) << 4) | (enc3 >> 2);\n      if(i < input.length) {\n        // can decode 3 bytes\n        enc4 = _alphabetIdx[input.charCodeAt(i++) - 45];\n        output[j++] = ((enc3 & 3) << 6) | enc4;\n      }\n    }\n  }\n\n  return output;\n}\n\nmodule.exports = {decode, encode};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/base64url-universal/lib/base64url.js?");

/***/ }),

/***/ "./node_modules/base64url-universal/lib/browser.js":
/*!*********************************************************!*\
  !*** ./node_modules/base64url-universal/lib/browser.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst api = {};\nmodule.exports = api;\n\nconst base64url = __webpack_require__(/*! ./base64url */ \"./node_modules/base64url-universal/lib/base64url.js\");\n\napi.encode = base64url.encode;\napi.decode = base64url.decode;\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/base64url-universal/lib/browser.js?");

/***/ }),

/***/ "./node_modules/canonicalize/lib/canonicalize.js":
/*!*******************************************************!*\
  !*** ./node_modules/canonicalize/lib/canonicalize.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
eval("/* jshint esversion: 6 */\n/* jslint node: true */\n\n\nmodule.exports = function serialize (object) {\n  if (object === null || typeof object !== 'object' || object.toJSON != null) {\n    return JSON.stringify(object);\n  }\n\n  if (Array.isArray(object)) {\n    return '[' + object.reduce((t, cv, ci) => {\n      const comma = ci === 0 ? '' : ',';\n      const value = cv === undefined || typeof cv === 'symbol' ? null : cv;\n      return t + comma + serialize(value);\n    }, '') + ']';\n  }\n\n  return '{' + Object.keys(object).sort().reduce((t, cv, ci) => {\n    if (object[cv] === undefined ||\n        typeof object[cv] === 'symbol') {\n      return t;\n    }\n    const comma = t.length === 0 ? '' : ',';\n    return t + comma + serialize(cv) + ':' + serialize(object[cv]);\n  }, '') + '}';\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/canonicalize/lib/canonicalize.js?");

/***/ }),

/***/ "./node_modules/credentials-context/dist/context.esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/credentials-context/dist/context.esm.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONTEXT\": () => (/* binding */ context_3),\n/* harmony export */   \"CONTEXT_URL\": () => (/* binding */ context_4),\n/* harmony export */   \"CONTEXT_URL_V1\": () => (/* binding */ context_5),\n/* harmony export */   \"CREDENTIALS_CONTEXT_V1_URL\": () => (/* binding */ context_6),\n/* harmony export */   \"constants\": () => (/* binding */ context_2),\n/* harmony export */   \"contexts\": () => (/* binding */ context_1),\n/* harmony export */   \"default\": () => (/* binding */ context$1)\n/* harmony export */ });\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar context = createCommonjsModule(function (module, exports) {\n/*! For license information please see context.js.LICENSE.txt */\n(()=>{var e={717:e=>{e.exports={CONTEXT_FILENAME:\"credentials-v1.jsonld\",CONTEXT_URL:\"https://www.w3.org/2018/credentials/v1\",CREDENTIALS_CONTEXT_V1_URL:\"https://www.w3.org/2018/credentials/v1\"};},869:e=>{e.exports={\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",VerifiableCredential:{\"@id\":\"https://www.w3.org/2018/credentials#VerifiableCredential\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",cred:\"https://www.w3.org/2018/credentials#\",sec:\"https://w3id.org/security#\",xsd:\"http://www.w3.org/2001/XMLSchema#\",credentialSchema:{\"@id\":\"cred:credentialSchema\",\"@type\":\"@id\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",cred:\"https://www.w3.org/2018/credentials#\",JsonSchemaValidator2018:\"cred:JsonSchemaValidator2018\"}},credentialStatus:{\"@id\":\"cred:credentialStatus\",\"@type\":\"@id\"},credentialSubject:{\"@id\":\"cred:credentialSubject\",\"@type\":\"@id\"},evidence:{\"@id\":\"cred:evidence\",\"@type\":\"@id\"},expirationDate:{\"@id\":\"cred:expirationDate\",\"@type\":\"xsd:dateTime\"},holder:{\"@id\":\"cred:holder\",\"@type\":\"@id\"},issued:{\"@id\":\"cred:issued\",\"@type\":\"xsd:dateTime\"},issuer:{\"@id\":\"cred:issuer\",\"@type\":\"@id\"},issuanceDate:{\"@id\":\"cred:issuanceDate\",\"@type\":\"xsd:dateTime\"},proof:{\"@id\":\"sec:proof\",\"@type\":\"@id\",\"@container\":\"@graph\"},refreshService:{\"@id\":\"cred:refreshService\",\"@type\":\"@id\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",cred:\"https://www.w3.org/2018/credentials#\",ManualRefreshService2018:\"cred:ManualRefreshService2018\"}},termsOfUse:{\"@id\":\"cred:termsOfUse\",\"@type\":\"@id\"},validFrom:{\"@id\":\"cred:validFrom\",\"@type\":\"xsd:dateTime\"},validUntil:{\"@id\":\"cred:validUntil\",\"@type\":\"xsd:dateTime\"}}},VerifiablePresentation:{\"@id\":\"https://www.w3.org/2018/credentials#VerifiablePresentation\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",cred:\"https://www.w3.org/2018/credentials#\",sec:\"https://w3id.org/security#\",holder:{\"@id\":\"cred:holder\",\"@type\":\"@id\"},proof:{\"@id\":\"sec:proof\",\"@type\":\"@id\",\"@container\":\"@graph\"},verifiableCredential:{\"@id\":\"cred:verifiableCredential\",\"@type\":\"@id\",\"@container\":\"@graph\"}}},EcdsaSecp256k1Signature2019:{\"@id\":\"https://w3id.org/security#EcdsaSecp256k1Signature2019\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",sec:\"https://w3id.org/security#\",xsd:\"http://www.w3.org/2001/XMLSchema#\",challenge:\"sec:challenge\",created:{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"xsd:dateTime\"},domain:\"sec:domain\",expires:{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},jws:\"sec:jws\",nonce:\"sec:nonce\",proofPurpose:{\"@id\":\"sec:proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",sec:\"https://w3id.org/security#\",assertionMethod:{\"@id\":\"sec:assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},authentication:{\"@id\":\"sec:authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},proofValue:\"sec:proofValue\",verificationMethod:{\"@id\":\"sec:verificationMethod\",\"@type\":\"@id\"}}},EcdsaSecp256r1Signature2019:{\"@id\":\"https://w3id.org/security#EcdsaSecp256r1Signature2019\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",sec:\"https://w3id.org/security#\",xsd:\"http://www.w3.org/2001/XMLSchema#\",challenge:\"sec:challenge\",created:{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"xsd:dateTime\"},domain:\"sec:domain\",expires:{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},jws:\"sec:jws\",nonce:\"sec:nonce\",proofPurpose:{\"@id\":\"sec:proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",sec:\"https://w3id.org/security#\",assertionMethod:{\"@id\":\"sec:assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},authentication:{\"@id\":\"sec:authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},proofValue:\"sec:proofValue\",verificationMethod:{\"@id\":\"sec:verificationMethod\",\"@type\":\"@id\"}}},Ed25519Signature2018:{\"@id\":\"https://w3id.org/security#Ed25519Signature2018\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",sec:\"https://w3id.org/security#\",xsd:\"http://www.w3.org/2001/XMLSchema#\",challenge:\"sec:challenge\",created:{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"xsd:dateTime\"},domain:\"sec:domain\",expires:{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},jws:\"sec:jws\",nonce:\"sec:nonce\",proofPurpose:{\"@id\":\"sec:proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",sec:\"https://w3id.org/security#\",assertionMethod:{\"@id\":\"sec:assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},authentication:{\"@id\":\"sec:authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},proofValue:\"sec:proofValue\",verificationMethod:{\"@id\":\"sec:verificationMethod\",\"@type\":\"@id\"}}},RsaSignature2018:{\"@id\":\"https://w3id.org/security#RsaSignature2018\",\"@context\":{\"@version\":1.1,\"@protected\":!0,challenge:\"sec:challenge\",created:{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"xsd:dateTime\"},domain:\"sec:domain\",expires:{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},jws:\"sec:jws\",nonce:\"sec:nonce\",proofPurpose:{\"@id\":\"sec:proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",sec:\"https://w3id.org/security#\",assertionMethod:{\"@id\":\"sec:assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},authentication:{\"@id\":\"sec:authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},proofValue:\"sec:proofValue\",verificationMethod:{\"@id\":\"sec:verificationMethod\",\"@type\":\"@id\"}}},proof:{\"@id\":\"https://w3id.org/security#proof\",\"@type\":\"@id\",\"@container\":\"@graph\"}}};},858:(e,t,i)=>{const{CONTEXT_URL:d}=i(717),r=i(869);e.exports={documentLoader(e){if(e!==d)throw new Error(`Loading document \"${e}\" is not allowed.`);return {contextUrl:null,document:r,documentUrl:e}}};},243:(e,t,i)=>{const d=i(869),r=i(717),{documentLoader:o}=i(858),{CONTEXT_URL:c}=r,s=new Map;s.set(r.CONTEXT_URL,d),e.exports={constants:r,contexts:s,documentLoader:o,CONTEXT_URL:c,CREDENTIALS_CONTEXT_V1_URL:c,CONTEXT_URL_V1:c,CONTEXT:d};}},t={},i=function i(d){var r=t[d];if(void 0!==r)return r.exports;var o=t[d]={exports:{}};return e[d](o,o.exports,i),o.exports}(243),d=exports;for(var r in i)d[r]=i[r];i.__esModule&&Object.defineProperty(d,\"__esModule\",{value:!0});})();\n});\n\nvar context$1 = unwrapExports(context);\nvar context_1 = context.contexts;\nvar context_2 = context.constants;\nvar context_3 = context.CONTEXT;\nvar context_4 = context.CONTEXT_URL;\nvar context_5 = context.CONTEXT_URL_V1;\nvar context_6 = context.CREDENTIALS_CONTEXT_V1_URL;\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/credentials-context/dist/context.esm.js?");

/***/ }),

/***/ "./node_modules/crypto-ld/lib/CryptoLD.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-ld/lib/CryptoLD.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n/**\n * General purpose key generation driver for Linked Data cryptographic key\n * pairs.\n *\n * @param {Map} [suites] - Optional map of supported suites, by suite id.\n */\nclass CryptoLD {\n  constructor({suites} = {}) {\n    this.suites = suites || new Map();\n  }\n\n  /**\n   * Installs support for a key type (suite).\n   *\n   * @param {LDKeyPair} keyPairLib - Conforming key pair library for a suite.\n   */\n  use(keyPairLib) {\n    this.suites.set(keyPairLib.suite, keyPairLib);\n  }\n\n  /**\n   * Generates a public/private LDKeyPair.\n   *\n   * @param {string} type - Key suite id ('Ed25519VerificationKey2020').\n   *\n   * @param {object} [options] - Optional suite-specific key options.\n   * @param {string} [options.controller] - Controller DID or URL for the\n   *   generated key pair. If present, used to auto-initialize the key.id.\n   *\n   * @returns {Promise<LDKeyPair>}\n   */\n  async generate({type, ...options} = {}) {\n    if(!type) {\n      throw new TypeError('A key type is required to generate.');\n    }\n    if(!this._installed({type})) {\n      throw new TypeError(`Support for key type \"${type}\" is not installed.`);\n    }\n\n    return this.suites.get(type).generate(options);\n  }\n\n  /**\n   * Imports a public/private key pair from serialized data.\n   *\n   * @param {object} serialized - Serialized key object.\n   *\n   * @throws {Error} - On missing or invalid serialized key data.\n   *\n   * @returns {Promise<LDKeyPair>}\n   */\n  async from(serialized = {}) {\n    const type = serialized && serialized.type;\n\n    if(!type) {\n      throw new TypeError('Missing key type.');\n    }\n    if(!this._installed({type})) {\n      throw new Error(`Support for key type \"${type}\" is not installed.`);\n    }\n\n    return this.suites.get(type).from(serialized);\n  }\n\n  /**\n   * Imports a key pair instance via the provided `documentLoader` function,\n   * optionally checking it for revocation and required context.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.id - Key ID or URI.\n   * @param {Function} options.documentLoader - JSON-LD Document Loader.\n   * @param {boolean} [options.checkContext=true] - Whether to check that the\n   *   fetched key document contains the context required by the key's crypto\n   *   suite.\n   * @param {boolean} [options.checkRevoked=true] - Whether to check the key\n   *   object for the presence of the `revoked` timestamp.\n   *\n   * @returns {Promise<LDKeyPair>} Resolves with the appropriate key pair\n   *   instance.\n   */\n  async fromKeyId({\n    id, documentLoader, checkContext = true, checkRevoked = true\n  } = {}) {\n    if(!id) {\n      throw new TypeError('The \"id\" parameter is required.');\n    }\n    if(!documentLoader) {\n      throw new TypeError('The \"documentLoader\" parameter is required.');\n    }\n    let keyDocument;\n    try {\n      ({document: keyDocument} = await documentLoader(id));\n      // the supplied documentLoader may not be properly implemented\n      if(!keyDocument) {\n        throw new Error(\n          'The \"documentLoader\" function must return a \"document\" object.');\n      }\n    } catch(e) {\n      const error = new Error('Error fetching document: ' + e.message);\n      error.cause = e;\n      throw error;\n    }\n    const fetchedType = keyDocument.type;\n    if(!fetchedType) {\n      throw new Error('Key suite type not found in fetched document.');\n    }\n    const keySuite = this.suites.get(fetchedType);\n    if(!keySuite) {\n      throw new Error(`Support for suite \"${fetchedType}\" is not installed.`);\n    }\n\n    return keySuite.fromKeyDocument({document: keyDocument, checkContext,\n      checkRevoked});\n  }\n\n  /**\n   * Tests if a given key type is currently installed.\n   *\n   * @param {string} [type] - Key suite id ('Ed25519VerificationKey2020').\n   * @private\n   */\n  _installed({type}) {\n    return this.suites.has(type);\n  }\n}\n\nmodule.exports = {\n  CryptoLD\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/crypto-ld/lib/CryptoLD.js?");

/***/ }),

/***/ "./node_modules/crypto-ld/lib/LDKeyPair.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-ld/lib/LDKeyPair.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2018-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n/**\n * When adding support for a new suite type for `crypto-ld`, developers should\n * do the following:\n *\n * 1. Create their own npm package / github repo, such as `example-key-pair`.\n * 2. Subclass LDKeyPair.\n * 3. Override relevant methods (such as `export()` and `fingerprint()`).\n * 4. Add to the key type table in the `crypto-ld` README.md (that's this repo).\n */\nclass LDKeyPair {\n  /**\n   * Creates a public/private key pair instance. This is an abstract base class,\n   * actual key material and suite-specific methods are handled in the subclass.\n   *\n   * To generate or import a key pair, use the `cryptoLd` instance.\n   * @see CryptoLD.js\n   *\n   * @param {string} id - The key id, typically composed of controller\n   *   URL and key fingerprint as hash fragment.\n   * @param {string} controller - DID/URL of the person/entity\n   *   controlling this key.\n   * @param {string} [revoked] - Timestamp of when the key has been revoked,\n   *   in RFC3339 format. If not present, the key itself is considered not\n   *   revoked. (Note that this mechanism is slightly different than DID\n   *   Document key revocation, where a DID controller can revoke a key from\n   *   that DID by removing it from the DID Document.)\n   */\n  constructor({id, controller, revoked} = {}) {\n    this.id = id;\n    this.controller = controller;\n    this.revoked = revoked;\n    // this.type is set in subclass constructor\n  }\n\n  /**\n   * Generates a new public/private key pair instance.\n   * Note that this method is not typically called directly by client code,\n   * but instead is used through a `cryptoLd` instance.\n   *\n   * @param {object} options - Suite-specific options for the KeyPair. For\n   *   common options, see the `LDKeyPair.constructor()` docstring.\n   *\n   * @returns {Promise<LDKeyPair>} An LDKeyPair instance.\n   */\n  static async generate(/* options */) {\n    throw new Error('Abstract method, must be implemented in subclass.');\n  }\n\n  /**\n   * Imports a key pair instance from a provided externally fetched key\n   * document (fetched via a secure JSON-LD `documentLoader` or via\n   * `cryptoLd.fromKeyId()`), optionally checking it for revocation and required\n   * context.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.document - Externally fetched key document.\n   * @param {boolean} [options.checkContext=true] - Whether to check that the\n   *   fetched key document contains the context required by the key's crypto\n   *   suite.\n   * @param {boolean} [options.checkRevoked=true] - Whether to check the key\n   *   object for the presence of the `revoked` timestamp.\n   *\n   * @returns {Promise<LDKeyPair>} Resolves with the resulting key pair\n   *   instance.\n   */\n  static async fromKeyDocument({\n    document, checkContext = true, checkRevoked = true\n  } = {}) {\n    if(!document) {\n      throw new TypeError('The \"document\" parameter is required.');\n    }\n\n    if(checkContext) {\n      const fetchedDocContexts = [].concat(document['@context']);\n      if(!fetchedDocContexts.includes(this.SUITE_CONTEXT)) {\n        throw new Error('Key document does not contain required context \"' +\n          this.SUITE_CONTEXT + '\".');\n      }\n    }\n    if(checkRevoked && document.revoked) {\n      throw new Error(`Key has been revoked since: \"${document.revoked}\".`);\n    }\n    return this.from(document);\n  }\n\n  /**\n   * Generates a KeyPair from some options.\n   * @param {object} options  - Will generate a key pair\n   * in multiple different formats.\n   * @example\n   * > const options = {\n   *    type: 'Ed25519VerificationKey2020'\n   *   };\n   * > const edKeyPair = await LDKeyPair.from(options);\n   *\n   * @returns {Promise<LDKeyPair>} A LDKeyPair.\n   * @throws Unsupported Key Type.\n   */\n  static async from(/* options */) {\n    throw new Error('Abstract method from() must be implemented in subclass.');\n  }\n\n  /**\n   * Exports the serialized representation of the KeyPair\n   * and other information that json-ld Signatures can use to form a proof.\n   *\n   * NOTE: Subclasses MUST override this method (and add the exporting of\n   * their public and private key material).\n   *\n   * @param {object} [options={}] - Options hashmap.\n   * @param {boolean} [options.publicKey] - Export public key material?\n   * @param {boolean} [options.privateKey] - Export private key material?\n   *\n   * @returns {object} A public key object\n   *   information used in verification methods by signatures.\n   */\n  export({publicKey = false, privateKey = false} = {}) {\n    if(!publicKey && !privateKey) {\n      throw new Error(\n        'Export requires specifying either \"publicKey\" or \"privateKey\".');\n    }\n    const key = {\n      id: this.id,\n      type: this.type,\n      controller: this.controller\n    };\n    if(this.revoked) {\n      key.revoked = this.revoked;\n    }\n\n    return key;\n  }\n\n  /**\n   * Returns the public key fingerprint, multibase+multicodec encoded. The\n   * specific fingerprint method is determined by the key suite, and is often\n   * either a hash of the public key material (such as with RSA), or the\n   * full encoded public key (for key types with sufficiently short\n   * representations, such as ed25519).\n   * This is frequently used in initializing the key id, or generating some\n   * types of cryptonym DIDs.\n   *\n   * @returns {string}\n   */\n  fingerprint() {\n    throw new Error('Abstract method, must be implemented in subclass.');\n  }\n\n  /**\n   * Verifies that a given key fingerprint matches the public key material\n   * belonging to this key pair.\n   *\n   * @param {string} fingerprint - Public key fingerprint.\n   *\n   * @returns {{verified: boolean}}\n   */\n  verifyFingerprint(/* {fingerprint} */) {\n    throw new Error('Abstract method, must be implemented in subclass.');\n  }\n\n  /* eslint-disable max-len */\n  /**\n   * Returns a signer object for use with\n   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}.\n   * NOTE: Applies only to verifier type keys (like ed25519).\n   *\n   * @example\n   * > const signer = keyPair.signer();\n   * > signer\n   * { sign: [AsyncFunction: sign] }\n   * > signer.sign({data});\n   *\n   * @returns {{sign: Function}} A signer for json-ld usage.\n   */\n  /* eslint-enable */\n  signer() {\n    return {\n      async sign({/* data */}) {\n        throw new Error('Abstract method, must be implemented in subclass.');\n      }\n    };\n  }\n\n  /* eslint-disable max-len */\n  /**\n   * Returns a verifier object for use with\n   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}.\n   * NOTE: Applies only to verifier type keys (like ed25519).\n   *\n   * @example\n   * > const verifier = keyPair.verifier();\n   * > verifier\n   * { verify: [AsyncFunction: verify] }\n   * > verifier.verify(key);\n   *\n   * @returns {{verify: Function}} Used to verify jsonld-signatures.\n   */\n  /* eslint-enable */\n  verifier() {\n    return {\n      async verify({/* data, signature */}) {\n        throw new Error('Abstract method, must be implemented in subclass.');\n      }\n    };\n  }\n}\n\n// Implementers must override this in subclasses\nLDKeyPair.SUITE_CONTEXT = 'INVALID LDKeyPair CONTEXT';\n\nmodule.exports = {\n  LDKeyPair\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/crypto-ld/lib/LDKeyPair.js?");

/***/ }),

/***/ "./node_modules/crypto-ld/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-ld/lib/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2018-2020 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {CryptoLD} = __webpack_require__(/*! ./CryptoLD */ \"./node_modules/crypto-ld/lib/CryptoLD.js\");\nconst {LDKeyPair} = __webpack_require__(/*! ./LDKeyPair */ \"./node_modules/crypto-ld/lib/LDKeyPair.js\");\n\nmodule.exports = {\n  CryptoLD,\n  LDKeyPair\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/crypto-ld/lib/index.js?");

/***/ }),

/***/ "./node_modules/ed25519-signature-2018-context/dist/context.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ed25519-signature-2018-context/dist/context.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"CONTEXT\": () => (/* binding */ context_3),\n/* harmony export */   \"CONTEXT_URL\": () => (/* binding */ context_4),\n/* harmony export */   \"appContextMap\": () => (/* binding */ context_5),\n/* harmony export */   \"constants\": () => (/* binding */ context_2),\n/* harmony export */   \"contexts\": () => (/* binding */ context_1),\n/* harmony export */   \"documentLoader\": () => (/* binding */ context_6)\n/* harmony export */ });\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar context = createCommonjsModule(function (module, exports) {\n!function(t,e){for(var i in e)t[i]=e[i];}(exports,function(t){var e={};function i(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=t,i.c=e,i.d=function(t,e,r){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r});},i.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0});},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var o in t)i.d(r,o,function(e){return t[e]}.bind(null,o));return r},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p=\"\",i(i.s=2)}([function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */t.exports={\"@context\":{id:\"@id\",type:\"@type\",\"@protected\":!0,proof:{\"@id\":\"https://w3id.org/security#proof\",\"@type\":\"@id\",\"@container\":\"@graph\"},Ed25519VerificationKey2018:{\"@id\":\"https://w3id.org/security#Ed25519VerificationKey2018\",\"@context\":{\"@protected\":!0,id:\"@id\",type:\"@type\",controller:{\"@id\":\"https://w3id.org/security#controller\",\"@type\":\"@id\"},revoked:{\"@id\":\"https://w3id.org/security#revoked\",\"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"},publicKeyBase58:{\"@id\":\"https://w3id.org/security#publicKeyBase58\"}}},Ed25519Signature2018:{\"@id\":\"https://w3id.org/security#Ed25519Signature2018\",\"@context\":{\"@protected\":!0,id:\"@id\",type:\"@type\",challenge:\"https://w3id.org/security#challenge\",created:{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"},domain:\"https://w3id.org/security#domain\",expires:{\"@id\":\"https://w3id.org/security#expiration\",\"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"},nonce:\"https://w3id.org/security#nonce\",proofPurpose:{\"@id\":\"https://w3id.org/security#proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@protected\":!0,id:\"@id\",type:\"@type\",assertionMethod:{\"@id\":\"https://w3id.org/security#assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},authentication:{\"@id\":\"https://w3id.org/security#authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},capabilityInvocation:{\"@id\":\"https://w3id.org/security#capabilityInvocationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},capabilityDelegation:{\"@id\":\"https://w3id.org/security#capabilityDelegationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},keyAgreement:{\"@id\":\"https://w3id.org/security#keyAgreementMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},jws:{\"@id\":\"https://w3id.org/security#jws\"},verificationMethod:{\"@id\":\"https://w3id.org/security#verificationMethod\",\"@type\":\"@id\"}}}}};},function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */t.exports={CONTEXT_FILENAME:\"ed25519-signature-2018-v1.jsonld\",CONTEXT_URL:\"https://w3id.org/security/suites/ed25519-2018/v1\",CBORLD_CODEC_VALUE:19};},function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */const r=i(0),o=i(1),{documentLoader:n}=i(3),{CONTEXT_URL:d,CBORLD_CODEC_VALUE:c}=o,s=new Map;s.set(d,r);const p=new Map;p.set(d,c),t.exports={constants:o,contexts:s,appContextMap:p,documentLoader:n,CONTEXT_URL:d,CONTEXT:r};},function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */const{CONTEXT_URL:r}=i(1),o=i(0);t.exports={documentLoader(t){if(t!==r)throw new Error(`Loading document \"${t}\" is not allowed.`);return {contextUrl:null,document:o,documentUrl:t}}};}]));\n});\n\nvar context$1 = unwrapExports(context);\nvar context_1 = context.contexts;\nvar context_2 = context.constants;\nvar context_3 = context.CONTEXT;\nvar context_4 = context.CONTEXT_URL;\nvar context_5 = context.appContextMap;\nvar context_6 = context.documentLoader;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (context$1);\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/ed25519-signature-2018-context/dist/context.esm.js?");

/***/ }),

/***/ "./node_modules/ed25519-signature-2020-context/dist/context.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ed25519-signature-2020-context/dist/context.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"CONTEXT\": () => (/* binding */ context_3),\n/* harmony export */   \"CONTEXT_URL\": () => (/* binding */ context_4),\n/* harmony export */   \"appContextMap\": () => (/* binding */ context_5),\n/* harmony export */   \"constants\": () => (/* binding */ context_2),\n/* harmony export */   \"contexts\": () => (/* binding */ context_1),\n/* harmony export */   \"documentLoader\": () => (/* binding */ context_6)\n/* harmony export */ });\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar context = createCommonjsModule(function (module, exports) {\n!function(t,e){for(var i in e)t[i]=e[i];}(exports,function(t){var e={};function i(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=t,i.c=e,i.d=function(t,e,r){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r});},i.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0});},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var o in t)i.d(r,o,function(e){return t[e]}.bind(null,o));return r},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p=\"\",i(i.s=2)}([function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */t.exports={\"@context\":{id:\"@id\",type:\"@type\",\"@protected\":!0,proof:{\"@id\":\"https://w3id.org/security#proof\",\"@type\":\"@id\",\"@container\":\"@graph\"},Ed25519VerificationKey2020:{\"@id\":\"https://w3id.org/security#Ed25519VerificationKey2020\",\"@context\":{\"@protected\":!0,id:\"@id\",type:\"@type\",controller:{\"@id\":\"https://w3id.org/security#controller\",\"@type\":\"@id\"},revoked:{\"@id\":\"https://w3id.org/security#revoked\",\"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"},publicKeyMultibase:{\"@id\":\"https://w3id.org/security#publicKeyMultibase\",\"@type\":\"https://w3id.org/security#multibase\"}}},Ed25519Signature2020:{\"@id\":\"https://w3id.org/security#Ed25519Signature2020\",\"@context\":{\"@protected\":!0,id:\"@id\",type:\"@type\",challenge:\"https://w3id.org/security#challenge\",created:{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"},domain:\"https://w3id.org/security#domain\",expires:{\"@id\":\"https://w3id.org/security#expiration\",\"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"},nonce:\"https://w3id.org/security#nonce\",proofPurpose:{\"@id\":\"https://w3id.org/security#proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@protected\":!0,id:\"@id\",type:\"@type\",assertionMethod:{\"@id\":\"https://w3id.org/security#assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},authentication:{\"@id\":\"https://w3id.org/security#authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},capabilityInvocation:{\"@id\":\"https://w3id.org/security#capabilityInvocationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},capabilityDelegation:{\"@id\":\"https://w3id.org/security#capabilityDelegationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},keyAgreement:{\"@id\":\"https://w3id.org/security#keyAgreementMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},proofValue:{\"@id\":\"https://w3id.org/security#proofValue\",\"@type\":\"https://w3id.org/security#multibase\"},verificationMethod:{\"@id\":\"https://w3id.org/security#verificationMethod\",\"@type\":\"@id\"}}}}};},function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */t.exports={CONTEXT_FILENAME:\"ed25519-signature-2020-v1.jsonld\",CONTEXT_URL:\"https://w3id.org/security/suites/ed25519-2020/v1\",CBORLD_CODEC_VALUE:20};},function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */const r=i(0),o=i(1),{documentLoader:n}=i(3),{CONTEXT_URL:d,CBORLD_CODEC_VALUE:c}=o,s=new Map;s.set(o.CONTEXT_URL,r);const p=new Map;p.set(d,c),t.exports={constants:o,contexts:s,appContextMap:p,documentLoader:n,CONTEXT_URL:d,CONTEXT:r};},function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */const{CONTEXT_URL:r}=i(1),o=i(0);t.exports={documentLoader(t){if(t!==r)throw new Error(`Loading document \"${t}\" is not allowed.`);return {contextUrl:null,document:o,documentUrl:t}}};}]));\n});\n\nvar context$1 = unwrapExports(context);\nvar context_1 = context.contexts;\nvar context_2 = context.constants;\nvar context_3 = context.CONTEXT;\nvar context_4 = context.CONTEXT_URL;\nvar context_5 = context.appContextMap;\nvar context_6 = context.documentLoader;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (context$1);\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/ed25519-signature-2020-context/dist/context.esm.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/ProofSet.js":
/*!********************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/ProofSet.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/jsonld-signatures/lib/constants.js\");\nconst jsonld = __webpack_require__(/*! jsonld */ \"./node_modules/jsonld/lib/jsonld.js\");\nconst {extendContextLoader, strictDocumentLoader} = __webpack_require__(/*! ./documentLoader */ \"./node_modules/jsonld-signatures/lib/documentLoader.js\");\nconst {serializeError} = __webpack_require__(/*! serialize-error */ \"./node_modules/serialize-error/index.js\");\nconst strictExpansionMap = __webpack_require__(/*! ./expansionMap */ \"./node_modules/jsonld-signatures/lib/expansionMap.js\");\n\nmodule.exports = class ProofSet {\n  /**\n   * Adds a Linked Data proof to a document. If the document contains other\n   * proofs, the new proof will be appended to the existing set of proofs.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object} - JSON-LD Document to be signed.\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature} a signature suite instance\n   *   that will create the proof.\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   augment the proof with information describing its intended purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   * @param [expansionMap] {function} A custom expansion map that is\n   *   passed to the JSON-LD processor; by default a function that will throw\n   *   an error when unmapped properties are detected in the input, use `false`\n   *   to turn this off and allow unmapped properties to be dropped or use a\n   *   custom function.\n   *\n   * @return {Promise<object>} resolves with the signed document, with\n   *   the signature in the top-level `proof` property.\n   */\n  async add(document, {suite, purpose, documentLoader, expansionMap} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n    if(expansionMap !== false) {\n      expansionMap = strictExpansionMap;\n    }\n\n    // preprocess document to prepare to remove existing proofs\n    // let input;\n    // shallow copy document to allow removal of existing proofs\n    const input = {...document};\n\n    delete input.proof;\n\n    // create the new proof (suites MUST output a proof using the security-v2\n    // `@context`)\n    const proof = await suite.createProof({\n      document: input, purpose, documentLoader, expansionMap\n    });\n\n    jsonld.addValue(document, 'proof', proof);\n\n    return document;\n  }\n\n  /**\n   * Verifies Linked Data proof(s) on a document. The proofs to be verified\n   * must match the given proof purpose.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param {object} document - The JSON-LD document with one or more proofs to\n   *   be verified.\n   *\n   * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n   *   Acceptable signature suite instances for verifying the proof(s).\n   *\n   * @param {ProofPurpose} purpose - A proof purpose instance that will\n   *   match proofs to be verified and ensure they were created according to\n   *   the appropriate purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {function} [documentLoader]  a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   * @param {function} [expansionMap] - A custom expansion map that is\n   *   passed to the JSON-LD processor; by default a function that will throw\n   *   an error when unmapped properties are detected in the input, use `false`\n   *   to turn this off and allow unmapped properties to be dropped or use a\n   *   custom function.\n   *\n   * @return {Promise<{verified: boolean, results: Array, error: *}>} resolves\n   *   with an object with a `verified`boolean property that is `true` if at\n   *   least one proof matching the given purpose and suite verifies and `false`\n   *   otherwise; a `results` property with an array of detailed results;\n   *   if `false` an `error` property will be present.\n   */\n  async verify(document, {suite, purpose, documentLoader, expansionMap} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n    const suites = Array.isArray(suite) ? suite : [suite];\n    if(suites.length === 0) {\n      throw new TypeError('At least one suite is required.');\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n    if(expansionMap !== false) {\n      expansionMap = strictExpansionMap;\n    }\n\n    try {\n      // shallow copy to allow for removal of proof set prior to canonize\n      document = {...document};\n\n      // get proofs from document\n      const {proofSet, document: doc} = await _getProofs({\n        document, documentLoader, expansionMap\n      });\n      document = doc;\n\n      // verify proofs\n      const results = await _verify({\n        document, suites, proofSet, purpose, documentLoader, expansionMap\n      });\n      if(results.length === 0) {\n        const error = new Error(\n          'Did not verify any proofs; insufficient proofs matched the ' +\n          'acceptable suite(s) and required purpose(s).');\n        error.name = 'NotFoundError';\n        throw error;\n      }\n\n      // combine results\n      const verified = results.some(r => r.verified);\n      if(!verified) {\n        const errors = [].concat(\n          ...results.filter(r => r.error).map(r => r.error));\n        const result = {verified, results};\n        if(errors.length > 0) {\n          result.error = errors;\n        }\n        return result;\n      }\n      return {verified, results};\n    } catch(error) {\n      _makeSerializable(error);\n      return {verified: false, error};\n    }\n  }\n};\n\nasync function _getProofs({document}) {\n  // handle document preprocessing to find proofs\n  let proofSet;\n  proofSet = jsonld.getValues(document, 'proof');\n  delete document.proof;\n\n  if(proofSet.length === 0) {\n    // no possible matches\n    throw new Error('No matching proofs found in the given document.');\n  }\n\n  // shallow copy proofs and add document context or SECURITY_CONTEXT_URL\n  const context = document['@context'] || constants.SECURITY_CONTEXT_URL;\n  proofSet = proofSet.map(proof => ({\n    '@context': context,\n    ...proof\n  }));\n\n  return {proofSet, document};\n}\n\nasync function _verify({\n  document, suites, proofSet, purpose, documentLoader, expansionMap\n}) {\n  // map each purpose to at least one proof to verify\n  const purposes = Array.isArray(purpose) ? purpose : [purpose];\n  const purposeToProofs = new Map();\n  const proofToSuite = new Map();\n  const suiteMatchQueue = new Map();\n  await Promise.all(purposes.map(purpose => _matchProofSet({\n    purposeToProofs, proofToSuite, purpose, proofSet, suites,\n    suiteMatchQueue, document, documentLoader, expansionMap\n  })));\n\n  // every purpose must have at least one matching proof or verify will fail\n  if(purposeToProofs.size < purposes.length) {\n    // insufficient proofs to verify, so don't bother verifying any\n    return [];\n  }\n\n  // verify every proof in `proofToSuite`; these proofs matched a purpose\n  const verifyResults = new Map();\n  await Promise.all([...proofToSuite.entries()].map(async ([proof, suite]) => {\n    let result;\n    try {\n      // create backwards-compatible deferred proof purpose to capture\n      // verification method from old-style suites\n      let vm;\n      const purpose = {\n        async validate(proof, {verificationMethod}) {\n          vm = verificationMethod;\n          return {valid: true};\n        }\n      };\n      const {verified, verificationMethod, error} = await suite.verifyProof({\n        proof, document, purpose, documentLoader, expansionMap\n      });\n      if(!vm) {\n        vm = verificationMethod;\n      }\n      result = {proof, verified, verificationMethod: vm, error};\n    } catch(error) {\n      result = {proof, verified: false, error};\n    }\n\n    if(result.error) {\n      // ensure error is serializable\n      _makeSerializable(result.error);\n    }\n\n    verifyResults.set(proof, result);\n  }));\n\n  // validate proof against each purpose that matched it\n  await Promise.all([...purposeToProofs.entries()].map(\n    async ([purpose, proofs]) => {\n      for(const proof of proofs) {\n        const result = verifyResults.get(proof);\n        if(!result.verified) {\n          // if proof was not verified, so not bother validating purpose\n          continue;\n        }\n\n        // validate purpose\n        const {verificationMethod} = result;\n        const suite = proofToSuite.get(proof);\n        let purposeResult;\n        try {\n          purposeResult = await purpose.validate(proof, {\n            document, suite, verificationMethod, documentLoader, expansionMap\n          });\n        } catch(error) {\n          purposeResult = {valid: false, error};\n        }\n\n        // add `purposeResult` to verification result regardless of validity\n        // to ensure that all purposes are represented\n        if(result.purposeResult) {\n          if(Array.isArray(result.purposeResult)) {\n            result.purposeResult.push(purposeResult);\n          } else {\n            result.purposeResult = [result.purposeResult, purposeResult];\n          }\n        } else {\n          result.purposeResult = purposeResult;\n        }\n\n        if(!purposeResult.valid) {\n          // ensure error is serializable\n          _makeSerializable(purposeResult.error);\n\n          // if no top level error set yet, set it\n          if(!result.error) {\n            result.verified = false;\n            result.error = purposeResult.error;\n          }\n        }\n      }\n    }));\n\n  return [...verifyResults.values()];\n}\n\n// add a `toJSON` method to an error which allows for errors in validation\n// reports to be serialized properly by `JSON.stringify`.\nfunction _makeSerializable(error) {\n  Object.defineProperty(error, 'toJSON', {\n    value: function() {\n      return serializeError(this);\n    },\n    configurable: true,\n    writable: true\n  });\n}\n\nasync function _matchProofSet({\n  purposeToProofs, proofToSuite, purpose, proofSet, suites,\n  suiteMatchQueue, document, documentLoader, expansionMap\n}) {\n  for(const proof of proofSet) {\n    // first check if the proof matches the purpose; if it doesn't continue\n    if(!await purpose.match(proof, {document, documentLoader, expansionMap})) {\n      continue;\n    }\n\n    // next, find the suite that can verify the proof; if found, `matched`\n    // will be set to `true` and the proof will be added to `purposeToProofs`\n    // and `proofToSuite` to be processed -- otherwise it will not be; if\n    // no proofs are added for a given purpose, an exception will be thrown\n    let matched = false;\n    for(const s of suites) {\n      // `matchingProofs` is a map of promises that resolve to whether a\n      // proof matches a suite; multiple purposes and suites may be checked\n      // in parallel so a promise queue is used to prevent duplicate work\n      let matchingProofs = suiteMatchQueue.get(s);\n      if(!matchingProofs) {\n        suiteMatchQueue.set(s, matchingProofs = new Map());\n      }\n      let promise = matchingProofs.get(proof);\n      if(!promise) {\n        promise = s.matchProof({proof, document, documentLoader, expansionMap});\n        matchingProofs.set(proof, promise);\n      }\n      if(await promise) {\n        // found the matching suite for the proof; there should only be one\n        // suite that can verify a particular proof; add the proof to the\n        // map of proofs to be verified along with the matching suite\n        matched = true;\n        proofToSuite.set(proof, s);\n        break;\n      }\n    }\n\n    if(matched) {\n      // note proof was a match for the purpose and an acceptable suite; it\n      // will need to be verified by the suite and then validated against the\n      // purpose\n      const matches = purposeToProofs.get(purpose);\n      if(matches) {\n        matches.push(proof);\n      } else {\n        purposeToProofs.set(purpose, [proof]);\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/ProofSet.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/VerificationError.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/VerificationError.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n/**\n * Used as an umbrella wrapper around multiple verification errors.\n */\nclass VerificationError extends Error {\n  /**\n   * @param {Error|Error[]} errors\n   */\n  constructor(errors) {\n    super('Verification error(s).');\n\n    this.name = 'VerificationError';\n    this.errors = [].concat(errors);\n  }\n}\nmodule.exports = VerificationError;\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/VerificationError.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/constants.js":
/*!*********************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/constants.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {constants: securityConstants} = __webpack_require__(/*! security-context */ \"./node_modules/security-context/dist/module.js\");\n\nmodule.exports = {\n  SECURITY_CONTEXT_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_CONTEXT_V1_URL: securityConstants.SECURITY_CONTEXT_V1_URL,\n  SECURITY_CONTEXT_V2_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_PROOF_URL: 'https://w3id.org/security#proof',\n  SECURITY_SIGNATURE_URL: 'https://w3id.org/security#signature'\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/constants.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/contexts.js":
/*!********************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/contexts.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/jsonld-signatures/lib/constants.js\");\nconst {contexts: securityContexts} = __webpack_require__(/*! security-context */ \"./node_modules/security-context/dist/module.js\");\n\nmodule.exports = new Map([\n  [constants.SECURITY_CONTEXT_V1_URL,\n    securityContexts.get(constants.SECURITY_CONTEXT_V1_URL)],\n  [constants.SECURITY_CONTEXT_V2_URL,\n    securityContexts.get(constants.SECURITY_CONTEXT_V2_URL)]\n]);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/contexts.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/documentLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/documentLoader.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n/*eslint max-len: [\"error\", { \"ignoreComments\": true }]*/\n\n// load locally embedded contexts\nconst contexts = __webpack_require__(/*! ./contexts */ \"./node_modules/jsonld-signatures/lib/contexts.js\");\n\n/**\n * This is a utility module that provides a set of functions for using or\n * extending jsonld-signature's built-in JSON-LD document loader.\n * @see https://www.w3.org/TR/json-ld11-api/#loaddocumentcallback\n */\nconst api = {};\nmodule.exports = api;\n\napi.extendContextLoader = documentLoader => {\n  /**\n   * extendContextLoader extends another JSON-LD document loader.\n   * Given a document loader to extend, this method will return a\n   * new document loader that will first check for a URL in\n   * jsonld-signature's built-in context map and, if not found,\n   * it will fall back to using the passed document loader.\n   * This utility method can be used to ensure that any local,\n   * in-memory, immutable context documents provided by\n   * jsonld-signatures will be used prior to using another\n   * document loader to load other documents.\n   *\n   * @param {Function} documentLoader - A function that fetches a document.\n   * @see [node documentLoader example]{@link https://github.com/digitalbazaar/jsonld.js/blob/master/lib/documentLoaders/node.js}\n   * @see [xhr documentLoader example]{@link https://github.com/digitalbazaar/jsonld.js/blob/master/lib/documentLoaders/xhr.js}\n   *\n   * @returns {Function} A function that accepts a\n   * url then fetches a jsonld document.\n   */\n  return async url => {\n    const context = contexts.get(url);\n    if(context !== undefined) {\n      return {\n        contextUrl: null,\n        documentUrl: url,\n        document: context,\n        tag: 'static'\n      };\n    }\n    return documentLoader(url);\n  };\n};\n\napi.strictDocumentLoader = api.extendContextLoader(url => {\n  /**\n   * strictDocumentLoader extends extendContextLoader.\n   * ensuring no network calls are made so the only documents\n   * available are the built-in contexts.\n   * @see documentLoader.extendContextLoader\n   *\n   * @param {string} url - A valid url to a jsonld context.\n   *\n   * @throws {Error} Always throws an error if the\n   * url is not in the context map\n   * (i.e., not a URL for a locally available context document).\n   * @return {Object} A JSON-LD RemoteDocument\n   * that is a copy of a locally available context.\n   */\n  throw new Error(`${url} not found.`);\n});\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/documentLoader.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/expansionMap.js":
/*!************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/expansionMap.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n// strict expansion map disallows dropping properties when expanding by default\nmodule.exports = info => {\n  if(info.unmappedProperty) {\n    throw new Error('The property \"' +\n       info.unmappedProperty + '\" in the input ' +\n      'was not defined in the context.');\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/expansionMap.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/jsonld-signatures.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/jsonld-signatures.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2010-2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n/* Core API */\nconst api = {};\nmodule.exports = api;\n\n/* API Constants */\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/jsonld-signatures/lib/constants.js\");\nObject.assign(api, constants);\n\n// TODO: support `ProofChain`\nconst ProofSet = __webpack_require__(/*! ./ProofSet */ \"./node_modules/jsonld-signatures/lib/ProofSet.js\");\nconst VerificationError = __webpack_require__(/*! ./VerificationError */ \"./node_modules/jsonld-signatures/lib/VerificationError.js\");\n\n/**\n * Cryptographically signs the provided document by adding a `proof` section,\n * based on the provided suite and proof purpose.\n *\n * @param {object} document - The JSON-LD document to be signed.\n *\n * @param {object} options - Options hashmap.\n * @param {LinkedDataSignature} options.suite - The linked data signature\n *   cryptographic suite, containing private key material, with which to sign\n *   the document.\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * @param {function} documentLoader  - A secure document loader (it is\n *   recommended to use one that provides static known documents, instead of\n *   fetching from the web) for returning contexts, controller documents, keys,\n *   and other relevant URLs needed for the proof.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [options.expansionMap] - A custom expansion map that is\n *   passed to the JSON-LD processor; by default a function that will throw\n *   an error when unmapped properties are detected in the input, use `false`\n *   to turn this off and allow unmapped properties to be dropped or use a\n *   custom function.\n * @param {boolean} [options.addSuiteContext=true] - Toggles the default\n *   behavior of each signature suite enforcing the presence of its own\n *   `@context` (if it is not present, it's added to the context list).\n *\n * @returns {Promise<object>} Resolves with signed document.\n */\napi.sign = async function sign(document, {\n  suite, purpose, documentLoader, expansionMap, addSuiteContext = true\n} = {}) {\n  if(typeof document !== 'object') {\n    throw new TypeError('The \"document\" parameter must be an object.');\n  }\n  // Ensure document contains the signature suite specific context URL\n  // or throw an error (in case an advanced user overrides the `addSuiteContext`\n  // flag to false).\n  suite.ensureSuiteContext({document, addSuiteContext});\n\n  try {\n    return await new ProofSet().add(\n      document, {suite, purpose, documentLoader, expansionMap});\n  } catch(e) {\n    if(!documentLoader && e.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = e;\n      const err = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"sign\".');\n      err.cause = e;\n      throw err;\n    }\n    throw e;\n  }\n};\n\n/**\n * Verifies the linked data signature on the provided document.\n *\n * @param {object} document - The JSON-LD document with one or more proofs to be\n *   verified.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n *   Acceptable signature suite instances for verifying the proof(s).\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [documentLoader]  - A custom document loader,\n *   `Promise<RemoteDocument> documentLoader(url)`.\n * @param {function} [expansionMap] - A custom expansion map that is\n *   passed to the JSON-LD processor; by default a function that will throw\n *   an error when unmapped properties are detected in the input, use `false`\n *   to turn this off and allow unmapped properties to be dropped or use a\n *   custom function.\n *\n * @return {Promise<{verified: boolean, results: Array,\n *   error: VerificationError}>}\n *   resolves with an object with a `verified` boolean property that is `true`\n *   if at least one proof matching the given purpose and suite verifies and\n *   `false` otherwise; a `results` property with an array of detailed results;\n *   if `false` an `error` property will be present, with `error.errors`\n *   containing all of the errors that occurred during the verification process.\n */\napi.verify = async function verify(document, {\n  suite, purpose, documentLoader, expansionMap} = {}) {\n  if(typeof document !== 'object') {\n    throw new TypeError('The \"document\" parameter must be an object.');\n  }\n  const result = await new ProofSet().verify(\n    document, {suite, purpose, documentLoader, expansionMap});\n  const {error} = result;\n  if(error) {\n    if(!documentLoader && error.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = error;\n      const urlError = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"verify\".');\n      result.error = new VerificationError(urlError);\n    } else {\n      result.error = new VerificationError(error);\n    }\n  }\n  return result;\n};\n\n// expose suite classes\napi.suites = (__webpack_require__(/*! ./suites */ \"./node_modules/jsonld-signatures/lib/suites.js\").suites);\n\n// expose ProofPurpose classes to enable extensions\napi.purposes = (__webpack_require__(/*! ./purposes */ \"./node_modules/jsonld-signatures/lib/purposes.js\").purposes);\n\n// expose document loader helpers\nObject.assign(api, __webpack_require__(/*! ./documentLoader */ \"./node_modules/jsonld-signatures/lib/documentLoader.js\"));\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/jsonld-signatures.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/purposes.js":
/*!********************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/purposes.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst api = {};\nmodule.exports = api;\n\n// TODO: only require dynamically as needed or according to build\napi.purposes = {\n  AssertionProofPurpose: __webpack_require__(/*! ./purposes/AssertionProofPurpose */ \"./node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js\"),\n  AuthenticationProofPurpose: __webpack_require__(/*! ./purposes/AuthenticationProofPurpose */ \"./node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js\"),\n  ControllerProofPurpose: __webpack_require__(/*! ./purposes/ControllerProofPurpose */ \"./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js\"),\n  ProofPurpose: __webpack_require__(/*! ./purposes/ProofPurpose */ \"./node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js\")\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/purposes.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js":
/*!******************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst ControllerProofPurpose = __webpack_require__(/*! ./ControllerProofPurpose */ \"./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js\");\n\nmodule.exports = class AssertionProofPurpose extends ControllerProofPurpose {\n  constructor({\n    term = 'assertionMethod', controller,\n    date, maxTimestampDelta = Infinity} = {}) {\n    super({term, controller, date, maxTimestampDelta});\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst ControllerProofPurpose = __webpack_require__(/*! ./ControllerProofPurpose */ \"./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js\");\n\nmodule.exports = class AuthenticationProofPurpose extends\n  ControllerProofPurpose {\n  constructor({\n    term = 'authentication', controller,\n    challenge, date, domain, maxTimestampDelta = Infinity} = {}) {\n    super({term, controller, date, maxTimestampDelta});\n    if(typeof challenge !== 'string') {\n      throw new TypeError('\"challenge\" must be a string.');\n    }\n    if(domain !== undefined && typeof domain !== 'string') {\n      throw new TypeError('\"domain\" must be a string.');\n    }\n    this.challenge = challenge;\n    this.domain = domain;\n  }\n\n  async validate(proof, {verificationMethod, documentLoader, expansionMap}) {\n    try {\n      // check challenge\n      if(proof.challenge !== this.challenge) {\n        throw new Error('The challenge is not as expected; ' +\n          `challenge=\"${proof.challenge}\", expected=\"${this.challenge}\"`);\n      }\n\n      // check domain\n      if(this.domain !== undefined && proof.domain !== this.domain) {\n        throw new Error('The domain is not as expected; ' +\n          `domain=\"${proof.domain}\", expected=\"${this.domain}\"`);\n      }\n\n      return super.validate(\n        proof, {verificationMethod, documentLoader, expansionMap});\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n\n  async update(proof, {document, suite, documentLoader, expansionMap}) {\n    proof = await super.update(\n      proof, {document, suite, documentLoader, expansionMap});\n    proof.challenge = this.challenge;\n    if(this.domain !== undefined) {\n      proof.domain = this.domain;\n    }\n    return proof;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst constants = __webpack_require__(/*! ../constants */ \"./node_modules/jsonld-signatures/lib/constants.js\");\nconst jsonld = __webpack_require__(/*! jsonld */ \"./node_modules/jsonld/lib/jsonld.js\");\nconst ProofPurpose = __webpack_require__(/*! ./ProofPurpose */ \"./node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js\");\n\n// DID documents can be specially optimized\nconst DID_CONTEXT_V1 = 'https://www.w3.org/ns/did/v1';\n// verification relationship terms that are known to appear in DID documents\nconst DID_VR_TERMS = [\n  'assertionMethod',\n  'authentication',\n  'capabilityInvocation',\n  'capabilityDelegation',\n  'keyAgreement',\n  'verificationMethod'\n];\n\nmodule.exports = class ControllerProofPurpose extends ProofPurpose {\n  /**\n   * Creates a proof purpose that will validate whether or not the verification\n   * method in a proof was authorized by its declared controller for the\n   * proof's purpose.\n   *\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [controller] {object} the description of the controller, if it\n   *   is not to be dereferenced via a `documentLoader`.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({term, controller, date, maxTimestampDelta = Infinity} = {}) {\n    super({term, date, maxTimestampDelta});\n    if(controller !== undefined) {\n      if(typeof controller !== 'object') {\n        throw new TypeError('\"controller\" must be an object.');\n      }\n      this.controller = controller;\n    }\n    this._termDefinedByDIDContext = DID_VR_TERMS.includes(term);\n  }\n\n  /**\n   * Validates the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof\n   * @param verificationMethod\n   * @param documentLoader\n   * @param expansionMap\n   *\n   * @throws {Error} If verification method not authorized by controller\n   * @throws {Error} If proof's created timestamp is out of range\n   *\n   * @returns {Promise<{valid: boolean, error: Error}>}\n   */\n  async validate(proof, {verificationMethod, documentLoader, expansionMap}) {\n    try {\n      const result = await super.validate(\n        proof, {verificationMethod, documentLoader, expansionMap});\n      if(!result.valid) {\n        throw result.error;\n      }\n\n      const {id: verificationId} = verificationMethod;\n      const {term, _termDefinedByDIDContext} = this;\n\n      // if no `controller` specified, use verification method's\n      if(this.controller) {\n        result.controller = this.controller;\n      } else {\n        const {controller} = verificationMethod;\n        let controllerId;\n        if(controller) {\n          if(typeof controller === 'object') {\n            controllerId = controller.id;\n          } else if(typeof controller !== 'string') {\n            throw new TypeError(\n              '\"controller\" must be a string representing a URL.');\n          } else {\n            controllerId = controller;\n          }\n        }\n\n        // apply optimization to controller documents that are DID documents;\n        // if `term` is one of those defined by the DID context\n        let {document} = await documentLoader(controllerId);\n        const mustFrame = !(_termDefinedByDIDContext &&\n          document['@context'] === DID_CONTEXT_V1 ||\n          (Array.isArray(document['@context']) &&\n          document['@context'][0] === DID_CONTEXT_V1));\n        if(mustFrame) {\n          // Note: `expansionMap` is intentionally not passed; we can safely\n          // drop properties here and must allow for it\n          document = await jsonld.frame(document, {\n            '@context': constants.SECURITY_CONTEXT_URL,\n            id: controllerId,\n            // this term must be in the JSON-LD controller document or\n            // verification will fail\n            [term]: {\n              '@embed': '@never',\n              id: verificationId\n            }\n          }, {documentLoader, compactToRelative: false});\n        }\n        result.controller = document;\n      }\n\n      const verificationMethods = jsonld.getValues(result.controller, term);\n      result.valid = verificationMethods.some(vm =>\n        vm === verificationId ||\n        (typeof vm === 'object' && vm.id === verificationId));\n      if(!result.valid) {\n        throw new Error(\n          `Verification method \"${verificationMethod.id}\" not authorized ` +\n          `by controller for proof purpose \"${this.term}\".`);\n      }\n      return result;\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js":
/*!*********************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class ProofPurpose {\n  /**\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({term, date, maxTimestampDelta = Infinity} = {}) {\n    if(term === undefined) {\n      throw new Error('\"term\" is required.');\n    }\n    if(maxTimestampDelta !== undefined &&\n      typeof maxTimestampDelta !== 'number') {\n      throw new TypeError('\"maxTimestampDelta\" must be a number.');\n    }\n    this.term = term;\n    if(date !== undefined) {\n      this.date = new Date(date);\n      if(isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.maxTimestampDelta = maxTimestampDelta;\n  }\n\n  /**\n   * Called to validate the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`,\n   *   with the matching purpose to validate.\n   *\n   * @return {Promise<object>} resolves to an object with `valid` and `error`.\n   */\n  async validate(\n    proof, {/*document, suite, verificationMethod,\n      documentLoader, expansionMap*/}) {\n    try {\n      // check expiration\n      if(this.maxTimestampDelta !== Infinity) {\n        const expected = (this.date || new Date()).getTime();\n        const delta = this.maxTimestampDelta * 1000;\n        const created = new Date(proof.created).getTime();\n        // comparing this way handles NaN case where `created` is invalid\n        if(!(created >= (expected - delta) && created <= (expected + delta))) {\n          throw new Error('The proof\\'s created timestamp is out of range.');\n        }\n      }\n      return {valid: true};\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n\n  /**\n   * Called to update a proof when it is being created, adding any properties\n   * specific to this purpose. This method is called prior to the proof\n   * value being generated such that any properties added may be, for example,\n   * included in a digital signature value.\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`\n   *   to update.\n   *\n   * @return {Promise<object>} resolves to the proof instance (in the\n   *   `constants.SECURITY_CONTEXT_URL`.\n   */\n  async update(proof, {/*document, suite, documentLoader, expansionMap */}) {\n    proof.proofPurpose = this.term;\n    return proof;\n  }\n\n  /**\n   * Determines if the given proof has a purpose that matches this instance,\n   * i.e. this ProofPurpose instance should be used to validate the given\n   * proof.\n   *\n   * @param proof {object} the proof to check.\n   *\n   * @return {Promise<boolean>} `true` if there's a match, `false` if not.\n   */\n  async match(proof, {/* document, documentLoader, expansionMap */}) {\n    return proof.proofPurpose === this.term;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/sha256digest-browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/sha256digest-browser.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */\n/* eslint-env browser */\n\nconst crypto = self && (self.crypto || self.msCrypto);\n\nmodule.exports = {\n  /**\n   * Hashes a string of data using SHA-256.\n   *\n   * @param {string} string - the string to hash.\n   *\n   * @return {Uint8Array} the hash digest.\n   */\n  async sha256digest({string}) {\n    const bytes = new TextEncoder().encode(string);\n    return new Uint8Array(\n      await crypto.subtle.digest('SHA-256', bytes)\n    );\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/sha256digest-browser.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/suites.js":
/*!******************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/suites.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst api = {};\nmodule.exports = api;\n\n// TODO: only require dynamically as needed or according to build\napi.suites = {\n  LinkedDataProof: __webpack_require__(/*! ./suites/LinkedDataProof */ \"./node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js\"),\n  LinkedDataSignature: __webpack_require__(/*! ./suites/LinkedDataSignature */ \"./node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js\")\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/suites.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class LinkedDataProof {\n  constructor({type} = {}) {\n    if(typeof type !== 'string') {\n      throw new TypeError('A LinkedDataProof must have a \"type\".');\n    }\n    this.type = type;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof({\n    /* document, purpose, documentLoader, expansionMap */\n  }) {\n    throw new Error('\"createProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * @param proof {object} the proof to be verified.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({\n    /* proof, document, purpose, documentLoader, expansionMap */\n  }) {\n    throw new Error('\"verifyProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * Checks whether a given proof exists in the document.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {object} options.proof\n   *\n   * @returns {Promise<boolean>} Whether a match for the proof was found.\n   */\n  async matchProof({\n    proof /*, document, purpose, documentLoader, expansionMap */\n  }) {\n    return proof.type === this.type;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2017-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst constants = __webpack_require__(/*! ../constants */ \"./node_modules/jsonld-signatures/lib/constants.js\");\nconst jsonld = __webpack_require__(/*! jsonld */ \"./node_modules/jsonld/lib/jsonld.js\");\nconst util = __webpack_require__(/*! ../util */ \"./node_modules/jsonld-signatures/lib/util.js\");\nconst {sha256digest} = __webpack_require__(/*! ../sha256digest */ \"./node_modules/jsonld-signatures/lib/sha256digest-browser.js\");\nconst LinkedDataProof = __webpack_require__(/*! ./LinkedDataProof */ \"./node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js\");\n\nmodule.exports = class LinkedDataSignature extends LinkedDataProof {\n  /**\n   * Parent class from which the various LinkDataSignature suites (such as\n   * `Ed25519Signature2020`) inherit.\n   * NOTE: Developers are never expected to use this class directly, but to\n   * only work with individual suites.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.type - Suite name, provided by subclass.\n   * @typedef LDKeyPair\n   * @param {LDKeyPair} LDKeyClass - The crypto-ld key class that this suite\n   *   will use to sign/verify signatures. Provided by subclass. Used\n   *   during the `verifySignature` operation, to create an instance (containing\n   *   a `verifier()` property) of a public key fetched via a `documentLoader`.\n   *\n   * @param {string} contextUrl - JSON-LD context URL that corresponds to this\n   *   signature suite. Provided by subclass. Used for enforcing suite context\n   *   during the `sign()` operation.\n   *\n   * For `sign()` operations, either a `key` OR a `signer` is required.\n   * For `verify()` operations, you can pass in a verifier (from KMS), or\n   * the public key will be fetched via documentLoader.\n   *\n   * @param {object} [options.key] - An optional key object (containing an\n   *   `id` property, and either `signer` or `verifier`, depending on the\n   *   intended operation. Useful for when the application is managing keys\n   *   itself (when using a KMS, you never have access to the private key,\n   *   and so should use the `signer` param instead).\n   *\n   * @param {{sign: Function, id: string}} [options.signer] - Signer object\n   *   that has two properties: an async `sign()` method, and an `id`. This is\n   *   useful when interfacing with a KMS (since you don't get access to the\n   *   private key and its `signer`, the KMS client gives you only the signer\n   *   object to use).\n   *\n   * @param {{verify: Function, id: string}} [options.verifier] - Verifier\n   *   object that has two properties: an async `verify()` method, and an `id`.\n   *   Useful when working with a KMS-provided verifier.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {object} [options.proof] - A JSON-LD document with options to use\n   *   for the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2). If not provided, this is\n   *   constructed during signing.\n   * @param {string|Date} [options.date] - Signing date to use (otherwise\n   *   defaults to `now()`).\n   * @param {boolean} [options.useNativeCanonize] - Whether to use a native\n   *   canonize algorithm.\n   */\n  constructor({\n    type, proof, LDKeyClass, date, key, signer, verifier, useNativeCanonize,\n    contextUrl\n  } = {}) {\n    super({type});\n    this.LDKeyClass = LDKeyClass;\n    this.contextUrl = contextUrl;\n    this.proof = proof;\n    const vm = _processSignatureParams({key, signer, verifier});\n    this.verificationMethod = vm.verificationMethod;\n    this.key = vm.key;\n    this.signer = vm.signer;\n    this.verifier = vm.verifier;\n    if(date) {\n      this.date = new Date(date);\n      if(isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.useNativeCanonize = useNativeCanonize;\n    this._hashCache = null;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof({document, purpose, documentLoader, expansionMap}) {\n    // build proof (currently known as `signature options` in spec)\n    let proof;\n    if(this.proof) {\n      // shallow copy\n      proof = {...this.proof};\n    } else {\n      // create proof JSON-LD document\n      proof = {};\n    }\n\n    // ensure proof type is set\n    proof.type = this.type;\n\n    // set default `now` date if not given in `proof` or `options`\n    let date = this.date;\n    if(proof.created === undefined && date === undefined) {\n      date = new Date();\n    }\n\n    // ensure date is in string format\n    if(date && typeof date !== 'string') {\n      date = util.w3cDate(date);\n    }\n\n    // add API overrides\n    if(date) {\n      proof.created = date;\n    }\n\n    proof.verificationMethod = this.verificationMethod;\n\n    // add any extensions to proof (mostly for legacy support)\n    proof = await this.updateProof({\n      document, proof, purpose, documentLoader, expansionMap\n    });\n\n    // allow purpose to update the proof; the `proof` is in the\n    // SECURITY_CONTEXT_URL `@context` -- therefore the `purpose` must\n    // ensure any added fields are also represented in that same `@context`\n    proof = await purpose.update(\n      proof, {document, suite: this, documentLoader, expansionMap});\n\n    // create data to sign\n    const verifyData = await this.createVerifyData({\n      document, proof, documentLoader, expansionMap\n    });\n\n    // sign data\n    proof = await this.sign(\n      {verifyData, document, proof, documentLoader, expansionMap});\n\n    return proof;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async updateProof({proof}) {\n    // extending classes may do more\n    return proof;\n  }\n\n  /**\n   * @param proof {object} the proof to be verified.\n   * @param document {object} the document the proof applies to.\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({proof, document, documentLoader, expansionMap}) {\n    try {\n      // create data to verify\n      const verifyData = await this.createVerifyData(\n        {document, proof, documentLoader, expansionMap});\n\n      // fetch verification method\n      const verificationMethod = await this.getVerificationMethod(\n        {proof, document, documentLoader, expansionMap});\n\n      // verify signature on data\n      const verified = await this.verifySignature({\n        verifyData, verificationMethod, document, proof,\n        documentLoader, expansionMap});\n      if(!verified) {\n        throw new Error('Invalid signature.');\n      }\n\n      return {verified: true, verificationMethod};\n    } catch(error) {\n      return {verified: false, error};\n    }\n  }\n\n  async canonize(input, {documentLoader, expansionMap, skipExpansion}) {\n    return jsonld.canonize(input, {\n      algorithm: 'URDNA2015',\n      format: 'application/n-quads',\n      documentLoader,\n      expansionMap,\n      skipExpansion,\n      useNative: this.useNativeCanonize\n    });\n  }\n\n  async canonizeProof(proof, {document, documentLoader, expansionMap}) {\n    // `jws`,`signatureValue`,`proofValue` must not be included in the proof\n    // options\n    proof = {\n      '@context': document['@context'] || constants.SECURITY_CONTEXT_URL,\n      ...proof\n    };\n    delete proof.jws;\n    delete proof.signatureValue;\n    delete proof.proofValue;\n    return this.canonize(proof, {\n      documentLoader,\n      expansionMap,\n      skipExpansion: false\n    });\n  }\n\n  /**\n   * @param document {object} to be signed/verified.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{Uint8Array}>}.\n   */\n  async createVerifyData({document, proof, documentLoader, expansionMap}) {\n    // get cached document hash\n    let cachedDocHash;\n    const {_hashCache} = this;\n    if(_hashCache && _hashCache.document === document) {\n      cachedDocHash = _hashCache.hash;\n    } else {\n      this._hashCache = {\n        document,\n        // canonize and hash document\n        hash: cachedDocHash =\n          this.canonize(document, {documentLoader, expansionMap})\n            .then(c14nDocument => sha256digest({string: c14nDocument}))\n      };\n    }\n\n    // await both c14n proof hash and c14n document hash\n    const [proofHash, docHash] = await Promise.all([\n      // canonize and hash proof\n      this.canonizeProof(\n        proof, {document, documentLoader, expansionMap})\n        .then(c14nProofOptions => sha256digest({string: c14nProofOptions})),\n      cachedDocHash\n    ]);\n\n    // concatenate hash of c14n proof options and hash of c14n document\n    return util.concat(proofHash, docHash);\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   */\n  async getVerificationMethod({proof, documentLoader}) {\n    let {verificationMethod} = proof;\n\n    if(typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n\n    if(!verificationMethod) {\n      throw new Error('No \"verificationMethod\" found in proof.');\n    }\n\n    // Note: `expansionMap` is intentionally not passed; we can safely drop\n    // properties here and must allow for it\n    const framed = await jsonld.frame(verificationMethod, {\n      '@context': constants.SECURITY_CONTEXT_URL,\n      '@embed': '@always',\n      id: verificationMethod\n    }, {documentLoader, compactToRelative: false});\n    if(!framed) {\n      throw new Error(`Verification method ${verificationMethod} not found.`);\n    }\n\n    // ensure verification method has not been revoked\n    if(framed.revoked !== undefined) {\n      throw new Error('The verification method has been revoked.');\n    }\n\n    return framed;\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} the proof containing the signature value.\n   */\n  async sign() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param verificationMethod {object}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<boolean>}\n   */\n  async verifySignature() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * Ensures the document to be signed contains the required signature suite\n   * specific `@context`, by either adding it (if `addSuiteContext` is true),\n   * or throwing an error if it's missing.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {object} options.document - JSON-LD document to be signed.\n   * @param {boolean} options.addSuiteContext - Add suite context?\n   */\n  ensureSuiteContext({document, addSuiteContext}) {\n    const {contextUrl} = this;\n\n    if(_includesContext({document, contextUrl})) {\n      // document already includes the required context\n      return;\n    }\n\n    if(!addSuiteContext) {\n      throw new TypeError(\n        `The document to be signed must contain this suite's @context, ` +\n        `\"${contextUrl}\".`);\n    }\n\n    // enforce the suite's context by adding it to the document\n    const existingContext = document['@context'] || [];\n\n    document['@context'] = Array.isArray(existingContext) ?\n      [...existingContext, contextUrl] : [existingContext, contextUrl];\n  }\n};\n\n/**\n * Tests whether a provided JSON-LD document includes a context URL in its\n * `@context` property.\n *\n * @param {object} options - Options hashmap.\n * @param {object} options.document - A JSON-LD document.\n * @param {string} options.contextUrl - A context URL.\n *\n * @returns {boolean} Returns true if document includes context.\n */\nfunction _includesContext({document, contextUrl}) {\n  const context = document['@context'];\n  return context === contextUrl ||\n    (Array.isArray(context) && context.includes(contextUrl));\n}\n\n/**\n * See constructor docstring for param details.\n *\n * @returns {{verificationMethod: string, key: LDKeyPair,\n *   signer: {sign: Function, id: string},\n *   verifier: {verify: Function, id: string}}} - Validated and initialized\n *   key-related parameters.\n */\nfunction _processSignatureParams({key, signer, verifier}) {\n  // We are explicitly not requiring a key or signer/verifier param to be\n  // present, to support the verify() use case where the verificationMethod\n  // is being fetched by the documentLoader\n\n  const vm = {};\n  if(key) {\n    vm.key = key;\n    vm.verificationMethod = key.id;\n    if(typeof key.signer === 'function') {\n      vm.signer = key.signer();\n    }\n    if(typeof key.verifier === 'function') {\n      vm.verifier = key.verifier();\n    }\n    if(!(vm.signer || vm.verifier)) {\n      throw new TypeError(\n        'The \"key\" parameter must contain a \"signer\" or \"verifier\" method.');\n    }\n  } else {\n    vm.verificationMethod = (signer && signer.id) ||\n      (verifier && verifier.id);\n    vm.signer = signer;\n    vm.verifier = verifier;\n  }\n\n  if(vm.signer) {\n    if(typeof vm.signer.sign !== 'function') {\n      throw new TypeError('A signer API has not been specified.');\n    }\n  }\n  if(vm.verifier) {\n    if(typeof vm.verifier.verify !== 'function') {\n      throw new TypeError('A verifier API has not been specified.');\n    }\n  }\n\n  return vm;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/util.js":
/*!****************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/util.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Converts the given date into W3C datetime format (eg: 2011-03-09T21:55:41Z).\n *\n * @param date the date to convert.\n *\n * @return the date in W3C datetime format.\n */\napi.w3cDate = date => {\n  if(date === undefined || date === null) {\n    date = new Date();\n  } else if(typeof date === 'number' || typeof date === 'string') {\n    date = new Date(date);\n  }\n  const str = date.toISOString();\n  return str.substr(0, str.length - 5) + 'Z';\n};\n\n/**\n * Concatenates two Uint8Arrays.\n *\n * @param b1 {Uint8Array}.\n * @param b2 {Uint8Array}.\n *\n * @return {Uint8Array} the result.\n */\napi.concat = (b1, b2) => {\n  const rval = new Uint8Array(b1.length + b2.length);\n  rval.set(b1, 0);\n  rval.set(b2, b1.length);\n  return rval;\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/util.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/ContextResolver.js":
/*!****************************************************!*\
  !*** ./node_modules/jsonld/lib/ContextResolver.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n} = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\nconst {\n  asArray: _asArray\n} = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\nconst {prependBase} = __webpack_require__(/*! ./url */ \"./node_modules/jsonld/lib/url.js\");\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\nconst ResolvedContext = __webpack_require__(/*! ./ResolvedContext */ \"./node_modules/jsonld/lib/ResolvedContext.js\");\n\nconst MAX_CONTEXT_URLS = 10;\n\nmodule.exports = class ContextResolver {\n  /**\n   * Creates a ContextResolver.\n   *\n   * @param sharedCache a shared LRU cache with `get` and `set` APIs.\n   */\n  constructor({sharedCache}) {\n    this.perOpCache = new Map();\n    this.sharedCache = sharedCache;\n  }\n\n  async resolve({\n    activeCtx, context, documentLoader, base, cycles = new Set()\n  }) {\n    // process `@context`\n    if(context && _isObject(context) && context['@context']) {\n      context = context['@context'];\n    }\n\n    // context is one or more contexts\n    context = _asArray(context);\n\n    // resolve each context in the array\n    const allResolved = [];\n    for(const ctx of context) {\n      if(_isString(ctx)) {\n        // see if `ctx` has been resolved before...\n        let resolved = this._get(ctx);\n        if(!resolved) {\n          // not resolved yet, resolve\n          resolved = await this._resolveRemoteContext(\n            {activeCtx, url: ctx, documentLoader, base, cycles});\n        }\n\n        // add to output and continue\n        if(_isArray(resolved)) {\n          allResolved.push(...resolved);\n        } else {\n          allResolved.push(resolved);\n        }\n        continue;\n      }\n      if(ctx === null) {\n        // handle `null` context, nothing to cache\n        allResolved.push(new ResolvedContext({document: null}));\n        continue;\n      }\n      if(!_isObject(ctx)) {\n        _throwInvalidLocalContext(context);\n      }\n      // context is an object, get/create `ResolvedContext` for it\n      const key = JSON.stringify(ctx);\n      let resolved = this._get(key);\n      if(!resolved) {\n        // create a new static `ResolvedContext` and cache it\n        resolved = new ResolvedContext({document: ctx});\n        this._cacheResolvedContext({key, resolved, tag: 'static'});\n      }\n      allResolved.push(resolved);\n    }\n\n    return allResolved;\n  }\n\n  _get(key) {\n    // get key from per operation cache; no `tag` is used with this cache so\n    // any retrieved context will always be the same during a single operation\n    let resolved = this.perOpCache.get(key);\n    if(!resolved) {\n      // see if the shared cache has a `static` entry for this URL\n      const tagMap = this.sharedCache.get(key);\n      if(tagMap) {\n        resolved = tagMap.get('static');\n        if(resolved) {\n          this.perOpCache.set(key, resolved);\n        }\n      }\n    }\n    return resolved;\n  }\n\n  _cacheResolvedContext({key, resolved, tag}) {\n    this.perOpCache.set(key, resolved);\n    if(tag !== undefined) {\n      let tagMap = this.sharedCache.get(key);\n      if(!tagMap) {\n        tagMap = new Map();\n        this.sharedCache.set(key, tagMap);\n      }\n      tagMap.set(tag, resolved);\n    }\n    return resolved;\n  }\n\n  async _resolveRemoteContext({activeCtx, url, documentLoader, base, cycles}) {\n    // resolve relative URL and fetch context\n    url = prependBase(base, url);\n    const {context, remoteDoc} = await this._fetchContext(\n      {activeCtx, url, documentLoader, cycles});\n\n    // update base according to remote document and resolve any relative URLs\n    base = remoteDoc.documentUrl || url;\n    _resolveContextUrls({context, base});\n\n    // resolve, cache, and return context\n    const resolved = await this.resolve(\n      {activeCtx, context, documentLoader, base, cycles});\n    this._cacheResolvedContext({key: url, resolved, tag: remoteDoc.tag});\n    return resolved;\n  }\n\n  async _fetchContext({activeCtx, url, documentLoader, cycles}) {\n    // check for max context URLs fetched during a resolve operation\n    if(cycles.size > MAX_CONTEXT_URLS) {\n      throw new JsonLdError(\n        'Maximum number of @context URLs exceeded.',\n        'jsonld.ContextUrlError',\n        {\n          code: activeCtx.processingMode === 'json-ld-1.0' ?\n            'loading remote context failed' :\n            'context overflow',\n          max: MAX_CONTEXT_URLS\n        });\n    }\n\n    // check for context URL cycle\n    // shortcut to avoid extra work that would eventually hit the max above\n    if(cycles.has(url)) {\n      throw new JsonLdError(\n        'Cyclical @context URLs detected.',\n        'jsonld.ContextUrlError',\n        {\n          code: activeCtx.processingMode === 'json-ld-1.0' ?\n            'recursive context inclusion' :\n            'context overflow',\n          url\n        });\n    }\n\n    // track cycles\n    cycles.add(url);\n\n    let context;\n    let remoteDoc;\n\n    try {\n      remoteDoc = await documentLoader(url);\n      context = remoteDoc.document || null;\n      // parse string context as JSON\n      if(_isString(context)) {\n        context = JSON.parse(context);\n      }\n    } catch(e) {\n      throw new JsonLdError(\n        'Dereferencing a URL did not result in a valid JSON-LD object. ' +\n        'Possible causes are an inaccessible URL perhaps due to ' +\n        'a same-origin policy (ensure the server uses CORS if you are ' +\n        'using client-side JavaScript), too many redirects, a ' +\n        'non-JSON response, or more than one HTTP Link Header was ' +\n        'provided for a remote context.',\n        'jsonld.InvalidUrl',\n        {code: 'loading remote context failed', url, cause: e});\n    }\n\n    // ensure ctx is an object\n    if(!_isObject(context)) {\n      throw new JsonLdError(\n        'Dereferencing a URL did not result in a JSON object. The ' +\n        'response was valid JSON, but it was not a JSON object.',\n        'jsonld.InvalidUrl', {code: 'invalid remote context', url});\n    }\n\n    // use empty context if no @context key is present\n    if(!('@context' in context)) {\n      context = {'@context': {}};\n    } else {\n      context = {'@context': context['@context']};\n    }\n\n    // append @context URL to context if given\n    if(remoteDoc.contextUrl) {\n      if(!_isArray(context['@context'])) {\n        context['@context'] = [context['@context']];\n      }\n      context['@context'].push(remoteDoc.contextUrl);\n    }\n\n    return {context, remoteDoc};\n  }\n};\n\nfunction _throwInvalidLocalContext(ctx) {\n  throw new JsonLdError(\n    'Invalid JSON-LD syntax; @context must be an object.',\n    'jsonld.SyntaxError', {\n      code: 'invalid local context', context: ctx\n    });\n}\n\n/**\n * Resolve all relative `@context` URLs in the given context by inline\n * replacing them with absolute URLs.\n *\n * @param context the context.\n * @param base the base IRI to use to resolve relative IRIs.\n */\nfunction _resolveContextUrls({context, base}) {\n  if(!context) {\n    return;\n  }\n\n  const ctx = context['@context'];\n\n  if(_isString(ctx)) {\n    context['@context'] = prependBase(base, ctx);\n    return;\n  }\n\n  if(_isArray(ctx)) {\n    for(let i = 0; i < ctx.length; ++i) {\n      const element = ctx[i];\n      if(_isString(element)) {\n        ctx[i] = prependBase(base, element);\n        continue;\n      }\n      if(_isObject(element)) {\n        _resolveContextUrls({context: {'@context': element}, base});\n      }\n    }\n    return;\n  }\n\n  if(!_isObject(ctx)) {\n    // no @context URLs can be found in non-object\n    return;\n  }\n\n  // ctx is an object, resolve any context URLs in terms\n  for(const term in ctx) {\n    _resolveContextUrls({context: ctx[term], base});\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/ContextResolver.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/JsonLdError.js":
/*!************************************************!*\
  !*** ./node_modules/jsonld/lib/JsonLdError.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class JsonLdError extends Error {\n  /**\n   * Creates a JSON-LD Error.\n   *\n   * @param msg the error message.\n   * @param type the error type.\n   * @param details the error details.\n   */\n  constructor(\n    message = 'An unspecified JSON-LD error occurred.',\n    name = 'jsonld.Error',\n    details = {}) {\n    super(message);\n    this.name = name;\n    this.message = message;\n    this.details = details;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/JsonLdError.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/JsonLdProcessor.js":
/*!****************************************************!*\
  !*** ./node_modules/jsonld/lib/JsonLdProcessor.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = jsonld => {\n  class JsonLdProcessor {\n    toString() {\n      return '[object JsonLdProcessor]';\n    }\n  }\n  Object.defineProperty(JsonLdProcessor, 'prototype', {\n    writable: false,\n    enumerable: false\n  });\n  Object.defineProperty(JsonLdProcessor.prototype, 'constructor', {\n    writable: true,\n    enumerable: false,\n    configurable: true,\n    value: JsonLdProcessor\n  });\n\n  // The Web IDL test harness will check the number of parameters defined in\n  // the functions below. The number of parameters must exactly match the\n  // required (non-optional) parameters of the JsonLdProcessor interface as\n  // defined here:\n  // https://www.w3.org/TR/json-ld-api/#the-jsonldprocessor-interface\n\n  JsonLdProcessor.compact = function(input, ctx) {\n    if(arguments.length < 2) {\n      return Promise.reject(\n        new TypeError('Could not compact, too few arguments.'));\n    }\n    return jsonld.compact(input, ctx);\n  };\n  JsonLdProcessor.expand = function(input) {\n    if(arguments.length < 1) {\n      return Promise.reject(\n        new TypeError('Could not expand, too few arguments.'));\n    }\n    return jsonld.expand(input);\n  };\n  JsonLdProcessor.flatten = function(input) {\n    if(arguments.length < 1) {\n      return Promise.reject(\n        new TypeError('Could not flatten, too few arguments.'));\n    }\n    return jsonld.flatten(input);\n  };\n\n  return JsonLdProcessor;\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/JsonLdProcessor.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/NQuads.js":
/*!*******************************************!*\
  !*** ./node_modules/jsonld/lib/NQuads.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n// TODO: move `NQuads` to its own package\nmodule.exports = __webpack_require__(/*! rdf-canonize */ \"./node_modules/rdf-canonize/index.js\").NQuads;\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/NQuads.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/RequestQueue.js":
/*!*************************************************!*\
  !*** ./node_modules/jsonld/lib/RequestQueue.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class RequestQueue {\n  /**\n   * Creates a simple queue for requesting documents.\n   */\n  constructor() {\n    this._requests = {};\n  }\n\n  wrapLoader(loader) {\n    const self = this;\n    self._loader = loader;\n    return function(/* url */) {\n      return self.add.apply(self, arguments);\n    };\n  }\n\n  async add(url) {\n    let promise = this._requests[url];\n    if(promise) {\n      // URL already queued, wait for it to load\n      return Promise.resolve(promise);\n    }\n\n    // queue URL and load it\n    promise = this._requests[url] = this._loader(url);\n\n    try {\n      return await promise;\n    } finally {\n      delete this._requests[url];\n    }\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/RequestQueue.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/ResolvedContext.js":
/*!****************************************************!*\
  !*** ./node_modules/jsonld/lib/ResolvedContext.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst LRU = __webpack_require__(/*! lru-cache */ \"./node_modules/lru-cache/index.js\");\n\nconst MAX_ACTIVE_CONTEXTS = 10;\n\nmodule.exports = class ResolvedContext {\n  /**\n   * Creates a ResolvedContext.\n   *\n   * @param document the context document.\n   */\n  constructor({document}) {\n    this.document = document;\n    // TODO: enable customization of processed context cache\n    // TODO: limit based on size of processed contexts vs. number of them\n    this.cache = new LRU({max: MAX_ACTIVE_CONTEXTS});\n  }\n\n  getProcessed(activeCtx) {\n    return this.cache.get(activeCtx);\n  }\n\n  setProcessed(activeCtx, processedCtx) {\n    this.cache.set(activeCtx, processedCtx);\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/ResolvedContext.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/compact.js":
/*!********************************************!*\
  !*** ./node_modules/jsonld/lib/compact.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSimpleGraph: _isSimpleGraph,\n  isSubjectReference: _isSubjectReference\n} = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = __webpack_require__(/*! ./context */ \"./node_modules/jsonld/lib/context.js\");\n\nconst {\n  removeBase: _removeBase,\n  prependBase: _prependBase\n} = __webpack_require__(/*! ./url */ \"./node_modules/jsonld/lib/url.js\");\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return a promise that resolves to the compacted value.\n */\napi.compact = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  compactionMap = () => undefined\n}) => {\n  // recursively compact array\n  if(_isArray(element)) {\n    let rval = [];\n    for(let i = 0; i < element.length; ++i) {\n      // compact, dropping any null values unless custom mapped\n      let compacted = await api.compact({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        compactionMap\n      });\n      if(compacted === null) {\n        compacted = await compactionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options\n        });\n        if(compacted === undefined) {\n          continue;\n        }\n      }\n      rval.push(compacted);\n    }\n    if(options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.length === 0) {\n        rval = rval[0];\n      }\n    }\n    return rval;\n  }\n\n  // use any scoped context on activeProperty\n  const ctx = _getContextValue(activeCtx, activeProperty, '@context');\n  if(!_isUndefined(ctx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: ctx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // recursively compact object\n  if(_isObject(element)) {\n    if(options.link && '@id' in element &&\n      options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      const linked = options.link[element['@id']];\n      for(let i = 0; i < linked.length; ++i) {\n        if(linked[i].expanded === element) {\n          return linked[i].compacted;\n        }\n      }\n    }\n\n    // do value compaction on @values and subject references\n    if(_isValue(element) || _isSubjectReference(element)) {\n      const rval =\n        api.compactValue({activeCtx, activeProperty, value: element, options});\n      if(options.link && _isSubjectReference(element)) {\n        // store linked element\n        if(!(options.link.hasOwnProperty(element['@id']))) {\n          options.link[element['@id']] = [];\n        }\n        options.link[element['@id']].push({expanded: element, compacted: rval});\n      }\n      return rval;\n    }\n\n    // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n    if(_isList(element)) {\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.includes('@list')) {\n        return api.compact({\n          activeCtx,\n          activeProperty,\n          element: element['@list'],\n          options,\n          compactionMap\n        });\n      }\n    }\n\n    // FIXME: avoid misuse of active property as an expanded property?\n    const insideReverse = (activeProperty === '@reverse');\n\n    const rval = {};\n\n    // original context before applying property-scoped and local contexts\n    const inputCtx = activeCtx;\n\n    // revert to previous context, if there is one,\n    // and element is not a value object or a node reference\n    if(!_isValue(element) && !_isSubjectReference(element)) {\n      activeCtx = activeCtx.revertToPreviousContext();\n    }\n\n    // apply property-scoped context after reverting term-scoped context\n    const propertyScopedCtx =\n      _getContextValue(inputCtx, activeProperty, '@context');\n    if(!_isUndefined(propertyScopedCtx)) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx: propertyScopedCtx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    if(options.link && '@id' in element) {\n      // store linked element\n      if(!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n      options.link[element['@id']].push({expanded: element, compacted: rval});\n    }\n\n    // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n    let types = element['@type'] || [];\n    if(types.length > 1) {\n      types = Array.from(types).sort();\n    }\n    // find all type-scoped contexts based on current context, prior to\n    // updating it\n    const typeContext = activeCtx;\n    for(const type of types) {\n      const compactedType = api.compactIri(\n        {activeCtx: typeContext, iri: type, relativeTo: {vocab: true}});\n\n      // Use any type-scoped context defined on this value\n      const ctx = _getContextValue(inputCtx, compactedType, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          options,\n          propagate: false\n        });\n      }\n    }\n\n    // process element keys in order\n    const keys = Object.keys(element).sort();\n    for(const expandedProperty of keys) {\n      const expandedValue = element[expandedProperty];\n\n      // compact @id\n      if(expandedProperty === '@id') {\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: false},\n            base: options.base\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@id', relativeTo: {vocab: true}});\n\n        rval[alias] = compactedValue;\n        continue;\n      }\n\n      // compact @type(s)\n      if(expandedProperty === '@type') {\n        // resolve type values against previous context\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx: inputCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: true}\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@type', relativeTo: {vocab: true}});\n        const container = _getContextValue(\n          activeCtx, alias, '@container') || [];\n\n        // treat as array for @type if @container includes @set\n        const typeAsSet =\n          container.includes('@set') &&\n          _processingMode(activeCtx, 1.1);\n        const isArray =\n          typeAsSet || (_isArray(compactedValue) && expandedValue.length === 0);\n        _addValue(rval, alias, compactedValue, {propertyIsArray: isArray});\n        continue;\n      }\n\n      // handle @reverse\n      if(expandedProperty === '@reverse') {\n        // recursively compact expanded value\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty: '@reverse',\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        // handle double-reversed properties\n        for(const compactedProperty in compactedValue) {\n          if(activeCtx.mappings.has(compactedProperty) &&\n            activeCtx.mappings.get(compactedProperty).reverse) {\n            const value = compactedValue[compactedProperty];\n            const container = _getContextValue(\n              activeCtx, compactedProperty, '@container') || [];\n            const useArray = (\n              container.includes('@set') || !options.compactArrays);\n            _addValue(\n              rval, compactedProperty, value, {propertyIsArray: useArray});\n            delete compactedValue[compactedProperty];\n          }\n        }\n\n        if(Object.keys(compactedValue).length > 0) {\n          // use keyword alias and add value\n          const alias = api.compactIri({\n            activeCtx,\n            iri: expandedProperty,\n            relativeTo: {vocab: true}\n          });\n          _addValue(rval, alias, compactedValue);\n        }\n\n        continue;\n      }\n\n      if(expandedProperty === '@preserve') {\n        // compact using activeProperty\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty,\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        if(!(_isArray(compactedValue) && compactedValue.length === 0)) {\n          _addValue(rval, expandedProperty, compactedValue);\n        }\n        continue;\n      }\n\n      // handle @index property\n      if(expandedProperty === '@index') {\n        // drop @index if inside an @index container\n        const container = _getContextValue(\n          activeCtx, activeProperty, '@container') || [];\n        if(container.includes('@index')) {\n          continue;\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // skip array processing for keywords that aren't\n      // @graph, @list, or @included\n      if(expandedProperty !== '@graph' && expandedProperty !== '@list' &&\n        expandedProperty !== '@included' &&\n        _isKeyword(expandedProperty)) {\n        // use keyword alias and add value as is\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // Note: expanded value must be an array due to expansion algorithm.\n      if(!_isArray(expandedValue)) {\n        throw new JsonLdError(\n          'JSON-LD expansion error; expanded value must be an array.',\n          'jsonld.SyntaxError');\n      }\n\n      // preserve empty arrays\n      if(expandedValue.length === 0) {\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedValue,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n        _addValue(\n          nestResult, itemActiveProperty, expandedValue, {\n            propertyIsArray: true\n          });\n      }\n\n      // recusively process array values\n      for(const expandedItem of expandedValue) {\n        // compact property and get container type\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedItem,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n\n        // if itemActiveProperty is a @nest property, add values to nestResult,\n        // otherwise rval\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n\n        const container = _getContextValue(\n          activeCtx, itemActiveProperty, '@container') || [];\n\n        // get simple @graph or @list value if appropriate\n        const isGraph = _isGraph(expandedItem);\n        const isList = _isList(expandedItem);\n        let inner;\n        if(isList) {\n          inner = expandedItem['@list'];\n        } else if(isGraph) {\n          inner = expandedItem['@graph'];\n        }\n\n        // recursively compact expanded item\n        let compactedItem = await api.compact({\n          activeCtx,\n          activeProperty: itemActiveProperty,\n          element: (isList || isGraph) ? inner : expandedItem,\n          options,\n          compactionMap\n        });\n\n        // handle @list\n        if(isList) {\n          // ensure @list value is an array\n          if(!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n\n          if(!container.includes('@list')) {\n            // wrap using @list alias\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@list',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @index from expanded @list, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n          } else {\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              valueIsArray: true,\n              allowDuplicate: true\n            });\n            continue;\n          }\n        }\n\n        // Graph object compaction cases\n        if(isGraph) {\n          if(container.includes('@graph') && (container.includes('@id') ||\n            container.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            let mapObject;\n            if(nestResult.hasOwnProperty(itemActiveProperty)) {\n              mapObject = nestResult[itemActiveProperty];\n            } else {\n              nestResult[itemActiveProperty] = mapObject = {};\n            }\n\n            // index on @id or @index or alias of @none\n            const key = (container.includes('@id') ?\n              expandedItem['@id'] : expandedItem['@index']) ||\n              api.compactIri({activeCtx, iri: '@none',\n                relativeTo: {vocab: true}});\n            // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n\n            _addValue(\n              mapObject, key, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else if(container.includes('@graph') &&\n            _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            // if compactedItem contains multiple values, it is wrapped in\n            // `@included`\n            if(_isArray(compactedItem) && compactedItem.length > 1) {\n              compactedItem = {'@included': compactedItem};\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if(_isArray(compactedItem) && compactedItem.length === 1 &&\n              options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@graph',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @id from expanded graph, if any\n            if('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@id',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@id'];\n            }\n\n            // include @index from expanded graph, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          }\n        } else if(container.includes('@language') ||\n          container.includes('@index') || container.includes('@id') ||\n          container.includes('@type')) {\n          // handle language and index maps\n          // get or create the map object\n          let mapObject;\n          if(nestResult.hasOwnProperty(itemActiveProperty)) {\n            mapObject = nestResult[itemActiveProperty];\n          } else {\n            nestResult[itemActiveProperty] = mapObject = {};\n          }\n\n          let key;\n          if(container.includes('@language')) {\n          // if container is a language map, simplify compacted value to\n          // a simple string\n            if(_isValue(compactedItem)) {\n              compactedItem = compactedItem['@value'];\n            }\n            key = expandedItem['@language'];\n          } else if(container.includes('@index')) {\n            const indexKey = _getContextValue(\n              activeCtx, itemActiveProperty, '@index') || '@index';\n            const containerKey = api.compactIri(\n              {activeCtx, iri: indexKey, relativeTo: {vocab: true}});\n            if(indexKey === '@index') {\n              key = expandedItem['@index'];\n              delete compactedItem[containerKey];\n            } else {\n              let others;\n              [key, ...others] = _asArray(compactedItem[indexKey] || []);\n              if(!_isString(key)) {\n                // Will use @none if it isn't a string.\n                key = null;\n              } else {\n                switch(others.length) {\n                  case 0:\n                    delete compactedItem[indexKey];\n                    break;\n                  case 1:\n                    compactedItem[indexKey] = others[0];\n                    break;\n                  default:\n                    compactedItem[indexKey] = others;\n                    break;\n                }\n              }\n            }\n          } else if(container.includes('@id')) {\n            const idKey = api.compactIri({activeCtx, iri: '@id',\n              relativeTo: {vocab: true}});\n            key = compactedItem[idKey];\n            delete compactedItem[idKey];\n          } else if(container.includes('@type')) {\n            const typeKey = api.compactIri({\n              activeCtx,\n              iri: '@type',\n              relativeTo: {vocab: true}\n            });\n            let types;\n            [key, ...types] = _asArray(compactedItem[typeKey] || []);\n            switch(types.length) {\n              case 0:\n                delete compactedItem[typeKey];\n                break;\n              case 1:\n                compactedItem[typeKey] = types[0];\n                break;\n              default:\n                compactedItem[typeKey] = types;\n                break;\n            }\n\n            // If compactedItem contains a single entry\n            // whose key maps to @id, recompact without @type\n            if(Object.keys(compactedItem).length === 1 &&\n              '@id' in expandedItem) {\n              compactedItem = await api.compact({\n                activeCtx,\n                activeProperty: itemActiveProperty,\n                element: {'@id': expandedItem['@id']},\n                options,\n                compactionMap\n              });\n            }\n          }\n\n          // if compacting this value which has no key, index on @none\n          if(!key) {\n            key = api.compactIri({activeCtx, iri: '@none',\n              relativeTo: {vocab: true}});\n          }\n          // add compact value to map object using key from expanded value\n          // based on the container type\n          _addValue(\n            mapObject, key, compactedItem, {\n              propertyIsArray: container.includes('@set')\n            });\n        } else {\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          const isArray = (!options.compactArrays ||\n            container.includes('@set') || container.includes('@list') ||\n            (_isArray(compactedItem) && compactedItem.length === 0) ||\n            expandedProperty === '@list' || expandedProperty === '@graph');\n\n          // add compact value\n          _addValue(\n            nestResult, itemActiveProperty, compactedItem,\n            {propertyIsArray: isArray});\n        }\n      }\n    }\n\n    return rval;\n  }\n\n  // only primitives remain which are already compact\n  return element;\n};\n\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n * @param base the absolute URL to use for compacting document-relative IRIs.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\napi.compactIri = ({\n  activeCtx,\n  iri,\n  value = null,\n  relativeTo = {vocab: false},\n  reverse = false,\n  base = null\n}) => {\n  // can't compact null\n  if(iri === null) {\n    return iri;\n  }\n\n  // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n  if(activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  const inverseCtx = activeCtx.getInverse();\n\n  // if term is a keyword, it may be compacted to a simple alias\n  if(_isKeyword(iri) &&\n    iri in inverseCtx &&\n    '@none' in inverseCtx[iri] &&\n    '@type' in inverseCtx[iri]['@none'] &&\n    '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  }\n\n  // use inverse context to pick a term if iri is relative to vocab\n  if(relativeTo.vocab && iri in inverseCtx) {\n    const defaultLanguage = activeCtx['@language'] || '@none';\n\n    // prefer @index if available in value\n    const containers = [];\n    if(_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    }\n\n    // if value is a preserve object, use its value\n    if(_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    }\n\n    // prefer most specific container including @graph, prefering @set\n    // variations\n    if(_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if('@index' in value) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // favor idmap if the graph is has an @id\n      if('@id' in value) {\n        containers.push(\n          '@graph@id', '@graph@id@set');\n      }\n      containers.push('@graph', '@graph@set', '@set');\n      // allow indexmap if the graph is not indexed\n      if(!('@index' in value)) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // allow idmap if the graph does not have an @id\n      if(!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if(_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    }\n\n    // defaults for term selection based on type/language\n    let typeOrLanguage = '@language';\n    let typeOrLanguageValue = '@null';\n\n    if(reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if(_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if(!('@index' in value)) {\n        containers.push('@list');\n      }\n      const list = value['@list'];\n      if(list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        let commonLanguage = (list.length === 0) ? defaultLanguage : null;\n        let commonType = null;\n        for(let i = 0; i < list.length; ++i) {\n          const item = list[i];\n          let itemLanguage = '@none';\n          let itemType = '@none';\n          if(_isValue(item)) {\n            if('@direction' in item) {\n              const lang = (item['@language'] || '').toLowerCase();\n              const dir = item['@direction'];\n              itemLanguage = `${lang}_${dir}`;\n            } else if('@language' in item) {\n              itemLanguage = item['@language'].toLowerCase();\n            } else if('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n          if(commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if(itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n          if(commonType === null) {\n            commonType = itemType;\n          } else if(itemType !== commonType) {\n            commonType = '@none';\n          }\n          // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n          if(commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n        if(commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if(_isValue(value)) {\n        if('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n          const dir = value['@direction'];\n          if(dir) {\n            typeOrLanguageValue = `${typeOrLanguageValue}_${dir}`;\n          }\n        } else if('@direction' in value && !('@index' in value)) {\n          typeOrLanguageValue = `_${value['@direction']}`;\n        } else if('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n      containers.push('@set');\n    }\n\n    // do term selection\n    containers.push('@none');\n\n    // an index map can be used to index values using @none, so add as a low\n    // priority\n    if(_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    }\n\n    // values without type or language can use @language map\n    if(_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    const term = _selectTerm(\n      activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n    if(term !== null) {\n      return term;\n    }\n  }\n\n  // no term match, use @vocab if available\n  if(relativeTo.vocab) {\n    if('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      const vocab = activeCtx['@vocab'];\n      if(iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        const suffix = iri.substr(vocab.length);\n        if(!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  }\n\n  // no term or @vocab match, check for possible CURIEs\n  let choice = null;\n  // TODO: make FastCurieMap a class with a method to do this lookup\n  const partialMatches = [];\n  let iriMap = activeCtx.fastCurieMap;\n  // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n  const maxPartialLength = iri.length - 1;\n  for(let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {\n    iriMap = iriMap[iri[i]];\n    if('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  }\n  // check partial matches in reverse order to prefer longest ones first\n  for(let i = partialMatches.length - 1; i >= 0; --i) {\n    const entry = partialMatches[i];\n    const terms = entry.terms;\n    for(const term of terms) {\n      // a CURIE is usable if:\n      // 1. it has no mapping, OR\n      // 2. value is null, which means we're not compacting an @value, AND\n      //   the mapping matches the IRI\n      const curie = term + ':' + iri.substr(entry.iri.length);\n      const isUsableCurie = (activeCtx.mappings.get(term)._prefix &&\n        (!activeCtx.mappings.has(curie) ||\n        (value === null && activeCtx.mappings.get(curie)['@id'] === iri)));\n\n      // select curie if it is shorter or the same length but lexicographically\n      // less than the current choice\n      if(isUsableCurie && (choice === null ||\n        _compareShortestLeast(curie, choice) < 0)) {\n        choice = curie;\n      }\n    }\n  }\n\n  // return chosen curie\n  if(choice !== null) {\n    return choice;\n  }\n\n  // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n  for(const [term, td] of activeCtx.mappings) {\n    if(td && td._prefix && iri.startsWith(term + ':')) {\n      throw new JsonLdError(\n        `Absolute IRI \"${iri}\" confused with prefix \"${term}\".`,\n        'jsonld.SyntaxError',\n        {code: 'IRI confused with prefix', context: activeCtx});\n    }\n  }\n\n  // compact IRI relative to base\n  if(!relativeTo.vocab) {\n    if('@base' in activeCtx) {\n      if(!activeCtx['@base']) {\n        // The None case preserves rval as potentially relative\n        return iri;\n      } else {\n        return _removeBase(_prependBase(base, activeCtx['@base']), iri);\n      }\n    } else {\n      return _removeBase(base, iri);\n    }\n  }\n\n  // return IRI as is\n  return iri;\n};\n\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\napi.compactValue = ({activeCtx, activeProperty, value, options}) => {\n  // value is a @value\n  if(_isValue(value)) {\n    // get context rules\n    const type = _getContextValue(activeCtx, activeProperty, '@type');\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    const container =\n      _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n    // whether or not the value has an @index that must be preserved\n    const preserveIndex = '@index' in value && !container.includes('@index');\n\n    // if there's no @index to preserve ...\n    if(!preserveIndex && type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if(value['@type'] === type) {\n        return value['@value'];\n      }\n      if('@language' in value && value['@language'] === language &&\n         '@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n      if('@language' in value && value['@language'] === language) {\n        return value['@value'];\n      }\n      if('@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n    }\n\n    // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n    const keyCount = Object.keys(value).length;\n    const isValueOnlyKey = (keyCount === 1 ||\n      (keyCount === 2 && '@index' in value && !preserveIndex));\n    const hasDefaultLanguage = ('@language' in activeCtx);\n    const isValueString = _isString(value['@value']);\n    const hasNullMapping = (activeCtx.mappings.has(activeProperty) &&\n      activeCtx.mappings.get(activeProperty)['@language'] === null);\n    if(isValueOnlyKey &&\n      type !== '@none' &&\n      (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    const rval = {};\n\n    // preserve @index\n    if(preserveIndex) {\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@index',\n        relativeTo: {vocab: true}\n      })] = value['@index'];\n    }\n\n    if('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@type',\n        relativeTo: {vocab: true}\n      })] = api.compactIri(\n        {activeCtx, iri: value['@type'], relativeTo: {vocab: true}});\n    } else if('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@language',\n        relativeTo: {vocab: true}\n      })] = value['@language'];\n    }\n\n    if('@direction' in value) {\n      // alias @direction\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@direction',\n        relativeTo: {vocab: true}\n      })] = value['@direction'];\n    }\n\n    // alias @value\n    rval[api.compactIri({\n      activeCtx,\n      iri: '@value',\n      relativeTo: {vocab: true}\n    })] = value['@value'];\n\n    return rval;\n  }\n\n  // value is a subject reference\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {vocab: true},\n    options);\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n  const compacted = api.compactIri({\n    activeCtx,\n    iri: value['@id'],\n    relativeTo: {vocab: type === '@vocab'},\n    base: options.base});\n\n  // compact to scalar\n  if(type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return {\n    [api.compactIri({\n      activeCtx,\n      iri: '@id',\n      relativeTo: {vocab: true}\n    })]: compacted\n  };\n};\n\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\nfunction _selectTerm(\n  activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if(typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  }\n\n  // preferences for the value of @type or @language\n  const prefs = [];\n\n  // determine prefs for @id based on whether or not value compacts to a term\n  if((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') &&\n    _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if(typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    }\n    // try to compact value to a term\n    const term = api.compactIri(\n      {activeCtx, iri: value['@id'], relativeTo: {vocab: true}});\n    if(activeCtx.mappings.has(term) &&\n      activeCtx.mappings.get(term) &&\n      activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n\n    // consider direction only\n    const langDir = prefs.find(el => el.includes('_'));\n    if(langDir) {\n      // consider _dir portion\n      prefs.push(langDir.replace(/^[^_]+_/, '_'));\n    }\n  }\n  prefs.push('@none');\n\n  const containerMap = activeCtx.inverse[iri];\n  for(const container of containers) {\n    // if container not available in the map, continue\n    if(!(container in containerMap)) {\n      continue;\n    }\n\n    const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n    for(const pref of prefs) {\n      // if type/language option not available in the map, continue\n      if(!(pref in typeOrLanguageValueMap)) {\n        continue;\n      }\n\n      // select term\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if(_expandIri(activeCtx, nestProperty, {vocab: true}, options) !== '@nest') {\n    throw new JsonLdError(\n      'JSON-LD compact error; nested property must have an @nest value ' +\n      'resolving to @nest.',\n      'jsonld.SyntaxError', {code: 'invalid @nest value'});\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/compact.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/constants.js":
/*!**********************************************!*\
  !*** ./node_modules/jsonld/lib/constants.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nconst XSD = 'http://www.w3.org/2001/XMLSchema#';\n\nmodule.exports = {\n  // TODO: Deprecated and will be removed later. Use LINK_HEADER_CONTEXT.\n  LINK_HEADER_REL: 'http://www.w3.org/ns/json-ld#context',\n\n  LINK_HEADER_CONTEXT: 'http://www.w3.org/ns/json-ld#context',\n\n  RDF,\n  RDF_LIST: RDF + 'List',\n  RDF_FIRST: RDF + 'first',\n  RDF_REST: RDF + 'rest',\n  RDF_NIL: RDF + 'nil',\n  RDF_TYPE: RDF + 'type',\n  RDF_PLAIN_LITERAL: RDF + 'PlainLiteral',\n  RDF_XML_LITERAL: RDF + 'XMLLiteral',\n  RDF_JSON_LITERAL: RDF + 'JSON',\n  RDF_OBJECT: RDF + 'object',\n  RDF_LANGSTRING: RDF + 'langString',\n\n  XSD,\n  XSD_BOOLEAN: XSD + 'boolean',\n  XSD_DOUBLE: XSD + 'double',\n  XSD_INTEGER: XSD + 'integer',\n  XSD_STRING: XSD + 'string',\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/constants.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/context.js":
/*!********************************************!*\
  !*** ./node_modules/jsonld/lib/context.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n\nconst {\n  isAbsolute: _isAbsoluteIri,\n  isRelative: _isRelativeIri,\n  prependBase\n} = __webpack_require__(/*! ./url */ \"./node_modules/jsonld/lib/url.js\");\n\nconst {\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\n\nconst INITIAL_CONTEXT_CACHE = new Map();\nconst INITIAL_CONTEXT_CACHE_MAX_SIZE = 10000;\nconst KEYWORD_PATTERN = /^@[a-zA-Z]+$/;\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Processes a local context and returns a new active context.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param options the context processing options.\n * @param propagate `true` if `false`, retains any previously defined term,\n *   which can be rolled back when the descending into a new node object.\n * @param overrideProtected `false` allows protected terms to be modified.\n *\n * @return a Promise that resolves to the new active context.\n */\napi.process = async ({\n  activeCtx, localCtx, options,\n  propagate = true,\n  overrideProtected = false,\n  cycles = new Set()\n}) => {\n  // normalize local context to an array of @context objects\n  if(_isObject(localCtx) && '@context' in localCtx &&\n    _isArray(localCtx['@context'])) {\n    localCtx = localCtx['@context'];\n  }\n  const ctxs = _asArray(localCtx);\n\n  // no contexts in array, return current active context w/o changes\n  if(ctxs.length === 0) {\n    return activeCtx;\n  }\n\n  // resolve contexts\n  const resolved = await options.contextResolver.resolve({\n    activeCtx,\n    context: localCtx,\n    documentLoader: options.documentLoader,\n    base: options.base\n  });\n\n  // override propagate if first resolved context has `@propagate`\n  if(_isObject(resolved[0].document) &&\n    typeof resolved[0].document['@propagate'] === 'boolean') {\n    // retrieve early, error checking done later\n    propagate = resolved[0].document['@propagate'];\n  }\n\n  // process each context in order, update active context\n  // on each iteration to ensure proper caching\n  let rval = activeCtx;\n\n  // track the previous context\n  // if not propagating, make sure rval has a previous context\n  if(!propagate && !rval.previousContext) {\n    // clone `rval` context before updating\n    rval = rval.clone();\n    rval.previousContext = activeCtx;\n  }\n\n  for(const resolvedContext of resolved) {\n    let {document: ctx} = resolvedContext;\n\n    // update active context to one computed from last iteration\n    activeCtx = rval;\n\n    // reset to initial context\n    if(ctx === null) {\n      // We can't nullify if there are protected terms and we're\n      // not allowing overrides (e.g. processing a property term scoped context)\n      if(!overrideProtected &&\n        Object.keys(activeCtx.protected).length !== 0) {\n        const protectedMode = (options && options.protectedMode) || 'error';\n        if(protectedMode === 'error') {\n          throw new JsonLdError(\n            'Tried to nullify a context with protected terms outside of ' +\n            'a term definition.',\n            'jsonld.SyntaxError',\n            {code: 'invalid context nullification'});\n        } else if(protectedMode === 'warn') {\n          // FIXME: remove logging and use a handler\n          console.warn('WARNING: invalid context nullification');\n\n          // get processed context from cache if available\n          const processed = resolvedContext.getProcessed(activeCtx);\n          if(processed) {\n            rval = activeCtx = processed;\n            continue;\n          }\n\n          const oldActiveCtx = activeCtx;\n          // copy all protected term definitions to fresh initial context\n          rval = activeCtx = api.getInitialContext(options).clone();\n          for(const [term, _protected] of\n            Object.entries(oldActiveCtx.protected)) {\n            if(_protected) {\n              activeCtx.mappings[term] =\n                util.clone(oldActiveCtx.mappings[term]);\n            }\n          }\n          activeCtx.protected = util.clone(oldActiveCtx.protected);\n\n          // cache processed result\n          resolvedContext.setProcessed(oldActiveCtx, rval);\n          continue;\n        }\n        throw new JsonLdError(\n          'Invalid protectedMode.',\n          'jsonld.SyntaxError',\n          {code: 'invalid protected mode', context: localCtx, protectedMode});\n      }\n      rval = activeCtx = api.getInitialContext(options).clone();\n      continue;\n    }\n\n    // get processed context from cache if available\n    const processed = resolvedContext.getProcessed(activeCtx);\n    if(processed) {\n      rval = activeCtx = processed;\n      continue;\n    }\n\n    // dereference @context key if present\n    if(_isObject(ctx) && '@context' in ctx) {\n      ctx = ctx['@context'];\n    }\n\n    // context must be an object by now, all URLs retrieved before this call\n    if(!_isObject(ctx)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context must be an object.',\n        'jsonld.SyntaxError', {code: 'invalid local context', context: ctx});\n    }\n\n    // TODO: there is likely a `previousContext` cloning optimization that\n    // could be applied here (no need to copy it under certain conditions)\n\n    // clone context before updating it\n    rval = rval.clone();\n\n    // define context mappings for keys in local context\n    const defined = new Map();\n\n    // handle @version\n    if('@version' in ctx) {\n      if(ctx['@version'] !== 1.1) {\n        throw new JsonLdError(\n          'Unsupported JSON-LD version: ' + ctx['@version'],\n          'jsonld.UnsupportedVersion',\n          {code: 'invalid @version value', context: ctx});\n      }\n      if(activeCtx.processingMode &&\n        activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          '@version: ' + ctx['@version'] + ' not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.ProcessingModeConflict',\n          {code: 'processing mode conflict', context: ctx});\n      }\n      rval.processingMode = 'json-ld-1.1';\n      rval['@version'] = ctx['@version'];\n      defined.set('@version', true);\n    }\n\n    // if not set explicitly, set processingMode to \"json-ld-1.1\"\n    rval.processingMode =\n      rval.processingMode || activeCtx.processingMode;\n\n    // handle @base\n    if('@base' in ctx) {\n      let base = ctx['@base'];\n\n      if(base === null || _isAbsoluteIri(base)) {\n        // no action\n      } else if(_isRelativeIri(base)) {\n        base = prependBase(rval['@base'], base);\n      } else {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@base\" in a ' +\n          '@context must be an absolute IRI, a relative IRI, or null.',\n          'jsonld.SyntaxError', {code: 'invalid base IRI', context: ctx});\n      }\n\n      rval['@base'] = base;\n      defined.set('@base', true);\n    }\n\n    // handle @vocab\n    if('@vocab' in ctx) {\n      const value = ctx['@vocab'];\n      if(value === null) {\n        delete rval['@vocab'];\n      } else if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@vocab\" in a ' +\n          '@context must be a string or null.',\n          'jsonld.SyntaxError', {code: 'invalid vocab mapping', context: ctx});\n      } else if(!_isAbsoluteIri(value) && api.processingMode(rval, 1.0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@vocab\" in a ' +\n          '@context must be an absolute IRI.',\n          'jsonld.SyntaxError', {code: 'invalid vocab mapping', context: ctx});\n      } else {\n        rval['@vocab'] = _expandIri(rval, value, {vocab: true, base: true},\n          undefined, undefined, options);\n      }\n      defined.set('@vocab', true);\n    }\n\n    // handle @language\n    if('@language' in ctx) {\n      const value = ctx['@language'];\n      if(value === null) {\n        delete rval['@language'];\n      } else if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@language\" in a ' +\n          '@context must be a string or null.',\n          'jsonld.SyntaxError',\n          {code: 'invalid default language', context: ctx});\n      } else {\n        rval['@language'] = value.toLowerCase();\n      }\n      defined.set('@language', true);\n    }\n\n    // handle @direction\n    if('@direction' in ctx) {\n      const value = ctx['@direction'];\n      if(activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @direction not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.SyntaxError',\n          {code: 'invalid context member', context: ctx});\n      }\n      if(value === null) {\n        delete rval['@direction'];\n      } else if(value !== 'ltr' && value !== 'rtl') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@direction\" in a ' +\n          '@context must be null, \"ltr\", or \"rtl\".',\n          'jsonld.SyntaxError',\n          {code: 'invalid base direction', context: ctx});\n      } else {\n        rval['@direction'] = value;\n      }\n      defined.set('@direction', true);\n    }\n\n    // handle @propagate\n    // note: we've already extracted it, here we just do error checking\n    if('@propagate' in ctx) {\n      const value = ctx['@propagate'];\n      if(activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @propagate not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.SyntaxError',\n          {code: 'invalid context entry', context: ctx});\n      }\n      if(typeof value !== 'boolean') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @propagate value must be a boolean.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @propagate value', context: localCtx});\n      }\n      defined.set('@propagate', true);\n    }\n\n    // handle @import\n    if('@import' in ctx) {\n      const value = ctx['@import'];\n      if(activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @import not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.SyntaxError',\n          {code: 'invalid context entry', context: ctx});\n      }\n      if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @import must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @import value', context: localCtx});\n      }\n\n      // resolve contexts\n      const resolvedImport = await options.contextResolver.resolve({\n        activeCtx,\n        context: value,\n        documentLoader: options.documentLoader,\n        base: options.base\n      });\n      if(resolvedImport.length !== 1) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @import must reference a single context.',\n          'jsonld.SyntaxError',\n          {code: 'invalid remote context', context: localCtx});\n      }\n      const processedImport = resolvedImport[0].getProcessed(activeCtx);\n      if(processedImport) {\n        // Note: if the same context were used in this active context\n        // as a reference context, then processed_input might not\n        // be a dict.\n        ctx = processedImport;\n      } else {\n        const importCtx = resolvedImport[0].document;\n        if('@import' in importCtx) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax: ' +\n            'imported context must not include @import.',\n            'jsonld.SyntaxError',\n            {code: 'invalid context entry', context: localCtx});\n        }\n\n        // merge ctx into importCtx and replace rval with the result\n        for(const key in importCtx) {\n          if(!ctx.hasOwnProperty(key)) {\n            ctx[key] = importCtx[key];\n          }\n        }\n\n        // Note: this could potenially conflict if the import\n        // were used in the same active context as a referenced\n        // context and an import. In this case, we\n        // could override the cached result, but seems unlikely.\n        resolvedImport[0].setProcessed(activeCtx, ctx);\n      }\n\n      defined.set('@import', true);\n    }\n\n    // handle @protected; determine whether this sub-context is declaring\n    // all its terms to be \"protected\" (exceptions can be made on a\n    // per-definition basis)\n    defined.set('@protected', ctx['@protected'] || false);\n\n    // process all other keys\n    for(const key in ctx) {\n      api.createTermDefinition({\n        activeCtx: rval,\n        localCtx: ctx,\n        term: key,\n        defined,\n        options,\n        overrideProtected\n      });\n\n      if(_isObject(ctx[key]) && '@context' in ctx[key]) {\n        const keyCtx = ctx[key]['@context'];\n        let process = true;\n        if(_isString(keyCtx)) {\n          const url = prependBase(options.base, keyCtx);\n          // track processed contexts to avoid scoped context recursion\n          if(cycles.has(url)) {\n            process = false;\n          } else {\n            cycles.add(url);\n          }\n        }\n        // parse context to validate\n        if(process) {\n          try {\n            await api.process({\n              activeCtx: rval.clone(),\n              localCtx: ctx[key]['@context'],\n              overrideProtected: true,\n              options,\n              cycles\n            });\n          } catch(e) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; invalid scoped context.',\n              'jsonld.SyntaxError',\n              {\n                code: 'invalid scoped context',\n                context: ctx[key]['@context'],\n                term: key\n              });\n          }\n        }\n      }\n    }\n\n    // cache processed result\n    resolvedContext.setProcessed(activeCtx, rval);\n  }\n\n  return rval;\n};\n\n/**\n * Creates a term definition during context processing.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context being processed.\n * @param term the term in the local context to define the mapping for.\n * @param defined a map of defining/defined keys to detect cycles and prevent\n *          double definitions.\n * @param {Object} [options] - creation options.\n * @param {string} [options.protectedMode=\"error\"] - \"error\" to throw error\n *   on `@protected` constraint violation, \"warn\" to allow violations and\n *   signal a warning.\n * @param overrideProtected `false` allows protected terms to be modified.\n */\napi.createTermDefinition = ({\n  activeCtx,\n  localCtx,\n  term,\n  defined,\n  options,\n  overrideProtected = false,\n}) => {\n  if(defined.has(term)) {\n    // term already defined\n    if(defined.get(term)) {\n      return;\n    }\n    // cycle detected\n    throw new JsonLdError(\n      'Cyclical context definition detected.',\n      'jsonld.CyclicalContext',\n      {code: 'cyclic IRI mapping', context: localCtx, term});\n  }\n\n  // now defining term\n  defined.set(term, false);\n\n  // get context term value\n  let value;\n  if(localCtx.hasOwnProperty(term)) {\n    value = localCtx[term];\n  }\n\n  if(term === '@type' &&\n     _isObject(value) &&\n     (value['@container'] || '@set') === '@set' &&\n     api.processingMode(activeCtx, 1.1)) {\n\n    const validKeys = ['@container', '@id', '@protected'];\n    const keys = Object.keys(value);\n    if(keys.length === 0 || keys.some(k => !validKeys.includes(k))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; keywords cannot be overridden.',\n        'jsonld.SyntaxError',\n        {code: 'keyword redefinition', context: localCtx, term});\n    }\n  } else if(api.isKeyword(term)) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; keywords cannot be overridden.',\n      'jsonld.SyntaxError',\n      {code: 'keyword redefinition', context: localCtx, term});\n  } else if(term.match(KEYWORD_PATTERN)) {\n    // FIXME: remove logging and use a handler\n    console.warn('WARNING: terms beginning with \"@\" are reserved' +\n      ' for future use and ignored', {term});\n    return;\n  } else if(term === '') {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; a term cannot be an empty string.',\n      'jsonld.SyntaxError',\n      {code: 'invalid term definition', context: localCtx});\n  }\n\n  // keep reference to previous mapping for potential `@protected` check\n  const previousMapping = activeCtx.mappings.get(term);\n\n  // remove old mapping\n  if(activeCtx.mappings.has(term)) {\n    activeCtx.mappings.delete(term);\n  }\n\n  // convert short-hand value to object w/@id\n  let simpleTerm = false;\n  if(_isString(value) || value === null) {\n    simpleTerm = true;\n    value = {'@id': value};\n  }\n\n  if(!_isObject(value)) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; @context term values must be ' +\n      'strings or objects.',\n      'jsonld.SyntaxError',\n      {code: 'invalid term definition', context: localCtx});\n  }\n\n  // create new mapping\n  const mapping = {};\n  activeCtx.mappings.set(term, mapping);\n  mapping.reverse = false;\n\n  // make sure term definition only has expected keywords\n  const validKeys = ['@container', '@id', '@language', '@reverse', '@type'];\n\n  // JSON-LD 1.1 support\n  if(api.processingMode(activeCtx, 1.1)) {\n    validKeys.push(\n      '@context', '@direction', '@index', '@nest', '@prefix', '@protected');\n  }\n\n  for(const kw in value) {\n    if(!validKeys.includes(kw)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a term definition must not contain ' + kw,\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n  }\n\n  // always compute whether term has a colon as an optimization for\n  // _compactIri\n  const colon = term.indexOf(':');\n  mapping._termHasColon = (colon > 0);\n\n  if('@reverse' in value) {\n    if('@id' in value) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @reverse term definition must not ' +\n        'contain @id.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n    if('@nest' in value) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @reverse term definition must not ' +\n        'contain @nest.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n    const reverse = value['@reverse'];\n    if(!_isString(reverse)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @reverse value must be a string.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n\n    if(!api.isKeyword(reverse) && reverse.match(KEYWORD_PATTERN)) {\n      // FIXME: remove logging and use a handler\n      console.warn('WARNING: values beginning with \"@\" are reserved' +\n        ' for future use and ignored', {reverse});\n      if(previousMapping) {\n        activeCtx.mappings.set(term, previousMapping);\n      } else {\n        activeCtx.mappings.delete(term);\n      }\n      return;\n    }\n\n    // expand and add @id mapping\n    const id = _expandIri(\n      activeCtx, reverse, {vocab: true, base: false}, localCtx, defined,\n      options);\n    if(!_isAbsoluteIri(id)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @reverse value must be an ' +\n        'absolute IRI or a blank node identifier.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n\n    mapping['@id'] = id;\n    mapping.reverse = true;\n  } else if('@id' in value) {\n    let id = value['@id'];\n    if(id && !_isString(id)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @id value must be an array ' +\n        'of strings or a string.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n    if(id === null) {\n      // reserve a null term, which may be protected\n      mapping['@id'] = null;\n    } else if(!api.isKeyword(id) && id.match(KEYWORD_PATTERN)) {\n      // FIXME: remove logging and use a handler\n      console.warn('WARNING: values beginning with \"@\" are reserved' +\n        ' for future use and ignored', {id});\n      if(previousMapping) {\n        activeCtx.mappings.set(term, previousMapping);\n      } else {\n        activeCtx.mappings.delete(term);\n      }\n      return;\n    } else if(id !== term) {\n      // expand and add @id mapping\n      id = _expandIri(\n        activeCtx, id, {vocab: true, base: false}, localCtx, defined, options);\n      if(!_isAbsoluteIri(id) && !api.isKeyword(id)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; a @context @id value must be an ' +\n          'absolute IRI, a blank node identifier, or a keyword.',\n          'jsonld.SyntaxError',\n          {code: 'invalid IRI mapping', context: localCtx});\n      }\n\n      // if term has the form of an IRI it must map the same\n      if(term.match(/(?::[^:])|\\//)) {\n        const termDefined = new Map(defined).set(term, true);\n        const termIri = _expandIri(\n          activeCtx, term, {vocab: true, base: false},\n          localCtx, termDefined, options);\n        if(termIri !== id) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; term in form of IRI must ' +\n            'expand to definition.',\n            'jsonld.SyntaxError',\n            {code: 'invalid IRI mapping', context: localCtx});\n        }\n      }\n\n      mapping['@id'] = id;\n      // indicate if this term may be used as a compact IRI prefix\n      mapping._prefix = (simpleTerm &&\n        !mapping._termHasColon &&\n        id.match(/[:\\/\\?#\\[\\]@]$/));\n    }\n  }\n\n  if(!('@id' in mapping)) {\n    // see if the term has a prefix\n    if(mapping._termHasColon) {\n      const prefix = term.substr(0, colon);\n      if(localCtx.hasOwnProperty(prefix)) {\n        // define parent prefix\n        api.createTermDefinition({\n          activeCtx, localCtx, term: prefix, defined, options\n        });\n      }\n\n      if(activeCtx.mappings.has(prefix)) {\n        // set @id based on prefix parent\n        const suffix = term.substr(colon + 1);\n        mapping['@id'] = activeCtx.mappings.get(prefix)['@id'] + suffix;\n      } else {\n        // term is an absolute IRI\n        mapping['@id'] = term;\n      }\n    } else if(term === '@type') {\n      // Special case, were we've previously determined that container is @set\n      mapping['@id'] = term;\n    } else {\n      // non-IRIs *must* define @ids if @vocab is not available\n      if(!('@vocab' in activeCtx)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @context terms must define an @id.',\n          'jsonld.SyntaxError',\n          {code: 'invalid IRI mapping', context: localCtx, term});\n      }\n      // prepend vocab to term\n      mapping['@id'] = activeCtx['@vocab'] + term;\n    }\n  }\n\n  // Handle term protection\n  if(value['@protected'] === true ||\n    (defined.get('@protected') === true && value['@protected'] !== false)) {\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n  }\n\n  // IRI mapping now defined\n  defined.set(term, true);\n\n  if('@type' in value) {\n    let type = value['@type'];\n    if(!_isString(type)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an @context @type value must be a string.',\n        'jsonld.SyntaxError',\n        {code: 'invalid type mapping', context: localCtx});\n    }\n\n    if((type === '@json' || type === '@none')) {\n      if(api.processingMode(activeCtx, 1.0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must not be ' +\n          `\"${type}\" in JSON-LD 1.0 mode.`,\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n    } else if(type !== '@id' && type !== '@vocab') {\n      // expand @type to full IRI\n      type = _expandIri(\n        activeCtx, type, {vocab: true, base: false}, localCtx, defined,\n        options);\n      if(!_isAbsoluteIri(type)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must be an ' +\n          'absolute IRI.',\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n      if(type.indexOf('_:') === 0) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must be an IRI, ' +\n          'not a blank node identifier.',\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n    }\n\n    // add @type to mapping\n    mapping['@type'] = type;\n  }\n\n  if('@container' in value) {\n    // normalize container to an array form\n    const container = _isString(value['@container']) ?\n      [value['@container']] : (value['@container'] || []);\n    const validContainers = ['@list', '@set', '@index', '@language'];\n    let isValid = true;\n    const hasSet = container.includes('@set');\n\n    // JSON-LD 1.1 support\n    if(api.processingMode(activeCtx, 1.1)) {\n      validContainers.push('@graph', '@id', '@type');\n\n      // check container length\n      if(container.includes('@list')) {\n        if(container.length !== 1) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; @context @container with @list must ' +\n            'have no other values',\n            'jsonld.SyntaxError',\n            {code: 'invalid container mapping', context: localCtx});\n        }\n      } else if(container.includes('@graph')) {\n        if(container.some(key =>\n          key !== '@graph' && key !== '@id' && key !== '@index' &&\n          key !== '@set')) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; @context @container with @graph must ' +\n            'have no other values other than @id, @index, and @set',\n            'jsonld.SyntaxError',\n            {code: 'invalid container mapping', context: localCtx});\n        }\n      } else {\n        // otherwise, container may also include @set\n        isValid &= container.length <= (hasSet ? 2 : 1);\n      }\n\n      if(container.includes('@type')) {\n        // If mapping does not have an @type,\n        // set it to @id\n        mapping['@type'] = mapping['@type'] || '@id';\n\n        // type mapping must be either @id or @vocab\n        if(!['@id', '@vocab'].includes(mapping['@type'])) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; container: @type requires @type to be ' +\n            '@id or @vocab.',\n            'jsonld.SyntaxError',\n            {code: 'invalid type mapping', context: localCtx});\n        }\n      }\n    } else {\n      // in JSON-LD 1.0, container must not be an array (it must be a string,\n      // which is one of the validContainers)\n      isValid &= !_isArray(value['@container']);\n\n      // check container length\n      isValid &= container.length <= 1;\n    }\n\n    // check against valid containers\n    isValid &= container.every(c => validContainers.includes(c));\n\n    // @set not allowed with @list\n    isValid &= !(hasSet && container.includes('@list'));\n\n    if(!isValid) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @container value must be ' +\n        'one of the following: ' + validContainers.join(', '),\n        'jsonld.SyntaxError',\n        {code: 'invalid container mapping', context: localCtx});\n    }\n\n    if(mapping.reverse &&\n      !container.every(c => ['@index', '@set'].includes(c))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @container value for a @reverse ' +\n        'type definition must be @index or @set.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n\n    // add @container to mapping\n    mapping['@container'] = container;\n  }\n\n  // property indexing\n  if('@index' in value) {\n    if(!('@container' in value) || !mapping['@container'].includes('@index')) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @index without @index in @container: ' +\n        `\"${value['@index']}\" on term \"${term}\".`, 'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(!_isString(value['@index']) || value['@index'].indexOf('@') === 0) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @index must expand to an IRI: ' +\n        `\"${value['@index']}\" on term \"${term}\".`, 'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    mapping['@index'] = value['@index'];\n  }\n\n  // scoped contexts\n  if('@context' in value) {\n    mapping['@context'] = value['@context'];\n  }\n\n  if('@language' in value && !('@type' in value)) {\n    let language = value['@language'];\n    if(language !== null && !_isString(language)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @language value must be ' +\n        'a string or null.', 'jsonld.SyntaxError',\n        {code: 'invalid language mapping', context: localCtx});\n    }\n\n    // add @language to mapping\n    if(language !== null) {\n      language = language.toLowerCase();\n    }\n    mapping['@language'] = language;\n  }\n\n  // term may be used as a prefix\n  if('@prefix' in value) {\n    if(term.match(/:|\\//)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @prefix used on a compact IRI term',\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(api.isKeyword(mapping['@id'])) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; keywords may not be used as prefixes',\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(typeof value['@prefix'] === 'boolean') {\n      mapping._prefix = value['@prefix'] === true;\n    } else {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context value for @prefix must be boolean',\n        'jsonld.SyntaxError',\n        {code: 'invalid @prefix value', context: localCtx});\n    }\n  }\n\n  if('@direction' in value) {\n    const direction = value['@direction'];\n    if(direction !== null && direction !== 'ltr' && direction !== 'rtl') {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @direction value must be ' +\n        'null, \"ltr\", or \"rtl\".',\n        'jsonld.SyntaxError',\n        {code: 'invalid base direction', context: localCtx});\n    }\n    mapping['@direction'] = direction;\n  }\n\n  if('@nest' in value) {\n    const nest = value['@nest'];\n    if(!_isString(nest) || (nest !== '@nest' && nest.indexOf('@') === 0)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @nest value must be ' +\n        'a string which is not a keyword other than @nest.',\n        'jsonld.SyntaxError',\n        {code: 'invalid @nest value', context: localCtx});\n    }\n    mapping['@nest'] = nest;\n  }\n\n  // disallow aliasing @context and @preserve\n  const id = mapping['@id'];\n  if(id === '@context' || id === '@preserve') {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; @context and @preserve cannot be aliased.',\n      'jsonld.SyntaxError', {code: 'invalid keyword alias', context: localCtx});\n  }\n\n  // Check for overriding protected terms\n  if(previousMapping && previousMapping.protected && !overrideProtected) {\n    // force new term to continue to be protected and see if the mappings would\n    // be equal\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n    if(!_deepCompare(previousMapping, mapping)) {\n      const protectedMode = (options && options.protectedMode) || 'error';\n      if(protectedMode === 'error') {\n        throw new JsonLdError(\n          `Invalid JSON-LD syntax; tried to redefine \"${term}\" which is a ` +\n          'protected term.',\n          'jsonld.SyntaxError',\n          {code: 'protected term redefinition', context: localCtx, term});\n      } else if(protectedMode === 'warn') {\n        // FIXME: remove logging and use a handler\n        console.warn('WARNING: protected term redefinition', {term});\n        return;\n      }\n      throw new JsonLdError(\n        'Invalid protectedMode.',\n        'jsonld.SyntaxError',\n        {code: 'invalid protected mode', context: localCtx, term,\n          protectedMode});\n    }\n  }\n};\n\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\napi.expandIri = (activeCtx, value, relativeTo, options) => {\n  return _expandIri(activeCtx, value, relativeTo, undefined, undefined,\n    options);\n};\n\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param localCtx the local context being processed (only given if called\n *          during context processing).\n * @param defined a map for tracking cycles in context definitions (only given\n *          if called during context processing).\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandIri(activeCtx, value, relativeTo, localCtx, defined, options) {\n  // already expanded\n  if(value === null || !_isString(value) || api.isKeyword(value)) {\n    return value;\n  }\n\n  // ignore non-keyword things that look like a keyword\n  if(value.match(KEYWORD_PATTERN)) {\n    return null;\n  }\n\n  // define term dependency if not defined\n  if(localCtx && localCtx.hasOwnProperty(value) &&\n    defined.get(value) !== true) {\n    api.createTermDefinition({\n      activeCtx, localCtx, term: value, defined, options\n    });\n  }\n\n  relativeTo = relativeTo || {};\n  if(relativeTo.vocab) {\n    const mapping = activeCtx.mappings.get(value);\n\n    // value is explicitly ignored with a null mapping\n    if(mapping === null) {\n      return null;\n    }\n\n    if(_isObject(mapping) && '@id' in mapping) {\n      // value is a term\n      return mapping['@id'];\n    }\n  }\n\n  // split value into prefix:suffix\n  const colon = value.indexOf(':');\n  if(colon > 0) {\n    const prefix = value.substr(0, colon);\n    const suffix = value.substr(colon + 1);\n\n    // do not expand blank nodes (prefix of '_') or already-absolute\n    // IRIs (suffix of '//')\n    if(prefix === '_' || suffix.indexOf('//') === 0) {\n      return value;\n    }\n\n    // prefix dependency not defined, define it\n    if(localCtx && localCtx.hasOwnProperty(prefix)) {\n      api.createTermDefinition({\n        activeCtx, localCtx, term: prefix, defined, options\n      });\n    }\n\n    // use mapping if prefix is defined\n    const mapping = activeCtx.mappings.get(prefix);\n    if(mapping && mapping._prefix) {\n      return mapping['@id'] + suffix;\n    }\n\n    // already absolute IRI\n    if(_isAbsoluteIri(value)) {\n      return value;\n    }\n  }\n\n  // prepend vocab\n  if(relativeTo.vocab && '@vocab' in activeCtx) {\n    return activeCtx['@vocab'] + value;\n  }\n\n  // prepend base\n  if(relativeTo.base && '@base' in activeCtx) {\n    if(activeCtx['@base']) {\n      // The null case preserves value as potentially relative\n      return prependBase(prependBase(options.base, activeCtx['@base']), value);\n    }\n  } else if(relativeTo.base) {\n    return prependBase(options.base, value);\n  }\n\n  return value;\n}\n\n/**\n * Gets the initial context.\n *\n * @param options the options to use:\n *          [base] the document base IRI.\n *\n * @return the initial context.\n */\napi.getInitialContext = options => {\n  const key = JSON.stringify({processingMode: options.processingMode});\n  const cached = INITIAL_CONTEXT_CACHE.get(key);\n  if(cached) {\n    return cached;\n  }\n\n  const initialContext = {\n    processingMode: options.processingMode,\n    mappings: new Map(),\n    inverse: null,\n    getInverse: _createInverseContext,\n    clone: _cloneActiveContext,\n    revertToPreviousContext: _revertToPreviousContext,\n    protected: {}\n  };\n  // TODO: consider using LRU cache instead\n  if(INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {\n    // clear whole cache -- assumes scenario where the cache fills means\n    // the cache isn't being used very efficiently anyway\n    INITIAL_CONTEXT_CACHE.clear();\n  }\n  INITIAL_CONTEXT_CACHE.set(key, initialContext);\n  return initialContext;\n\n  /**\n   * Generates an inverse context for use in the compaction algorithm, if\n   * not already generated for the given active context.\n   *\n   * @return the inverse context.\n   */\n  function _createInverseContext() {\n    const activeCtx = this;\n\n    // lazily create inverse\n    if(activeCtx.inverse) {\n      return activeCtx.inverse;\n    }\n    const inverse = activeCtx.inverse = {};\n\n    // variables for building fast CURIE map\n    const fastCurieMap = activeCtx.fastCurieMap = {};\n    const irisToTerms = {};\n\n    // handle default language\n    const defaultLanguage = (activeCtx['@language'] || '@none').toLowerCase();\n\n    // handle default direction\n    const defaultDirection = activeCtx['@direction'];\n\n    // create term selections for each mapping in the context, ordered by\n    // shortest and then lexicographically least\n    const mappings = activeCtx.mappings;\n    const terms = [...mappings.keys()].sort(_compareShortestLeast);\n    for(const term of terms) {\n      const mapping = mappings.get(term);\n      if(mapping === null) {\n        continue;\n      }\n\n      let container = mapping['@container'] || '@none';\n      container = [].concat(container).sort().join('');\n\n      if(mapping['@id'] === null) {\n        continue;\n      }\n      // iterate over every IRI in the mapping\n      const ids = _asArray(mapping['@id']);\n      for(const iri of ids) {\n        let entry = inverse[iri];\n        const isKeyword = api.isKeyword(iri);\n\n        if(!entry) {\n          // initialize entry\n          inverse[iri] = entry = {};\n\n          if(!isKeyword && !mapping._termHasColon) {\n            // init IRI to term map and fast CURIE prefixes\n            irisToTerms[iri] = [term];\n            const fastCurieEntry = {iri, terms: irisToTerms[iri]};\n            if(iri[0] in fastCurieMap) {\n              fastCurieMap[iri[0]].push(fastCurieEntry);\n            } else {\n              fastCurieMap[iri[0]] = [fastCurieEntry];\n            }\n          }\n        } else if(!isKeyword && !mapping._termHasColon) {\n          // add IRI to term match\n          irisToTerms[iri].push(term);\n        }\n\n        // add new entry\n        if(!entry[container]) {\n          entry[container] = {\n            '@language': {},\n            '@type': {},\n            '@any': {}\n          };\n        }\n        entry = entry[container];\n        _addPreferredTerm(term, entry['@any'], '@none');\n\n        if(mapping.reverse) {\n          // term is preferred for values using @reverse\n          _addPreferredTerm(term, entry['@type'], '@reverse');\n        } else if(mapping['@type'] === '@none') {\n          _addPreferredTerm(term, entry['@any'], '@none');\n          _addPreferredTerm(term, entry['@language'], '@none');\n          _addPreferredTerm(term, entry['@type'], '@none');\n        } else if('@type' in mapping) {\n          // term is preferred for values using specific type\n          _addPreferredTerm(term, entry['@type'], mapping['@type']);\n        } else if('@language' in mapping && '@direction' in mapping) {\n          // term is preferred for values using specific language and direction\n          const language = mapping['@language'];\n          const direction = mapping['@direction'];\n          if(language && direction) {\n            _addPreferredTerm(term, entry['@language'],\n              `${language}_${direction}`.toLowerCase());\n          } else if(language) {\n            _addPreferredTerm(term, entry['@language'], language.toLowerCase());\n          } else if(direction) {\n            _addPreferredTerm(term, entry['@language'], `_${direction}`);\n          } else {\n            _addPreferredTerm(term, entry['@language'], '@null');\n          }\n        } else if('@language' in mapping) {\n          _addPreferredTerm(term, entry['@language'],\n            (mapping['@language'] || '@null').toLowerCase());\n        } else if('@direction' in mapping) {\n          if(mapping['@direction']) {\n            _addPreferredTerm(term, entry['@language'],\n              `_${mapping['@direction']}`);\n          } else {\n            _addPreferredTerm(term, entry['@language'], '@none');\n          }\n        } else if(defaultDirection) {\n          _addPreferredTerm(term, entry['@language'], `_${defaultDirection}`);\n          _addPreferredTerm(term, entry['@language'], '@none');\n          _addPreferredTerm(term, entry['@type'], '@none');\n        } else {\n          // add entries for no type and no language\n          _addPreferredTerm(term, entry['@language'], defaultLanguage);\n          _addPreferredTerm(term, entry['@language'], '@none');\n          _addPreferredTerm(term, entry['@type'], '@none');\n        }\n      }\n    }\n\n    // build fast CURIE map\n    for(const key in fastCurieMap) {\n      _buildIriMap(fastCurieMap, key, 1);\n    }\n\n    return inverse;\n  }\n\n  /**\n   * Runs a recursive algorithm to build a lookup map for quickly finding\n   * potential CURIEs.\n   *\n   * @param iriMap the map to build.\n   * @param key the current key in the map to work on.\n   * @param idx the index into the IRI to compare.\n   */\n  function _buildIriMap(iriMap, key, idx) {\n    const entries = iriMap[key];\n    const next = iriMap[key] = {};\n\n    let iri;\n    let letter;\n    for(const entry of entries) {\n      iri = entry.iri;\n      if(idx >= iri.length) {\n        letter = '';\n      } else {\n        letter = iri[idx];\n      }\n      if(letter in next) {\n        next[letter].push(entry);\n      } else {\n        next[letter] = [entry];\n      }\n    }\n\n    for(const key in next) {\n      if(key === '') {\n        continue;\n      }\n      _buildIriMap(next, key, idx + 1);\n    }\n  }\n\n  /**\n   * Adds the term for the given entry if not already added.\n   *\n   * @param term the term to add.\n   * @param entry the inverse context typeOrLanguage entry to add to.\n   * @param typeOrLanguageValue the key in the entry to add to.\n   */\n  function _addPreferredTerm(term, entry, typeOrLanguageValue) {\n    if(!entry.hasOwnProperty(typeOrLanguageValue)) {\n      entry[typeOrLanguageValue] = term;\n    }\n  }\n\n  /**\n   * Clones an active context, creating a child active context.\n   *\n   * @return a clone (child) of the active context.\n   */\n  function _cloneActiveContext() {\n    const child = {};\n    child.mappings = util.clone(this.mappings);\n    child.clone = this.clone;\n    child.inverse = null;\n    child.getInverse = this.getInverse;\n    child.protected = util.clone(this.protected);\n    if(this.previousContext) {\n      child.previousContext = this.previousContext.clone();\n    }\n    child.revertToPreviousContext = this.revertToPreviousContext;\n    if('@base' in this) {\n      child['@base'] = this['@base'];\n    }\n    if('@language' in this) {\n      child['@language'] = this['@language'];\n    }\n    if('@vocab' in this) {\n      child['@vocab'] = this['@vocab'];\n    }\n    return child;\n  }\n\n  /**\n   * Reverts any type-scoped context in this active context to the previous\n   * context.\n   */\n  function _revertToPreviousContext() {\n    if(!this.previousContext) {\n      return this;\n    }\n    return this.previousContext.clone();\n  }\n};\n\n/**\n * Gets the value for the given active context key and type, null if none is\n * set or undefined if none is set and type is '@context'.\n *\n * @param ctx the active context.\n * @param key the context key.\n * @param [type] the type of value to get (eg: '@id', '@type'), if not\n *          specified gets the entire entry for a key, null if not found.\n *\n * @return the value, null, or undefined.\n */\napi.getContextValue = (ctx, key, type) => {\n  // invalid key\n  if(key === null) {\n    if(type === '@context') {\n      return undefined;\n    }\n    return null;\n  }\n\n  // get specific entry information\n  if(ctx.mappings.has(key)) {\n    const entry = ctx.mappings.get(key);\n\n    if(_isUndefined(type)) {\n      // return whole entry\n      return entry;\n    }\n    if(entry.hasOwnProperty(type)) {\n      // return entry value for type\n      return entry[type];\n    }\n  }\n\n  // get default language\n  if(type === '@language' && type in ctx) {\n    return ctx[type];\n  }\n\n  // get default direction\n  if(type === '@direction' && type in ctx) {\n    return ctx[type];\n  }\n\n  if(type === '@context') {\n    return undefined;\n  }\n  return null;\n};\n\n/**\n * Processing Mode check.\n *\n * @param activeCtx the current active context.\n * @param version the string or numeric version to check.\n *\n * @return boolean.\n */\napi.processingMode = (activeCtx, version) => {\n  if(version.toString() >= '1.1') {\n    return !activeCtx.processingMode ||\n      activeCtx.processingMode >= 'json-ld-' + version.toString();\n  } else {\n    return activeCtx.processingMode === 'json-ld-1.0';\n  }\n};\n\n/**\n * Returns whether or not the given value is a keyword.\n *\n * @param v the value to check.\n *\n * @return true if the value is a keyword, false if not.\n */\napi.isKeyword = v => {\n  if(!_isString(v) || v[0] !== '@') {\n    return false;\n  }\n  switch(v) {\n    case '@base':\n    case '@container':\n    case '@context':\n    case '@default':\n    case '@direction':\n    case '@embed':\n    case '@explicit':\n    case '@graph':\n    case '@id':\n    case '@included':\n    case '@index':\n    case '@json':\n    case '@language':\n    case '@list':\n    case '@nest':\n    case '@none':\n    case '@omitDefault':\n    case '@prefix':\n    case '@preserve':\n    case '@protected':\n    case '@requireAll':\n    case '@reverse':\n    case '@set':\n    case '@type':\n    case '@value':\n    case '@version':\n    case '@vocab':\n      return true;\n  }\n  return false;\n};\n\nfunction _deepCompare(x1, x2) {\n  // compare `null` or primitive types directly\n  if((!(x1 && typeof x1 === 'object')) ||\n     (!(x2 && typeof x2 === 'object'))) {\n    return x1 === x2;\n  }\n  // x1 and x2 are objects (also potentially arrays)\n  const x1Array = Array.isArray(x1);\n  if(x1Array !== Array.isArray(x2)) {\n    return false;\n  }\n  if(x1Array) {\n    if(x1.length !== x2.length) {\n      return false;\n    }\n    for(let i = 0; i < x1.length; ++i) {\n      if(!_deepCompare(x1[i], x2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // x1 and x2 are non-array objects\n  const k1s = Object.keys(x1);\n  const k2s = Object.keys(x2);\n  if(k1s.length !== k2s.length) {\n    return false;\n  }\n  for(const k1 in x1) {\n    let v1 = x1[k1];\n    let v2 = x2[k1];\n    // special case: `@container` can be in any order\n    if(k1 === '@container') {\n      if(Array.isArray(v1) && Array.isArray(v2)) {\n        v1 = v1.slice().sort();\n        v2 = v2.slice().sort();\n      }\n    }\n    if(!_deepCompare(v1, v2)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/context.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/documentLoaders/xhr.js":
/*!********************************************************!*\
  !*** ./node_modules/jsonld/lib/documentLoaders/xhr.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {parseLinkHeader, buildHeaders} = __webpack_require__(/*! ../util */ \"./node_modules/jsonld/lib/util.js\");\nconst {LINK_HEADER_CONTEXT} = __webpack_require__(/*! ../constants */ \"./node_modules/jsonld/lib/constants.js\");\nconst JsonLdError = __webpack_require__(/*! ../JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\nconst RequestQueue = __webpack_require__(/*! ../RequestQueue */ \"./node_modules/jsonld/lib/RequestQueue.js\");\nconst {prependBase} = __webpack_require__(/*! ../url */ \"./node_modules/jsonld/lib/url.js\");\n\nconst REGEX_LINK_HEADER = /(^|(\\r\\n))link:/i;\n\n/**\n * Creates a built-in XMLHttpRequest document loader.\n *\n * @param options the options to use:\n *          secure: require all URLs to use HTTPS.\n *          headers: an object (map) of headers which will be passed as request\n *            headers for the requested document. Accept is not allowed.\n *          [xhr]: the XMLHttpRequest API to use.\n *\n * @return the XMLHttpRequest document loader.\n */\nmodule.exports = ({\n  secure,\n  headers = {},\n  xhr\n} = {headers: {}}) => {\n  headers = buildHeaders(headers);\n  const queue = new RequestQueue();\n  return queue.wrapLoader(loader);\n\n  async function loader(url) {\n    if(url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; only \"http\" and \"https\" URLs are ' +\n        'supported.',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    if(secure && url.indexOf('https') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; secure mode is enabled and ' +\n        'the URL\\'s scheme is not \"https\".',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n\n    let req;\n    try {\n      req = await _get(xhr, url, headers);\n    } catch(e) {\n      throw new JsonLdError(\n        'URL could not be dereferenced, an error occurred.',\n        'jsonld.LoadDocumentError',\n        {code: 'loading document failed', url, cause: e});\n    }\n\n    if(req.status >= 400) {\n      throw new JsonLdError(\n        'URL could not be dereferenced: ' + req.statusText,\n        'jsonld.LoadDocumentError', {\n          code: 'loading document failed',\n          url,\n          httpStatusCode: req.status\n        });\n    }\n\n    let doc = {contextUrl: null, documentUrl: url, document: req.response};\n    let alternate = null;\n\n    // handle Link Header (avoid unsafe header warning by existence testing)\n    const contentType = req.getResponseHeader('Content-Type');\n    let linkHeader;\n    if(REGEX_LINK_HEADER.test(req.getAllResponseHeaders())) {\n      linkHeader = req.getResponseHeader('Link');\n    }\n    if(linkHeader && contentType !== 'application/ld+json') {\n      // only 1 related link header permitted\n      const linkHeaders = parseLinkHeader(linkHeader);\n      const linkedContext = linkHeaders[LINK_HEADER_CONTEXT];\n      if(Array.isArray(linkedContext)) {\n        throw new JsonLdError(\n          'URL could not be dereferenced, it has more than one ' +\n          'associated HTTP Link Header.',\n          'jsonld.InvalidUrl',\n          {code: 'multiple context link headers', url});\n      }\n      if(linkedContext) {\n        doc.contextUrl = linkedContext.target;\n      }\n\n      // \"alternate\" link header is a redirect\n      alternate = linkHeaders['alternate'];\n      if(alternate &&\n        alternate.type == 'application/ld+json' &&\n        !(contentType || '').match(/^application\\/(\\w*\\+)?json$/)) {\n        doc = await loader(prependBase(url, alternate.target));\n      }\n    }\n\n    return doc;\n  }\n};\n\nfunction _get(xhr, url, headers) {\n  xhr = xhr || XMLHttpRequest;\n  const req = new xhr();\n  return new Promise((resolve, reject) => {\n    req.onload = () => resolve(req);\n    req.onerror = err => reject(err);\n    req.open('GET', url, true);\n    for(const k in headers) {\n      req.setRequestHeader(k, headers[k]);\n    }\n    req.send();\n  });\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/documentLoaders/xhr.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/expand.js":
/*!*******************************************!*\
  !*** ./node_modules/jsonld/lib/expand.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isEmptyObject: _isEmptyObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSubject: _isSubject\n} = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = __webpack_require__(/*! ./context */ \"./node_modules/jsonld/lib/context.js\");\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = __webpack_require__(/*! ./url */ \"./node_modules/jsonld/lib/url.js\");\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  getValues: _getValues,\n  validateTypeValue: _validateTypeValue\n} = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\n\nconst api = {};\nmodule.exports = api;\nconst REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;\n\n/**\n * Recursively expands an element using the given context. Any context in\n * the element will be removed. All context URLs must have been retrieved\n * before calling this method.\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element, null for none.\n * @param element the element to expand.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param insideIndex true if the element is inside an index container,\n *          false if not.\n * @param typeScopedContext an optional type-scoped active context for\n *          expanding values of nodes that were expressed according to\n *          a type-scoped context.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n *\n * @return a Promise that resolves to the expanded value.\n */\napi.expand = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  insideList = false,\n  insideIndex = false,\n  typeScopedContext = null,\n  expansionMap = () => undefined\n}) => {\n  // nothing to expand\n  if(element === null || element === undefined) {\n    return null;\n  }\n\n  // disable framing if activeProperty is @default\n  if(activeProperty === '@default') {\n    options = Object.assign({}, options, {isFrame: false});\n  }\n\n  if(!_isArray(element) && !_isObject(element)) {\n    // drop free-floating scalars that are not in lists unless custom mapped\n    if(!insideList && (activeProperty === null ||\n      _expandIri(activeCtx, activeProperty, {vocab: true},\n        options) === '@graph')) {\n      const mapped = await expansionMap({\n        unmappedValue: element,\n        activeCtx,\n        activeProperty,\n        options,\n        insideList\n      });\n      if(mapped === undefined) {\n        return null;\n      }\n      return mapped;\n    }\n\n    // expand element according to value expansion rules\n    return _expandValue({activeCtx, activeProperty, value: element, options});\n  }\n\n  // recursively expand array\n  if(_isArray(element)) {\n    let rval = [];\n    const container = _getContextValue(\n      activeCtx, activeProperty, '@container') || [];\n    insideList = insideList || container.includes('@list');\n    for(let i = 0; i < element.length; ++i) {\n      // expand element\n      let e = await api.expand({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        expansionMap,\n        insideIndex,\n        typeScopedContext\n      });\n      if(insideList && _isArray(e)) {\n        e = {'@list': e};\n      }\n\n      if(e === null) {\n        e = await expansionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options,\n          expandedParent: rval,\n          insideList\n        });\n        if(e === undefined) {\n          continue;\n        }\n      }\n\n      if(_isArray(e)) {\n        rval = rval.concat(e);\n      } else {\n        rval.push(e);\n      }\n    }\n    return rval;\n  }\n\n  // recursively expand object:\n\n  // first, expand the active property\n  const expandedActiveProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n\n  // Get any property-scoped context for activeProperty\n  const propertyScopedCtx =\n    _getContextValue(activeCtx, activeProperty, '@context');\n\n  // second, determine if any type-scoped context should be reverted; it\n  // should only be reverted when the following are all true:\n  // 1. `element` is not a value or subject reference\n  // 2. `insideIndex` is false\n  typeScopedContext = typeScopedContext ||\n    (activeCtx.previousContext ? activeCtx : null);\n  let keys = Object.keys(element).sort();\n  let mustRevert = !insideIndex;\n  if(mustRevert && typeScopedContext && keys.length <= 2 &&\n    !keys.includes('@context')) {\n    for(const key of keys) {\n      const expandedProperty = _expandIri(\n        typeScopedContext, key, {vocab: true}, options);\n      if(expandedProperty === '@value') {\n        // value found, ensure type-scoped context is used to expand it\n        mustRevert = false;\n        activeCtx = typeScopedContext;\n        break;\n      }\n      if(expandedProperty === '@id' && keys.length === 1) {\n        // subject reference found, do not revert\n        mustRevert = false;\n        break;\n      }\n    }\n  }\n\n  if(mustRevert) {\n    // revert type scoped context\n    activeCtx = activeCtx.revertToPreviousContext();\n  }\n\n  // apply property-scoped context after reverting term-scoped context\n  if(!_isUndefined(propertyScopedCtx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: propertyScopedCtx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // if element has a context, process it\n  if('@context' in element) {\n    activeCtx = await _processContext(\n      {activeCtx, localCtx: element['@context'], options});\n  }\n\n  // set the type-scoped context to the context on input, for use later\n  typeScopedContext = activeCtx;\n\n  // Remember the first key found expanding to @type\n  let typeKey = null;\n\n  // look for scoped contexts on `@type`\n  for(const key of keys) {\n    const expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n    if(expandedProperty === '@type') {\n      // set scoped contexts from @type\n      // avoid sorting if possible\n      typeKey = typeKey || key;\n      const value = element[key];\n      const types =\n        Array.isArray(value) ?\n          (value.length > 1 ? value.slice().sort() : value) : [value];\n      for(const type of types) {\n        const ctx = _getContextValue(typeScopedContext, type, '@context');\n        if(!_isUndefined(ctx)) {\n          activeCtx = await _processContext({\n            activeCtx,\n            localCtx: ctx,\n            options,\n            propagate: false\n          });\n        }\n      }\n    }\n  }\n\n  // process each key and value in element, ignoring @nest content\n  let rval = {};\n  await _expandObject({\n    activeCtx,\n    activeProperty,\n    expandedActiveProperty,\n    element,\n    expandedParent: rval,\n    options,\n    insideList,\n    typeKey,\n    typeScopedContext,\n    expansionMap});\n\n  // get property count on expanded output\n  keys = Object.keys(rval);\n  let count = keys.length;\n\n  if('@value' in rval) {\n    // @value must only have @language or @type\n    if('@type' in rval && ('@language' in rval || '@direction' in rval)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may not ' +\n        'contain both \"@type\" and either \"@language\" or \"@direction\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    let validCount = count - 1;\n    if('@type' in rval) {\n      validCount -= 1;\n    }\n    if('@index' in rval) {\n      validCount -= 1;\n    }\n    if('@language' in rval) {\n      validCount -= 1;\n    }\n    if('@direction' in rval) {\n      validCount -= 1;\n    }\n    if(validCount !== 0) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may only ' +\n        'have an \"@index\" property and either \"@type\" ' +\n        'or either or both \"@language\" or \"@direction\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    const values = rval['@value'] === null ? [] : _asArray(rval['@value']);\n    const types = _getValues(rval, '@type');\n\n    // drop null @values unless custom mapped\n    if(_processingMode(activeCtx, 1.1) && types.includes('@json') &&\n      types.length === 1) {\n      // Any value of @value is okay if @type: @json\n    } else if(values.length === 0) {\n      const mapped = await expansionMap({\n        unmappedValue: rval,\n        activeCtx,\n        activeProperty,\n        element,\n        options,\n        insideList\n      });\n      if(mapped !== undefined) {\n        rval = mapped;\n      } else {\n        rval = null;\n      }\n    } else if(!values.every(v => (_isString(v) || _isEmptyObject(v))) &&\n      '@language' in rval) {\n      // if @language is present, @value must be a string\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; only strings may be language-tagged.',\n        'jsonld.SyntaxError',\n        {code: 'invalid language-tagged value', element: rval});\n    } else if(!types.every(t =>\n      (_isAbsoluteIri(t) && !(_isString(t) && t.indexOf('_:') === 0) ||\n      _isEmptyObject(t)))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" and \"@type\" ' +\n        'must have an absolute IRI for the value of \"@type\".',\n        'jsonld.SyntaxError', {code: 'invalid typed value', element: rval});\n    }\n  } else if('@type' in rval && !_isArray(rval['@type'])) {\n    // convert @type to an array\n    rval['@type'] = [rval['@type']];\n  } else if('@set' in rval || '@list' in rval) {\n    // handle @set and @list\n    if(count > 1 && !(count === 2 && '@index' in rval)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; if an element has the property \"@set\" ' +\n        'or \"@list\", then it can have at most one other property that is ' +\n        '\"@index\".', 'jsonld.SyntaxError',\n        {code: 'invalid set or list object', element: rval});\n    }\n    // optimize away @set\n    if('@set' in rval) {\n      rval = rval['@set'];\n      keys = Object.keys(rval);\n      count = keys.length;\n    }\n  } else if(count === 1 && '@language' in rval) {\n    // drop objects with only @language unless custom mapped\n    const mapped = await expansionMap(rval, {\n      unmappedValue: rval,\n      activeCtx,\n      activeProperty,\n      element,\n      options,\n      insideList\n    });\n    if(mapped !== undefined) {\n      rval = mapped;\n    } else {\n      rval = null;\n    }\n  }\n\n  // drop certain top-level objects that do not occur in lists, unless custom\n  // mapped\n  if(_isObject(rval) &&\n    !options.keepFreeFloatingNodes && !insideList &&\n    (activeProperty === null || expandedActiveProperty === '@graph')) {\n    // drop empty object, top-level @value/@list, or object with only @id\n    if(count === 0 || '@value' in rval || '@list' in rval ||\n      (count === 1 && '@id' in rval)) {\n      const mapped = await expansionMap({\n        unmappedValue: rval,\n        activeCtx,\n        activeProperty,\n        element,\n        options,\n        insideList\n      });\n      if(mapped !== undefined) {\n        rval = mapped;\n      } else {\n        rval = null;\n      }\n    }\n  }\n\n  return rval;\n};\n\n/**\n * Expand each key and value of element adding to result\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element.\n * @param expandedActiveProperty the expansion of activeProperty\n * @param element the element to expand.\n * @param expandedParent the expanded result into which to add values.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param typeKey first key found expanding to @type.\n * @param typeScopedContext the context before reverting.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n */\nasync function _expandObject({\n  activeCtx,\n  activeProperty,\n  expandedActiveProperty,\n  element,\n  expandedParent,\n  options = {},\n  insideList,\n  typeKey,\n  typeScopedContext,\n  expansionMap\n}) {\n  const keys = Object.keys(element).sort();\n  const nests = [];\n  let unexpandedValue;\n\n  // Figure out if this is the type for a JSON literal\n  const isJsonType = element[typeKey] &&\n    _expandIri(activeCtx,\n      (_isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey]),\n      {vocab: true}, options) === '@json';\n\n  for(const key of keys) {\n    let value = element[key];\n    let expandedValue;\n\n    // skip @context\n    if(key === '@context') {\n      continue;\n    }\n\n    // expand property\n    let expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n\n    // drop non-absolute IRI keys that aren't keywords unless custom mapped\n    if(expandedProperty === null ||\n      !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {\n      // TODO: use `await` to support async\n      expandedProperty = expansionMap({\n        unmappedProperty: key,\n        activeCtx,\n        activeProperty,\n        parent: element,\n        options,\n        insideList,\n        value,\n        expandedParent\n      });\n      if(expandedProperty === undefined) {\n        continue;\n      }\n    }\n\n    if(_isKeyword(expandedProperty)) {\n      if(expandedActiveProperty === '@reverse') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' +\n          'property.', 'jsonld.SyntaxError',\n          {code: 'invalid reverse property map', value});\n      }\n      if(expandedProperty in expandedParent &&\n         expandedProperty !== '@included' &&\n         expandedProperty !== '@type') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; colliding keywords detected.',\n          'jsonld.SyntaxError',\n          {code: 'colliding keywords', keyword: expandedProperty});\n      }\n    }\n\n    // syntax error if @id is not a string\n    if(expandedProperty === '@id') {\n      if(!_isString(value)) {\n        if(!options.isFrame) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value must a string.',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n        if(_isObject(value)) {\n          // empty object is a wildcard\n          if(!_isEmptyObject(value)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else if(_isArray(value)) {\n          if(!value.every(v => _isString(v))) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n            'of strings, if framing',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n      }\n\n      _addValue(\n        expandedParent, '@id',\n        _asArray(value).map(v =>\n          _isString(v) ? _expandIri(activeCtx, v, {base: true}, options) : v),\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    if(expandedProperty === '@type') {\n      // if framing, can be a default object, but need to expand\n      // key to determine that\n      if(_isObject(value)) {\n        value = Object.fromEntries(Object.entries(value).map(([k, v]) => [\n          _expandIri(typeScopedContext, k, {vocab: true}),\n          _asArray(v).map(vv =>\n            _expandIri(typeScopedContext, vv, {base: true, vocab: true})\n          )\n        ]));\n      }\n      _validateTypeValue(value, options.isFrame);\n      _addValue(\n        expandedParent, '@type',\n        _asArray(value).map(v =>\n          _isString(v) ?\n            _expandIri(typeScopedContext, v,\n              {base: true, vocab: true}, options) : v),\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // Included blocks are treated as an array of separate object nodes sharing\n    // the same referencing active_property.\n    // For 1.0, it is skipped as are other unknown keywords\n    if(expandedProperty === '@included' && _processingMode(activeCtx, 1.1)) {\n      const includedResult = _asArray(await api.expand({\n        activeCtx,\n        activeProperty,\n        element: value,\n        options,\n        expansionMap\n      }));\n\n      // Expanded values must be node objects\n      if(!includedResult.every(v => _isSubject(v))) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; ' +\n          'values of @included must expand to node objects.',\n          'jsonld.SyntaxError', {code: 'invalid @included value', value});\n      }\n\n      _addValue(\n        expandedParent, '@included', includedResult, {propertyIsArray: true});\n      continue;\n    }\n\n    // @graph must be an array or an object\n    if(expandedProperty === '@graph' &&\n      !(_isObject(value) || _isArray(value))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@graph\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError', {code: 'invalid @graph value', value});\n    }\n\n    if(expandedProperty === '@value') {\n      // capture value for later\n      // \"colliding keywords\" check prevents this from being set twice\n      unexpandedValue = value;\n      if(isJsonType && _processingMode(activeCtx, 1.1)) {\n        // no coercion to array, and retain all values\n        expandedParent['@value'] = value;\n      } else {\n        _addValue(\n          expandedParent, '@value', value, {propertyIsArray: options.isFrame});\n      }\n      continue;\n    }\n\n    // @language must be a string\n    // it should match BCP47\n    if(expandedProperty === '@language') {\n      if(value === null) {\n        // drop null @language values, they expand as if they didn't exist\n        continue;\n      }\n      if(!_isString(value) && !options.isFrame) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@language\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language-tagged string', value});\n      }\n      // ensure language value is lowercase\n      value = _asArray(value).map(v => _isString(v) ? v.toLowerCase() : v);\n\n      // ensure language tag matches BCP47\n      for(const lang of value) {\n        if(_isString(lang) && !lang.match(REGEX_BCP47)) {\n          console.warn(`@language must be valid BCP47: ${lang}`);\n        }\n      }\n\n      _addValue(\n        expandedParent, '@language', value, {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @direction must be \"ltr\" or \"rtl\"\n    if(expandedProperty === '@direction') {\n      if(!_isString(value) && !options.isFrame) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@direction\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid base direction', value});\n      }\n\n      value = _asArray(value);\n\n      // ensure direction is \"ltr\" or \"rtl\"\n      for(const dir of value) {\n        if(_isString(dir) && dir !== 'ltr' && dir !== 'rtl') {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@direction\" must be \"ltr\" or \"rtl\".',\n            'jsonld.SyntaxError',\n            {code: 'invalid base direction', value});\n        }\n      }\n\n      _addValue(\n        expandedParent, '@direction', value,\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @index must be a string\n    if(expandedProperty === '@index') {\n      if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@index\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @index value', value});\n      }\n      _addValue(expandedParent, '@index', value);\n      continue;\n    }\n\n    // @reverse must be an object\n    if(expandedProperty === '@reverse') {\n      if(!_isObject(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@reverse\" value must be an object.',\n          'jsonld.SyntaxError', {code: 'invalid @reverse value', value});\n      }\n\n      expandedValue = await api.expand({\n        activeCtx,\n        activeProperty:\n        '@reverse',\n        element: value,\n        options,\n        expansionMap\n      });\n      // properties double-reversed\n      if('@reverse' in expandedValue) {\n        for(const property in expandedValue['@reverse']) {\n          _addValue(\n            expandedParent, property, expandedValue['@reverse'][property],\n            {propertyIsArray: true});\n        }\n      }\n\n      // FIXME: can this be merged with code below to simplify?\n      // merge in all reversed properties\n      let reverseMap = expandedParent['@reverse'] || null;\n      for(const property in expandedValue) {\n        if(property === '@reverse') {\n          continue;\n        }\n        if(reverseMap === null) {\n          reverseMap = expandedParent['@reverse'] = {};\n        }\n        _addValue(reverseMap, property, [], {propertyIsArray: true});\n        const items = expandedValue[property];\n        for(let ii = 0; ii < items.length; ++ii) {\n          const item = items[ii];\n          if(_isValue(item) || _isList(item)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n              '@value or an @list.', 'jsonld.SyntaxError',\n              {code: 'invalid reverse property value', value: expandedValue});\n          }\n          _addValue(reverseMap, property, item, {propertyIsArray: true});\n        }\n      }\n\n      continue;\n    }\n\n    // nested keys\n    if(expandedProperty === '@nest') {\n      nests.push(key);\n      continue;\n    }\n\n    // use potential scoped context for key\n    let termCtx = activeCtx;\n    const ctx = _getContextValue(activeCtx, key, '@context');\n    if(!_isUndefined(ctx)) {\n      termCtx = await _processContext({\n        activeCtx,\n        localCtx: ctx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    const container = _getContextValue(termCtx, key, '@container') || [];\n\n    if(container.includes('@language') && _isObject(value)) {\n      const direction = _getContextValue(termCtx, key, '@direction');\n      // handle language map container (skip if value is not an object)\n      expandedValue = _expandLanguageMap(termCtx, value, direction, options);\n    } else if(container.includes('@index') && _isObject(value)) {\n      // handle index container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      const indexKey = _getContextValue(termCtx, key, '@index') || '@index';\n      const propertyIndex = indexKey !== '@index' &&\n        _expandIri(activeCtx, indexKey, {vocab: true}, options);\n\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph,\n        indexKey,\n        propertyIndex\n      });\n    } else if(container.includes('@id') && _isObject(value)) {\n      // handle id container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph,\n        indexKey: '@id'\n      });\n    } else if(container.includes('@type') && _isObject(value)) {\n      // handle type container (skip if value is not an object)\n      expandedValue = await _expandIndexMap({\n        // since container is `@type`, revert type scoped context when expanding\n        activeCtx: termCtx.revertToPreviousContext(),\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph: false,\n        indexKey: '@type'\n      });\n    } else {\n      // recurse into @list or @set\n      const isList = (expandedProperty === '@list');\n      if(isList || expandedProperty === '@set') {\n        let nextActiveProperty = activeProperty;\n        if(isList && expandedActiveProperty === '@graph') {\n          nextActiveProperty = null;\n        }\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: nextActiveProperty,\n          element: value,\n          options,\n          insideList: isList,\n          expansionMap\n        });\n      } else if(\n        _getContextValue(activeCtx, key, '@type') === '@json') {\n        expandedValue = {\n          '@type': '@json',\n          '@value': value\n        };\n      } else {\n        // recursively expand value with key as new active property\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: key,\n          element: value,\n          options,\n          insideList: false,\n          expansionMap\n        });\n      }\n    }\n\n    // drop null values if property is not @value\n    if(expandedValue === null && expandedProperty !== '@value') {\n      // TODO: use `await` to support async\n      expandedValue = expansionMap({\n        unmappedValue: value,\n        expandedProperty,\n        activeCtx: termCtx,\n        activeProperty,\n        parent: element,\n        options,\n        insideList,\n        key,\n        expandedParent\n      });\n      if(expandedValue === undefined) {\n        continue;\n      }\n    }\n\n    // convert expanded value to @list if container specifies it\n    if(expandedProperty !== '@list' && !_isList(expandedValue) &&\n      container.includes('@list')) {\n      // ensure expanded value in @list is an array\n      expandedValue = {'@list': _asArray(expandedValue)};\n    }\n\n    // convert expanded value to @graph if container specifies it\n    // and value is not, itself, a graph\n    // index cases handled above\n    if(container.includes('@graph') &&\n      !container.some(key => key === '@id' || key === '@index')) {\n      // ensure expanded values are arrays\n      expandedValue = _asArray(expandedValue)\n        .map(v => ({'@graph': _asArray(v)}));\n    }\n\n    // FIXME: can this be merged with code above to simplify?\n    // merge in reverse properties\n    if(termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {\n      const reverseMap =\n        expandedParent['@reverse'] = expandedParent['@reverse'] || {};\n      expandedValue = _asArray(expandedValue);\n      for(let ii = 0; ii < expandedValue.length; ++ii) {\n        const item = expandedValue[ii];\n        if(_isValue(item) || _isList(item)) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n            '@value or an @list.', 'jsonld.SyntaxError',\n            {code: 'invalid reverse property value', value: expandedValue});\n        }\n        _addValue(reverseMap, expandedProperty, item, {propertyIsArray: true});\n      }\n      continue;\n    }\n\n    // add value for property\n    // special keywords handled above\n    _addValue(expandedParent, expandedProperty, expandedValue, {\n      propertyIsArray: true\n    });\n  }\n\n  // @value must not be an object or an array (unless framing) or if @type is\n  // @json\n  if('@value' in expandedParent) {\n    if(expandedParent['@type'] === '@json' && _processingMode(activeCtx, 1.1)) {\n      // allow any value, to be verified when the object is fully expanded and\n      // the @type is @json.\n    } else if((_isObject(unexpandedValue) || _isArray(unexpandedValue)) &&\n      !options.isFrame) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@value\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError',\n        {code: 'invalid value object value', value: unexpandedValue});\n    }\n  }\n\n  // expand each nested key\n  for(const key of nests) {\n    const nestedValues = _isArray(element[key]) ? element[key] : [element[key]];\n    for(const nv of nestedValues) {\n      if(!_isObject(nv) || Object.keys(nv).some(k =>\n        _expandIri(activeCtx, k, {vocab: true}, options) === '@value')) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; nested value must be a node object.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @nest value', value: nv});\n      }\n      await _expandObject({\n        activeCtx,\n        activeProperty,\n        expandedActiveProperty,\n        element: nv,\n        expandedParent,\n        options,\n        insideList,\n        typeScopedContext,\n        typeKey,\n        expansionMap});\n    }\n  }\n}\n\n/**\n * Expands the given value by using the coercion and keyword rules in the\n * given context.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the active property the value is associated with.\n * @param value the value to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandValue({activeCtx, activeProperty, value, options}) {\n  // nothing to expand\n  if(value === null || value === undefined) {\n    return null;\n  }\n\n  // special-case expand @id and @type (skips '@id' expansion)\n  const expandedProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n  if(expandedProperty === '@id') {\n    return _expandIri(activeCtx, value, {base: true}, options);\n  } else if(expandedProperty === '@type') {\n    return _expandIri(activeCtx, value, {vocab: true, base: true}, options);\n  }\n\n  // get type definition from context\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  // do @id expansion (automatic for @graph)\n  if((type === '@id' || expandedProperty === '@graph') && _isString(value)) {\n    return {'@id': _expandIri(activeCtx, value, {base: true}, options)};\n  }\n  // do @id expansion w/vocab\n  if(type === '@vocab' && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {vocab: true, base: true}, options)\n    };\n  }\n\n  // do not expand keyword values\n  if(_isKeyword(expandedProperty)) {\n    return value;\n  }\n\n  const rval = {};\n\n  if(type && !['@id', '@vocab', '@none'].includes(type)) {\n    // other type\n    rval['@type'] = type;\n  } else if(_isString(value)) {\n    // check for language tagging for strings\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    if(language !== null) {\n      rval['@language'] = language;\n    }\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    if(direction !== null) {\n      rval['@direction'] = direction;\n    }\n  }\n  // do conversion of values that aren't basic JSON types to strings\n  if(!['boolean', 'number', 'string'].includes(typeof value)) {\n    value = value.toString();\n  }\n  rval['@value'] = value;\n\n  return rval;\n}\n\n/**\n * Expands a language map.\n *\n * @param activeCtx the active context to use.\n * @param languageMap the language map to expand.\n * @param direction the direction to apply to values.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded language map.\n */\nfunction _expandLanguageMap(activeCtx, languageMap, direction, options) {\n  const rval = [];\n  const keys = Object.keys(languageMap).sort();\n  for(const key of keys) {\n    const expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    let val = languageMap[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n    for(const item of val) {\n      if(item === null) {\n        // null values are allowed (8.5) but ignored (3.1)\n        continue;\n      }\n      if(!_isString(item)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; language map values must be strings.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language map value', languageMap});\n      }\n      const val = {'@value': item};\n      if(expandedKey !== '@none') {\n        val['@language'] = key.toLowerCase();\n      }\n      if(direction) {\n        val['@direction'] = direction;\n      }\n      rval.push(val);\n    }\n  }\n  return rval;\n}\n\nasync function _expandIndexMap(\n  {activeCtx, options, activeProperty, value, expansionMap, asGraph,\n    indexKey, propertyIndex}) {\n  const rval = [];\n  const keys = Object.keys(value).sort();\n  const isTypeIndex = indexKey === '@type';\n  for(let key of keys) {\n    // if indexKey is @type, there may be a context defined for it\n    if(isTypeIndex) {\n      const ctx = _getContextValue(activeCtx, key, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          propagate: false,\n          options\n        });\n      }\n    }\n\n    let val = value[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n\n    val = await api.expand({\n      activeCtx,\n      activeProperty,\n      element: val,\n      options,\n      insideList: false,\n      insideIndex: true,\n      expansionMap\n    });\n\n    // expand for @type, but also for @none\n    let expandedKey;\n    if(propertyIndex) {\n      if(key === '@none') {\n        expandedKey = '@none';\n      } else {\n        expandedKey = _expandValue(\n          {activeCtx, activeProperty: indexKey, value: key, options});\n      }\n    } else {\n      expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    }\n\n    if(indexKey === '@id') {\n      // expand document relative\n      key = _expandIri(activeCtx, key, {base: true}, options);\n    } else if(isTypeIndex) {\n      key = expandedKey;\n    }\n\n    for(let item of val) {\n      // If this is also a @graph container, turn items into graphs\n      if(asGraph && !_isGraph(item)) {\n        item = {'@graph': [item]};\n      }\n      if(indexKey === '@type') {\n        if(expandedKey === '@none') {\n          // ignore @none\n        } else if(item['@type']) {\n          item['@type'] = [key].concat(item['@type']);\n        } else {\n          item['@type'] = [key];\n        }\n      } else if(_isValue(item) &&\n        !['@language', '@type', '@index'].includes(indexKey)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; Attempt to add illegal key to value ' +\n          `object: \"${indexKey}\".`,\n          'jsonld.SyntaxError',\n          {code: 'invalid value object', value: item});\n      } else if(propertyIndex) {\n        // index is a property to be expanded, and values interpreted for that\n        // property\n        if(expandedKey !== '@none') {\n          // expand key as a value\n          _addValue(item, propertyIndex, expandedKey, {\n            propertyIsArray: true,\n            prependValue: true\n          });\n        }\n      } else if(expandedKey !== '@none' && !(indexKey in item)) {\n        item[indexKey] = key;\n      }\n      rval.push(item);\n    }\n  }\n  return rval;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/expand.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/flatten.js":
/*!********************************************!*\
  !*** ./node_modules/jsonld/lib/flatten.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {\n  isSubjectReference: _isSubjectReference\n} = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\n\nconst {\n  createMergedNodeMap: _createMergedNodeMap\n} = __webpack_require__(/*! ./nodeMap */ \"./node_modules/jsonld/lib/nodeMap.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Performs JSON-LD flattening.\n *\n * @param input the expanded JSON-LD to flatten.\n *\n * @return the flattened output.\n */\napi.flatten = input => {\n  const defaultGraph = _createMergedNodeMap(input);\n\n  // produce flattened output\n  const flattened = [];\n  const keys = Object.keys(defaultGraph).sort();\n  for(let ki = 0; ki < keys.length; ++ki) {\n    const node = defaultGraph[keys[ki]];\n    // only add full subjects to top-level\n    if(!_isSubjectReference(node)) {\n      flattened.push(node);\n    }\n  }\n  return flattened;\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/flatten.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/frame.js":
/*!******************************************!*\
  !*** ./node_modules/jsonld/lib/frame.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {isKeyword} = __webpack_require__(/*! ./context */ \"./node_modules/jsonld/lib/context.js\");\nconst graphTypes = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\nconst url = __webpack_require__(/*! ./url */ \"./node_modules/jsonld/lib/url.js\");\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\nconst {\n  createNodeMap: _createNodeMap,\n  mergeNodeMapGraphs: _mergeNodeMapGraphs\n} = __webpack_require__(/*! ./nodeMap */ \"./node_modules/jsonld/lib/nodeMap.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Performs JSON-LD `merged` framing.\n *\n * @param input the expanded JSON-LD to frame.\n * @param frame the expanded JSON-LD frame to use.\n * @param options the framing options.\n *\n * @return the framed output.\n */\napi.frameMergedOrDefault = (input, frame, options) => {\n  // create framing state\n  const state = {\n    options,\n    embedded: false,\n    graph: '@default',\n    graphMap: {'@default': {}},\n    subjectStack: [],\n    link: {},\n    bnodeMap: {}\n  };\n\n  // produce a map of all graphs and name each bnode\n  // FIXME: currently uses subjects from @merged graph only\n  const issuer = new util.IdentifierIssuer('_:b');\n  _createNodeMap(input, state.graphMap, '@default', issuer);\n  if(options.merged) {\n    state.graphMap['@merged'] = _mergeNodeMapGraphs(state.graphMap);\n    state.graph = '@merged';\n  }\n  state.subjects = state.graphMap[state.graph];\n\n  // frame the subjects\n  const framed = [];\n  api.frame(state, Object.keys(state.subjects).sort(), frame, framed);\n\n  // If pruning blank nodes, find those to prune\n  if(options.pruneBlankNodeIdentifiers) {\n    // remove all blank nodes appearing only once, done in compaction\n    options.bnodesToClear =\n      Object.keys(state.bnodeMap).filter(id => state.bnodeMap[id].length === 1);\n  }\n\n  // remove @preserve from results\n  options.link = {};\n  return _cleanupPreserve(framed, options);\n};\n\n/**\n * Frames subjects according to the given frame.\n *\n * @param state the current framing state.\n * @param subjects the subjects to filter.\n * @param frame the frame.\n * @param parent the parent subject or top-level array.\n * @param property the parent property, initialized to null.\n */\napi.frame = (state, subjects, frame, parent, property = null) => {\n  // validate the frame\n  _validateFrame(frame);\n  frame = frame[0];\n\n  // get flags for current frame\n  const options = state.options;\n  const flags = {\n    embed: _getFrameFlag(frame, options, 'embed'),\n    explicit: _getFrameFlag(frame, options, 'explicit'),\n    requireAll: _getFrameFlag(frame, options, 'requireAll')\n  };\n\n  // get link for current graph\n  if(!state.link.hasOwnProperty(state.graph)) {\n    state.link[state.graph] = {};\n  }\n  const link = state.link[state.graph];\n\n  // filter out subjects that match the frame\n  const matches = _filterSubjects(state, subjects, frame, flags);\n\n  // add matches to output\n  const ids = Object.keys(matches).sort();\n  for(const id of ids) {\n    const subject = matches[id];\n\n    /* Note: In order to treat each top-level match as a compartmentalized\n    result, clear the unique embedded subjects map when the property is null,\n    which only occurs at the top-level. */\n    if(property === null) {\n      state.uniqueEmbeds = {[state.graph]: {}};\n    } else {\n      state.uniqueEmbeds[state.graph] = state.uniqueEmbeds[state.graph] || {};\n    }\n\n    if(flags.embed === '@link' && id in link) {\n      // TODO: may want to also match an existing linked subject against\n      // the current frame ... so different frames could produce different\n      // subjects that are only shared in-memory when the frames are the same\n\n      // add existing linked subject\n      _addFrameOutput(parent, property, link[id]);\n      continue;\n    }\n\n    // start output for subject\n    const output = {'@id': id};\n    if(id.indexOf('_:') === 0) {\n      util.addValue(state.bnodeMap, id, output, {propertyIsArray: true});\n    }\n    link[id] = output;\n\n    // validate @embed\n    if((flags.embed === '@first' || flags.embed === '@last') && state.is11) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; invalid value of @embed.',\n        'jsonld.SyntaxError', {code: 'invalid @embed value', frame});\n    }\n\n    if(!state.embedded && state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {\n      // skip adding this node object to the top level, as it was\n      // already included in another node object\n      continue;\n    }\n\n    // if embed is @never or if a circular reference would be created by an\n    // embed, the subject cannot be embedded, just add the reference;\n    // note that a circular reference won't occur when the embed flag is\n    // `@link` as the above check will short-circuit before reaching this point\n    if(state.embedded &&\n      (flags.embed === '@never' ||\n      _createsCircularReference(subject, state.graph, state.subjectStack))) {\n      _addFrameOutput(parent, property, output);\n      continue;\n    }\n\n    // if only the first (or once) should be embedded\n    if(state.embedded &&\n       (flags.embed == '@first' || flags.embed == '@once') &&\n       state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {\n      _addFrameOutput(parent, property, output);\n      continue;\n    }\n\n    // if only the last match should be embedded\n    if(flags.embed === '@last') {\n      // remove any existing embed\n      if(id in state.uniqueEmbeds[state.graph]) {\n        _removeEmbed(state, id);\n      }\n    }\n\n    state.uniqueEmbeds[state.graph][id] = {parent, property};\n\n    // push matching subject onto stack to enable circular embed checks\n    state.subjectStack.push({subject, graph: state.graph});\n\n    // subject is also the name of a graph\n    if(id in state.graphMap) {\n      let recurse = false;\n      let subframe = null;\n      if(!('@graph' in frame)) {\n        recurse = state.graph !== '@merged';\n        subframe = {};\n      } else {\n        subframe = frame['@graph'][0];\n        recurse = !(id === '@merged' || id === '@default');\n        if(!types.isObject(subframe)) {\n          subframe = {};\n        }\n      }\n\n      if(recurse) {\n        // recurse into graph\n        api.frame(\n          {...state, graph: id, embedded: false},\n          Object.keys(state.graphMap[id]).sort(), [subframe], output, '@graph');\n      }\n    }\n\n    // if frame has @included, recurse over its sub-frame\n    if('@included' in frame) {\n      api.frame(\n        {...state, embedded: false},\n        subjects, frame['@included'], output, '@included');\n    }\n\n    // iterate over subject properties\n    for(const prop of Object.keys(subject).sort()) {\n      // copy keywords to output\n      if(isKeyword(prop)) {\n        output[prop] = util.clone(subject[prop]);\n\n        if(prop === '@type') {\n          // count bnode values of @type\n          for(const type of subject['@type']) {\n            if(type.indexOf('_:') === 0) {\n              util.addValue(\n                state.bnodeMap, type, output, {propertyIsArray: true});\n            }\n          }\n        }\n        continue;\n      }\n\n      // explicit is on and property isn't in the frame, skip processing\n      if(flags.explicit && !(prop in frame)) {\n        continue;\n      }\n\n      // add objects\n      for(const o of subject[prop]) {\n        const subframe = (prop in frame ?\n          frame[prop] : _createImplicitFrame(flags));\n\n        // recurse into list\n        if(graphTypes.isList(o)) {\n          const subframe =\n            (frame[prop] && frame[prop][0] && frame[prop][0]['@list']) ?\n              frame[prop][0]['@list'] :\n              _createImplicitFrame(flags);\n\n          // add empty list\n          const list = {'@list': []};\n          _addFrameOutput(output, prop, list);\n\n          // add list objects\n          const src = o['@list'];\n          for(const oo of src) {\n            if(graphTypes.isSubjectReference(oo)) {\n              // recurse into subject reference\n              api.frame(\n                {...state, embedded: true},\n                [oo['@id']], subframe, list, '@list');\n            } else {\n              // include other values automatically\n              _addFrameOutput(list, '@list', util.clone(oo));\n            }\n          }\n        } else if(graphTypes.isSubjectReference(o)) {\n          // recurse into subject reference\n          api.frame(\n            {...state, embedded: true},\n            [o['@id']], subframe, output, prop);\n        } else if(_valueMatch(subframe[0], o)) {\n          // include other values, if they match\n          _addFrameOutput(output, prop, util.clone(o));\n        }\n      }\n    }\n\n    // handle defaults\n    for(const prop of Object.keys(frame).sort()) {\n      // skip keywords\n      if(prop === '@type') {\n        if(!types.isObject(frame[prop][0]) ||\n           !('@default' in frame[prop][0])) {\n          continue;\n        }\n        // allow through default types\n      } else if(isKeyword(prop)) {\n        continue;\n      }\n\n      // if omit default is off, then include default values for properties\n      // that appear in the next frame but are not in the matching subject\n      const next = frame[prop][0] || {};\n      const omitDefaultOn = _getFrameFlag(next, options, 'omitDefault');\n      if(!omitDefaultOn && !(prop in output)) {\n        let preserve = '@null';\n        if('@default' in next) {\n          preserve = util.clone(next['@default']);\n        }\n        if(!types.isArray(preserve)) {\n          preserve = [preserve];\n        }\n        output[prop] = [{'@preserve': preserve}];\n      }\n    }\n\n    // if embed reverse values by finding nodes having this subject as a value\n    // of the associated property\n    for(const reverseProp of Object.keys(frame['@reverse'] || {}).sort()) {\n      const subframe = frame['@reverse'][reverseProp];\n      for(const subject of Object.keys(state.subjects)) {\n        const nodeValues =\n          util.getValues(state.subjects[subject], reverseProp);\n        if(nodeValues.some(v => v['@id'] === id)) {\n          // node has property referencing this subject, recurse\n          output['@reverse'] = output['@reverse'] || {};\n          util.addValue(\n            output['@reverse'], reverseProp, [], {propertyIsArray: true});\n          api.frame(\n            {...state, embedded: true},\n            [subject], subframe, output['@reverse'][reverseProp],\n            property);\n        }\n      }\n    }\n\n    // add output to parent\n    _addFrameOutput(parent, property, output);\n\n    // pop matching subject from circular ref-checking stack\n    state.subjectStack.pop();\n  }\n};\n\n/**\n * Replace `@null` with `null`, removing it from arrays.\n *\n * @param input the framed, compacted output.\n * @param options the framing options used.\n *\n * @return the resulting output.\n */\napi.cleanupNull = (input, options) => {\n  // recurse through arrays\n  if(types.isArray(input)) {\n    const noNulls = input.map(v => api.cleanupNull(v, options));\n    return noNulls.filter(v => v); // removes nulls from array\n  }\n\n  if(input === '@null') {\n    return null;\n  }\n\n  if(types.isObject(input)) {\n    // handle in-memory linked nodes\n    if('@id' in input) {\n      const id = input['@id'];\n      if(options.link.hasOwnProperty(id)) {\n        const idx = options.link[id].indexOf(input);\n        if(idx !== -1) {\n          // already visited\n          return options.link[id][idx];\n        }\n        // prevent circular visitation\n        options.link[id].push(input);\n      } else {\n        // prevent circular visitation\n        options.link[id] = [input];\n      }\n    }\n\n    for(const key in input) {\n      input[key] = api.cleanupNull(input[key], options);\n    }\n  }\n  return input;\n};\n\n/**\n * Creates an implicit frame when recursing through subject matches. If\n * a frame doesn't have an explicit frame for a particular property, then\n * a wildcard child frame will be created that uses the same flags that the\n * parent frame used.\n *\n * @param flags the current framing flags.\n *\n * @return the implicit frame.\n */\nfunction _createImplicitFrame(flags) {\n  const frame = {};\n  for(const key in flags) {\n    if(flags[key] !== undefined) {\n      frame['@' + key] = [flags[key]];\n    }\n  }\n  return [frame];\n}\n\n/**\n * Checks the current subject stack to see if embedding the given subject\n * would cause a circular reference.\n *\n * @param subjectToEmbed the subject to embed.\n * @param graph the graph the subject to embed is in.\n * @param subjectStack the current stack of subjects.\n *\n * @return true if a circular reference would be created, false if not.\n */\nfunction _createsCircularReference(subjectToEmbed, graph, subjectStack) {\n  for(let i = subjectStack.length - 1; i >= 0; --i) {\n    const subject = subjectStack[i];\n    if(subject.graph === graph &&\n      subject.subject['@id'] === subjectToEmbed['@id']) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Gets the frame flag value for the given flag name.\n *\n * @param frame the frame.\n * @param options the framing options.\n * @param name the flag name.\n *\n * @return the flag value.\n */\nfunction _getFrameFlag(frame, options, name) {\n  const flag = '@' + name;\n  let rval = (flag in frame ? frame[flag][0] : options[name]);\n  if(name === 'embed') {\n    // default is \"@last\"\n    // backwards-compatibility support for \"embed\" maps:\n    // true => \"@last\"\n    // false => \"@never\"\n    if(rval === true) {\n      rval = '@once';\n    } else if(rval === false) {\n      rval = '@never';\n    } else if(rval !== '@always' && rval !== '@never' && rval !== '@link' &&\n      rval !== '@first' && rval !== '@last' && rval !== '@once') {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; invalid value of @embed.',\n        'jsonld.SyntaxError', {code: 'invalid @embed value', frame});\n    }\n  }\n  return rval;\n}\n\n/**\n * Validates a JSON-LD frame, throwing an exception if the frame is invalid.\n *\n * @param frame the frame to validate.\n */\nfunction _validateFrame(frame) {\n  if(!types.isArray(frame) || frame.length !== 1 || !types.isObject(frame[0])) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; a JSON-LD frame must be a single object.',\n      'jsonld.SyntaxError', {frame});\n  }\n\n  if('@id' in frame[0]) {\n    for(const id of util.asArray(frame[0]['@id'])) {\n      // @id must be wildcard or an IRI\n      if(!(types.isObject(id) || url.isAbsolute(id)) ||\n        (types.isString(id) && id.indexOf('_:') === 0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; invalid @id in frame.',\n          'jsonld.SyntaxError', {code: 'invalid frame', frame});\n      }\n    }\n  }\n\n  if('@type' in frame[0]) {\n    for(const type of util.asArray(frame[0]['@type'])) {\n      // @id must be wildcard or an IRI\n      if(!(types.isObject(type) || url.isAbsolute(type)) ||\n        (types.isString(type) && type.indexOf('_:') === 0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; invalid @type in frame.',\n          'jsonld.SyntaxError', {code: 'invalid frame', frame});\n      }\n    }\n  }\n}\n\n/**\n * Returns a map of all of the subjects that match a parsed frame.\n *\n * @param state the current framing state.\n * @param subjects the set of subjects to filter.\n * @param frame the parsed frame.\n * @param flags the frame flags.\n *\n * @return all of the matched subjects.\n */\nfunction _filterSubjects(state, subjects, frame, flags) {\n  // filter subjects in @id order\n  const rval = {};\n  for(const id of subjects) {\n    const subject = state.graphMap[state.graph][id];\n    if(_filterSubject(state, subject, frame, flags)) {\n      rval[id] = subject;\n    }\n  }\n  return rval;\n}\n\n/**\n * Returns true if the given subject matches the given frame.\n *\n * Matches either based on explicit type inclusion where the node has any\n * type listed in the frame. If the frame has empty types defined matches\n * nodes not having a @type. If the frame has a type of {} defined matches\n * nodes having any type defined.\n *\n * Otherwise, does duck typing, where the node must have all of the\n * properties defined in the frame.\n *\n * @param state the current framing state.\n * @param subject the subject to check.\n * @param frame the frame to check.\n * @param flags the frame flags.\n *\n * @return true if the subject matches, false if not.\n */\nfunction _filterSubject(state, subject, frame, flags) {\n  // check ducktype\n  let wildcard = true;\n  let matchesSome = false;\n\n  for(const key in frame) {\n    let matchThis = false;\n    const nodeValues = util.getValues(subject, key);\n    const isEmpty = util.getValues(frame, key).length === 0;\n\n    if(key === '@id') {\n      // match on no @id or any matching @id, including wildcard\n      if(types.isEmptyObject(frame['@id'][0] || {})) {\n        matchThis = true;\n      } else if(frame['@id'].length >= 0) {\n        matchThis = frame['@id'].includes(nodeValues[0]);\n      }\n      if(!flags.requireAll) {\n        return matchThis;\n      }\n    } else if(key === '@type') {\n      // check @type (object value means 'any' type,\n      // fall through to ducktyping)\n      wildcard = false;\n      if(isEmpty) {\n        if(nodeValues.length > 0) {\n          // don't match on no @type\n          return false;\n        }\n        matchThis = true;\n      } else if(frame['@type'].length === 1 &&\n        types.isEmptyObject(frame['@type'][0])) {\n        // match on wildcard @type if there is a type\n        matchThis = nodeValues.length > 0;\n      } else {\n        // match on a specific @type\n        for(const type of frame['@type']) {\n          if(types.isObject(type) && '@default' in type) {\n            // match on default object\n            matchThis = true;\n          } else {\n            matchThis = matchThis || nodeValues.some(tt => tt === type);\n          }\n        }\n      }\n      if(!flags.requireAll) {\n        return matchThis;\n      }\n    } else if(isKeyword(key)) {\n      continue;\n    } else {\n      // Force a copy of this frame entry so it can be manipulated\n      const thisFrame = util.getValues(frame, key)[0];\n      let hasDefault = false;\n      if(thisFrame) {\n        _validateFrame([thisFrame]);\n        hasDefault = '@default' in thisFrame;\n      }\n\n      // no longer a wildcard pattern if frame has any non-keyword properties\n      wildcard = false;\n\n      // skip, but allow match if node has no value for property, and frame has\n      // a default value\n      if(nodeValues.length === 0 && hasDefault) {\n        continue;\n      }\n\n      // if frame value is empty, don't match if subject has any value\n      if(nodeValues.length > 0 && isEmpty) {\n        return false;\n      }\n\n      if(thisFrame === undefined) {\n        // node does not match if values is not empty and the value of property\n        // in frame is match none.\n        if(nodeValues.length > 0) {\n          return false;\n        }\n        matchThis = true;\n      } else {\n        if(graphTypes.isList(thisFrame)) {\n          const listValue = thisFrame['@list'][0];\n          if(graphTypes.isList(nodeValues[0])) {\n            const nodeListValues = nodeValues[0]['@list'];\n\n            if(graphTypes.isValue(listValue)) {\n              // match on any matching value\n              matchThis = nodeListValues.some(lv => _valueMatch(listValue, lv));\n            } else if(graphTypes.isSubject(listValue) ||\n              graphTypes.isSubjectReference(listValue)) {\n              matchThis = nodeListValues.some(lv => _nodeMatch(\n                state, listValue, lv, flags));\n            }\n          }\n        } else if(graphTypes.isValue(thisFrame)) {\n          matchThis = nodeValues.some(nv => _valueMatch(thisFrame, nv));\n        } else if(graphTypes.isSubjectReference(thisFrame)) {\n          matchThis =\n            nodeValues.some(nv => _nodeMatch(state, thisFrame, nv, flags));\n        } else if(types.isObject(thisFrame)) {\n          matchThis = nodeValues.length > 0;\n        } else {\n          matchThis = false;\n        }\n      }\n    }\n\n    // all non-defaulted values must match if requireAll is set\n    if(!matchThis && flags.requireAll) {\n      return false;\n    }\n\n    matchesSome = matchesSome || matchThis;\n  }\n\n  // return true if wildcard or subject matches some properties\n  return wildcard || matchesSome;\n}\n\n/**\n * Removes an existing embed.\n *\n * @param state the current framing state.\n * @param id the @id of the embed to remove.\n */\nfunction _removeEmbed(state, id) {\n  // get existing embed\n  const embeds = state.uniqueEmbeds[state.graph];\n  const embed = embeds[id];\n  const parent = embed.parent;\n  const property = embed.property;\n\n  // create reference to replace embed\n  const subject = {'@id': id};\n\n  // remove existing embed\n  if(types.isArray(parent)) {\n    // replace subject with reference\n    for(let i = 0; i < parent.length; ++i) {\n      if(util.compareValues(parent[i], subject)) {\n        parent[i] = subject;\n        break;\n      }\n    }\n  } else {\n    // replace subject with reference\n    const useArray = types.isArray(parent[property]);\n    util.removeValue(parent, property, subject, {propertyIsArray: useArray});\n    util.addValue(parent, property, subject, {propertyIsArray: useArray});\n  }\n\n  // recursively remove dependent dangling embeds\n  const removeDependents = id => {\n    // get embed keys as a separate array to enable deleting keys in map\n    const ids = Object.keys(embeds);\n    for(const next of ids) {\n      if(next in embeds && types.isObject(embeds[next].parent) &&\n        embeds[next].parent['@id'] === id) {\n        delete embeds[next];\n        removeDependents(next);\n      }\n    }\n  };\n  removeDependents(id);\n}\n\n/**\n * Removes the @preserve keywords from expanded result of framing.\n *\n * @param input the framed, framed output.\n * @param options the framing options used.\n *\n * @return the resulting output.\n */\nfunction _cleanupPreserve(input, options) {\n  // recurse through arrays\n  if(types.isArray(input)) {\n    return input.map(value => _cleanupPreserve(value, options));\n  }\n\n  if(types.isObject(input)) {\n    // remove @preserve\n    if('@preserve' in input) {\n      return input['@preserve'][0];\n    }\n\n    // skip @values\n    if(graphTypes.isValue(input)) {\n      return input;\n    }\n\n    // recurse through @lists\n    if(graphTypes.isList(input)) {\n      input['@list'] = _cleanupPreserve(input['@list'], options);\n      return input;\n    }\n\n    // handle in-memory linked nodes\n    if('@id' in input) {\n      const id = input['@id'];\n      if(options.link.hasOwnProperty(id)) {\n        const idx = options.link[id].indexOf(input);\n        if(idx !== -1) {\n          // already visited\n          return options.link[id][idx];\n        }\n        // prevent circular visitation\n        options.link[id].push(input);\n      } else {\n        // prevent circular visitation\n        options.link[id] = [input];\n      }\n    }\n\n    // recurse through properties\n    for(const prop in input) {\n      // potentially remove the id, if it is an unreference bnode\n      if(prop === '@id' && options.bnodesToClear.includes(input[prop])) {\n        delete input['@id'];\n        continue;\n      }\n\n      input[prop] = _cleanupPreserve(input[prop], options);\n    }\n  }\n  return input;\n}\n\n/**\n * Adds framing output to the given parent.\n *\n * @param parent the parent to add to.\n * @param property the parent property.\n * @param output the output to add.\n */\nfunction _addFrameOutput(parent, property, output) {\n  if(types.isObject(parent)) {\n    util.addValue(parent, property, output, {propertyIsArray: true});\n  } else {\n    parent.push(output);\n  }\n}\n\n/**\n * Node matches if it is a node, and matches the pattern as a frame.\n *\n * @param state the current framing state.\n * @param pattern used to match value\n * @param value to check\n * @param flags the frame flags.\n */\nfunction _nodeMatch(state, pattern, value, flags) {\n  if(!('@id' in value)) {\n    return false;\n  }\n  const nodeObject = state.subjects[value['@id']];\n  return nodeObject && _filterSubject(state, nodeObject, pattern, flags);\n}\n\n/**\n * Value matches if it is a value and matches the value pattern\n *\n * * `pattern` is empty\n * * @values are the same, or `pattern[@value]` is a wildcard, and\n * * @types are the same or `value[@type]` is not null\n *   and `pattern[@type]` is `{}`, or `value[@type]` is null\n *   and `pattern[@type]` is null or `[]`, and\n * * @languages are the same or `value[@language]` is not null\n *   and `pattern[@language]` is `{}`, or `value[@language]` is null\n *   and `pattern[@language]` is null or `[]`.\n *\n * @param pattern used to match value\n * @param value to check\n */\nfunction _valueMatch(pattern, value) {\n  const v1 = value['@value'];\n  const t1 = value['@type'];\n  const l1 = value['@language'];\n  const v2 = pattern['@value'] ?\n    (types.isArray(pattern['@value']) ?\n      pattern['@value'] : [pattern['@value']]) :\n    [];\n  const t2 = pattern['@type'] ?\n    (types.isArray(pattern['@type']) ?\n      pattern['@type'] : [pattern['@type']]) :\n    [];\n  const l2 = pattern['@language'] ?\n    (types.isArray(pattern['@language']) ?\n      pattern['@language'] : [pattern['@language']]) :\n    [];\n\n  if(v2.length === 0 && t2.length === 0 && l2.length === 0) {\n    return true;\n  }\n  if(!(v2.includes(v1) || types.isEmptyObject(v2[0]))) {\n    return false;\n  }\n  if(!(!t1 && t2.length === 0 || t2.includes(t1) || t1 &&\n    types.isEmptyObject(t2[0]))) {\n    return false;\n  }\n  if(!(!l1 && l2.length === 0 || l2.includes(l1) || l1 &&\n    types.isEmptyObject(l2[0]))) {\n    return false;\n  }\n  return true;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/frame.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/fromRdf.js":
/*!********************************************!*\
  !*** ./node_modules/jsonld/lib/fromRdf.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\nconst graphTypes = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\n\n// constants\nconst {\n  // RDF,\n  RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  // RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING,\n} = __webpack_require__(/*! ./constants */ \"./node_modules/jsonld/lib/constants.js\");\n\nconst REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset the RDF dataset.\n * @param options the RDF serialization options.\n *\n * @return a Promise that resolves to the JSON-LD output.\n */\napi.fromRDF = async (\n  dataset,\n  {\n    useRdfType = false,\n    useNativeTypes = false,\n    rdfDirection = null\n  }\n) => {\n  const defaultGraph = {};\n  const graphMap = {'@default': defaultGraph};\n  const referencedOnce = {};\n\n  for(const quad of dataset) {\n    // TODO: change 'name' to 'graph'\n    const name = (quad.graph.termType === 'DefaultGraph') ?\n      '@default' : quad.graph.value;\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n\n    const nodeMap = graphMap[name];\n\n    // get subject, predicate, object\n    const s = quad.subject.value;\n    const p = quad.predicate.value;\n    const o = quad.object;\n\n    if(!(s in nodeMap)) {\n      nodeMap[s] = {'@id': s};\n    }\n    const node = nodeMap[s];\n\n    const objectIsNode = o.termType.endsWith('Node');\n    if(objectIsNode && !(o.value in nodeMap)) {\n      nodeMap[o.value] = {'@id': o.value};\n    }\n\n    if(p === RDF_TYPE && !useRdfType && objectIsNode) {\n      util.addValue(node, '@type', o.value, {propertyIsArray: true});\n      continue;\n    }\n\n    const value = _RDFToObject(o, useNativeTypes, rdfDirection);\n    util.addValue(node, p, value, {propertyIsArray: true});\n\n    // object may be an RDF list/partial list node but we can't know easily\n    // until all triples are read\n    if(objectIsNode) {\n      if(o.value === RDF_NIL) {\n        // track rdf:nil uniquely per graph\n        const object = nodeMap[o.value];\n        if(!('usages' in object)) {\n          object.usages = [];\n        }\n        object.usages.push({\n          node,\n          property: p,\n          value\n        });\n      } else if(o.value in referencedOnce) {\n        // object referenced more than once\n        referencedOnce[o.value] = false;\n      } else {\n        // keep track of single reference\n        referencedOnce[o.value] = {\n          node,\n          property: p,\n          value\n        };\n      }\n    }\n  }\n\n  /*\n  for(let name in dataset) {\n    const graph = dataset[name];\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n    const nodeMap = graphMap[name];\n    for(let ti = 0; ti < graph.length; ++ti) {\n      const triple = graph[ti];\n\n      // get subject, predicate, object\n      const s = triple.subject.value;\n      const p = triple.predicate.value;\n      const o = triple.object;\n\n      if(!(s in nodeMap)) {\n        nodeMap[s] = {'@id': s};\n      }\n      const node = nodeMap[s];\n\n      const objectIsId = (o.type === 'IRI' || o.type === 'blank node');\n      if(objectIsId && !(o.value in nodeMap)) {\n        nodeMap[o.value] = {'@id': o.value};\n      }\n\n      if(p === RDF_TYPE && !useRdfType && objectIsId) {\n        util.addValue(node, '@type', o.value, {propertyIsArray: true});\n        continue;\n      }\n\n      const value = _RDFToObject(o, useNativeTypes);\n      util.addValue(node, p, value, {propertyIsArray: true});\n\n      // object may be an RDF list/partial list node but we can't know easily\n      // until all triples are read\n      if(objectIsId) {\n        if(o.value === RDF_NIL) {\n          // track rdf:nil uniquely per graph\n          const object = nodeMap[o.value];\n          if(!('usages' in object)) {\n            object.usages = [];\n          }\n          object.usages.push({\n            node: node,\n            property: p,\n            value: value\n          });\n        } else if(o.value in referencedOnce) {\n          // object referenced more than once\n          referencedOnce[o.value] = false;\n        } else {\n          // keep track of single reference\n          referencedOnce[o.value] = {\n            node: node,\n            property: p,\n            value: value\n          };\n        }\n      }\n    }\n  }*/\n\n  // convert linked lists to @list arrays\n  for(const name in graphMap) {\n    const graphObject = graphMap[name];\n\n    // no @lists to be converted, continue\n    if(!(RDF_NIL in graphObject)) {\n      continue;\n    }\n\n    // iterate backwards through each RDF list\n    const nil = graphObject[RDF_NIL];\n    if(!nil.usages) {\n      continue;\n    }\n    for(let usage of nil.usages) {\n      let node = usage.node;\n      let property = usage.property;\n      let head = usage.value;\n      const list = [];\n      const listNodes = [];\n\n      // ensure node is a well-formed list node; it must:\n      // 1. Be referenced only once.\n      // 2. Have an array for rdf:first that has 1 item.\n      // 3. Have an array for rdf:rest that has 1 item.\n      // 4. Have no keys other than: @id, rdf:first, rdf:rest, and,\n      //   optionally, @type where the value is rdf:List.\n      let nodeKeyCount = Object.keys(node).length;\n      while(property === RDF_REST &&\n        types.isObject(referencedOnce[node['@id']]) &&\n        types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 &&\n        types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 &&\n        (nodeKeyCount === 3 ||\n          (nodeKeyCount === 4 && types.isArray(node['@type']) &&\n          node['@type'].length === 1 && node['@type'][0] === RDF_LIST))) {\n        list.push(node[RDF_FIRST][0]);\n        listNodes.push(node['@id']);\n\n        // get next node, moving backwards through list\n        usage = referencedOnce[node['@id']];\n        node = usage.node;\n        property = usage.property;\n        head = usage.value;\n        nodeKeyCount = Object.keys(node).length;\n\n        // if node is not a blank node, then list head found\n        if(!graphTypes.isBlankNode(node)) {\n          break;\n        }\n      }\n\n      // transform list into @list object\n      delete head['@id'];\n      head['@list'] = list.reverse();\n      for(const listNode of listNodes) {\n        delete graphObject[listNode];\n      }\n    }\n\n    delete nil.usages;\n  }\n\n  const result = [];\n  const subjects = Object.keys(defaultGraph).sort();\n  for(const subject of subjects) {\n    const node = defaultGraph[subject];\n    if(subject in graphMap) {\n      const graph = node['@graph'] = [];\n      const graphObject = graphMap[subject];\n      const graphSubjects = Object.keys(graphObject).sort();\n      for(const graphSubject of graphSubjects) {\n        const node = graphObject[graphSubject];\n        // only add full subjects to top-level\n        if(!graphTypes.isSubjectReference(node)) {\n          graph.push(node);\n        }\n      }\n    }\n    // only add full subjects to top-level\n    if(!graphTypes.isSubjectReference(node)) {\n      result.push(node);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Converts an RDF triple object to a JSON-LD object.\n *\n * @param o the RDF triple object to convert.\n * @param useNativeTypes true to output native types, false not to.\n *\n * @return the JSON-LD object.\n */\nfunction _RDFToObject(o, useNativeTypes, rdfDirection) {\n  // convert NamedNode/BlankNode object to JSON-LD\n  if(o.termType.endsWith('Node')) {\n    return {'@id': o.value};\n  }\n\n  // convert literal to JSON-LD\n  const rval = {'@value': o.value};\n\n  // add language\n  if(o.language) {\n    rval['@language'] = o.language;\n  } else {\n    let type = o.datatype.value;\n    if(!type) {\n      type = XSD_STRING;\n    }\n    if(type === RDF_JSON_LITERAL) {\n      type = '@json';\n      try {\n        rval['@value'] = JSON.parse(rval['@value']);\n      } catch(e) {\n        throw new JsonLdError(\n          'JSON literal could not be parsed.',\n          'jsonld.InvalidJsonLiteral',\n          {code: 'invalid JSON literal', value: rval['@value'], cause: e});\n      }\n    }\n    // use native types for certain xsd types\n    if(useNativeTypes) {\n      if(type === XSD_BOOLEAN) {\n        if(rval['@value'] === 'true') {\n          rval['@value'] = true;\n        } else if(rval['@value'] === 'false') {\n          rval['@value'] = false;\n        }\n      } else if(types.isNumeric(rval['@value'])) {\n        if(type === XSD_INTEGER) {\n          const i = parseInt(rval['@value'], 10);\n          if(i.toFixed(0) === rval['@value']) {\n            rval['@value'] = i;\n          }\n        } else if(type === XSD_DOUBLE) {\n          rval['@value'] = parseFloat(rval['@value']);\n        }\n      }\n      // do not add native type\n      if(![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {\n        rval['@type'] = type;\n      }\n    } else if(rdfDirection === 'i18n-datatype' &&\n      type.startsWith('https://www.w3.org/ns/i18n#')) {\n      const [, language, direction] = type.split(/[#_]/);\n      if(language.length > 0) {\n        rval['@language'] = language;\n        if(!language.match(REGEX_BCP47)) {\n          console.warn(`@language must be valid BCP47: ${language}`);\n        }\n      }\n      rval['@direction'] = direction;\n    } else if(type !== XSD_STRING) {\n      rval['@type'] = type;\n    }\n  }\n\n  return rval;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/fromRdf.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/graphTypes.js":
/*!***********************************************!*\
  !*** ./node_modules/jsonld/lib/graphTypes.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Returns true if the given value is a subject with properties.\n *\n * @param v the value to check.\n *\n * @return true if the value is a subject with properties, false if not.\n */\napi.isSubject = v => {\n  // Note: A value is a subject if all of these hold true:\n  // 1. It is an Object.\n  // 2. It is not a @value, @set, or @list.\n  // 3. It has more than 1 key OR any existing key is not @id.\n  if(types.isObject(v) &&\n    !(('@value' in v) || ('@set' in v) || ('@list' in v))) {\n    const keyCount = Object.keys(v).length;\n    return (keyCount > 1 || !('@id' in v));\n  }\n  return false;\n};\n\n/**\n * Returns true if the given value is a subject reference.\n *\n * @param v the value to check.\n *\n * @return true if the value is a subject reference, false if not.\n */\napi.isSubjectReference = v =>\n  // Note: A value is a subject reference if all of these hold true:\n  // 1. It is an Object.\n  // 2. It has a single key: @id.\n  (types.isObject(v) && Object.keys(v).length === 1 && ('@id' in v));\n\n/**\n * Returns true if the given value is a @value.\n *\n * @param v the value to check.\n *\n * @return true if the value is a @value, false if not.\n */\napi.isValue = v =>\n  // Note: A value is a @value if all of these hold true:\n  // 1. It is an Object.\n  // 2. It has the @value property.\n  types.isObject(v) && ('@value' in v);\n\n/**\n * Returns true if the given value is a @list.\n *\n * @param v the value to check.\n *\n * @return true if the value is a @list, false if not.\n */\napi.isList = v =>\n  // Note: A value is a @list if all of these hold true:\n  // 1. It is an Object.\n  // 2. It has the @list property.\n  types.isObject(v) && ('@list' in v);\n\n/**\n * Returns true if the given value is a @graph.\n *\n * @return true if the value is a @graph, false if not.\n */\napi.isGraph = v => {\n  // Note: A value is a graph if all of these hold true:\n  // 1. It is an object.\n  // 2. It has an `@graph` key.\n  // 3. It may have '@id' or '@index'\n  return types.isObject(v) &&\n    '@graph' in v &&\n    Object.keys(v)\n      .filter(key => key !== '@id' && key !== '@index').length === 1;\n};\n\n/**\n * Returns true if the given value is a simple @graph.\n *\n * @return true if the value is a simple @graph, false if not.\n */\napi.isSimpleGraph = v => {\n  // Note: A value is a simple graph if all of these hold true:\n  // 1. It is an object.\n  // 2. It has an `@graph` key.\n  // 3. It has only 1 key or 2 keys where one of them is `@index`.\n  return api.isGraph(v) && !('@id' in v);\n};\n\n/**\n * Returns true if the given value is a blank node.\n *\n * @param v the value to check.\n *\n * @return true if the value is a blank node, false if not.\n */\napi.isBlankNode = v => {\n  // Note: A value is a blank node if all of these hold true:\n  // 1. It is an Object.\n  // 2. If it has an @id key its value begins with '_:'.\n  // 3. It has no keys OR is not a @value, @set, or @list.\n  if(types.isObject(v)) {\n    if('@id' in v) {\n      return (v['@id'].indexOf('_:') === 0);\n    }\n    return (Object.keys(v).length === 0 ||\n      !(('@value' in v) || ('@set' in v) || ('@list' in v)));\n  }\n  return false;\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/graphTypes.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/jsonld.js":
/*!*******************************************!*\
  !*** ./node_modules/jsonld/lib/jsonld.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * A JavaScript implementation of the JSON-LD API.\n *\n * @author Dave Longley\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2011-2019 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nconst canonize = __webpack_require__(/*! rdf-canonize */ \"./node_modules/rdf-canonize/index.js\");\nconst platform = __webpack_require__(/*! ./platform */ \"./node_modules/jsonld/lib/platform-browser.js\");\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\nconst ContextResolver = __webpack_require__(/*! ./ContextResolver */ \"./node_modules/jsonld/lib/ContextResolver.js\");\nconst IdentifierIssuer = util.IdentifierIssuer;\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\nconst LRU = __webpack_require__(/*! lru-cache */ \"./node_modules/lru-cache/index.js\");\nconst NQuads = __webpack_require__(/*! ./NQuads */ \"./node_modules/jsonld/lib/NQuads.js\");\n\nconst {expand: _expand} = __webpack_require__(/*! ./expand */ \"./node_modules/jsonld/lib/expand.js\");\nconst {flatten: _flatten} = __webpack_require__(/*! ./flatten */ \"./node_modules/jsonld/lib/flatten.js\");\nconst {fromRDF: _fromRDF} = __webpack_require__(/*! ./fromRdf */ \"./node_modules/jsonld/lib/fromRdf.js\");\nconst {toRDF: _toRDF} = __webpack_require__(/*! ./toRdf */ \"./node_modules/jsonld/lib/toRdf.js\");\n\nconst {\n  frameMergedOrDefault: _frameMergedOrDefault,\n  cleanupNull: _cleanupNull\n} = __webpack_require__(/*! ./frame */ \"./node_modules/jsonld/lib/frame.js\");\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString\n} = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n\nconst {\n  isSubjectReference: _isSubjectReference,\n} = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\n\nconst {\n  expandIri: _expandIri,\n  getInitialContext: _getInitialContext,\n  process: _processContext,\n  processingMode: _processingMode\n} = __webpack_require__(/*! ./context */ \"./node_modules/jsonld/lib/context.js\");\n\nconst {\n  compact: _compact,\n  compactIri: _compactIri\n} = __webpack_require__(/*! ./compact */ \"./node_modules/jsonld/lib/compact.js\");\n\nconst {\n  createNodeMap: _createNodeMap,\n  createMergedNodeMap: _createMergedNodeMap,\n  mergeNodeMaps: _mergeNodeMaps\n} = __webpack_require__(/*! ./nodeMap */ \"./node_modules/jsonld/lib/nodeMap.js\");\n\n/* eslint-disable indent */\n// attaches jsonld API to the given object\nconst wrapper = function(jsonld) {\n\n/** Registered RDF dataset parsers hashed by content-type. */\nconst _rdfParsers = {};\n\n// resolved context cache\n// TODO: consider basing max on context size rather than number\nconst RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;\nconst _resolvedContextCache = new LRU({max: RESOLVED_CONTEXT_CACHE_MAX_SIZE});\n\n/* Core API */\n\n/**\n * Performs JSON-LD compaction.\n *\n * @param input the JSON-LD input to compact.\n * @param ctx the context to compact with.\n * @param [options] options to use:\n *          [base] the base IRI to use.\n *          [compactArrays] true to compact arrays to single values when\n *            appropriate, false not to (default: true).\n *          [compactToRelative] true to compact IRIs to be relative to document\n *            base, false to keep absolute (default: true)\n *          [graph] true to always output a top-level graph (default: false).\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false.\n *          [documentLoader(url, options)] the document loader.\n *          [expansionMap(info)] a function that can be used to custom map\n *            unmappable values (or to throw an error when they are detected);\n *            if this function returns `undefined` then the default behavior\n *            will be used.\n *          [framing] true if compaction is occuring during a framing operation.\n *          [compactionMap(info)] a function that can be used to custom map\n *            unmappable values (or to throw an error when they are detected);\n *            if this function returns `undefined` then the default behavior\n *            will be used.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the compacted output.\n */\njsonld.compact = async function(input, ctx, options) {\n  if(arguments.length < 2) {\n    throw new TypeError('Could not compact, too few arguments.');\n  }\n\n  if(ctx === null) {\n    throw new JsonLdError(\n      'The compaction context must not be null.',\n      'jsonld.CompactError', {code: 'invalid local context'});\n  }\n\n  // nothing to compact\n  if(input === null) {\n    return null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    compactArrays: true,\n    compactToRelative: true,\n    graph: false,\n    skipExpansion: false,\n    link: false,\n    issuer: new IdentifierIssuer('_:b'),\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if(options.link) {\n    // force skip expansion when linking, \"link\" is not part of the public\n    // API, it should only be called from framing\n    options.skipExpansion = true;\n  }\n  if(!options.compactToRelative) {\n    delete options.base;\n  }\n\n  // expand input\n  let expanded;\n  if(options.skipExpansion) {\n    expanded = input;\n  } else {\n    expanded = await jsonld.expand(input, options);\n  }\n\n  // process context\n  const activeCtx = await jsonld.processContext(\n    _getInitialContext(options), ctx, options);\n\n  // do compaction\n  let compacted = await _compact({\n    activeCtx,\n    element: expanded,\n    options,\n    compactionMap: options.compactionMap\n  });\n\n  // perform clean up\n  if(options.compactArrays && !options.graph && _isArray(compacted)) {\n    if(compacted.length === 1) {\n      // simplify to a single item\n      compacted = compacted[0];\n    } else if(compacted.length === 0) {\n      // simplify to an empty object\n      compacted = {};\n    }\n  } else if(options.graph && _isObject(compacted)) {\n    // always use array if graph option is on\n    compacted = [compacted];\n  }\n\n  // follow @context key\n  if(_isObject(ctx) && '@context' in ctx) {\n    ctx = ctx['@context'];\n  }\n\n  // build output context\n  ctx = util.clone(ctx);\n  if(!_isArray(ctx)) {\n    ctx = [ctx];\n  }\n  // remove empty contexts\n  const tmp = ctx;\n  ctx = [];\n  for(let i = 0; i < tmp.length; ++i) {\n    if(!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {\n      ctx.push(tmp[i]);\n    }\n  }\n\n  // remove array if only one context\n  const hasContext = (ctx.length > 0);\n  if(ctx.length === 1) {\n    ctx = ctx[0];\n  }\n\n  // add context and/or @graph\n  if(_isArray(compacted)) {\n    // use '@graph' keyword\n    const graphAlias = _compactIri({\n      activeCtx, iri: '@graph', relativeTo: {vocab: true}\n    });\n    const graph = compacted;\n    compacted = {};\n    if(hasContext) {\n      compacted['@context'] = ctx;\n    }\n    compacted[graphAlias] = graph;\n  } else if(_isObject(compacted) && hasContext) {\n    // reorder keys so @context is first\n    const graph = compacted;\n    compacted = {'@context': ctx};\n    for(const key in graph) {\n      compacted[key] = graph[key];\n    }\n  }\n\n  return compacted;\n};\n\n/**\n * Performs JSON-LD expansion.\n *\n * @param input the JSON-LD input to expand.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [keepFreeFloatingNodes] true to keep free-floating nodes,\n *            false not to, defaults to false.\n *          [documentLoader(url, options)] the document loader.\n *          [expansionMap(info)] a function that can be used to custom map\n *            unmappable values (or to throw an error when they are detected);\n *            if this function returns `undefined` then the default behavior\n *            will be used.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the expanded output.\n */\njsonld.expand = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not expand, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    keepFreeFloatingNodes: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if(options.expansionMap === false) {\n    options.expansionMap = undefined;\n  }\n\n  // build set of objects that may have @contexts to resolve\n  const toResolve = {};\n\n  // build set of contexts to process prior to expansion\n  const contextsToProcess = [];\n\n  // if an `expandContext` has been given ensure it gets resolved\n  if('expandContext' in options) {\n    const expandContext = util.clone(options.expandContext);\n    if(_isObject(expandContext) && '@context' in expandContext) {\n      toResolve.expandContext = expandContext;\n    } else {\n      toResolve.expandContext = {'@context': expandContext};\n    }\n    contextsToProcess.push(toResolve.expandContext);\n  }\n\n  // if input is a string, attempt to dereference remote document\n  let defaultBase;\n  if(!_isString(input)) {\n    // input is not a URL, do not need to retrieve it first\n    toResolve.input = util.clone(input);\n  } else {\n    // load remote doc\n    const remoteDoc = await jsonld.get(input, options);\n    defaultBase = remoteDoc.documentUrl;\n    toResolve.input = remoteDoc.document;\n    if(remoteDoc.contextUrl) {\n      // context included in HTTP link header and must be resolved\n      toResolve.remoteContext = {'@context': remoteDoc.contextUrl};\n      contextsToProcess.push(toResolve.remoteContext);\n    }\n  }\n\n  // set default base\n  if(!('base' in options)) {\n    options.base = defaultBase || '';\n  }\n\n  // process any additional contexts\n  let activeCtx = _getInitialContext(options);\n  for(const localCtx of contextsToProcess) {\n    activeCtx = await _processContext({activeCtx, localCtx, options});\n  }\n\n  // expand resolved input\n  let expanded = await _expand({\n    activeCtx,\n    element: toResolve.input,\n    options,\n    expansionMap: options.expansionMap\n  });\n\n  // optimize away @graph with no other properties\n  if(_isObject(expanded) && ('@graph' in expanded) &&\n    Object.keys(expanded).length === 1) {\n    expanded = expanded['@graph'];\n  } else if(expanded === null) {\n    expanded = [];\n  }\n\n  // normalize to an array\n  if(!_isArray(expanded)) {\n    expanded = [expanded];\n  }\n\n  return expanded;\n};\n\n/**\n * Performs JSON-LD flattening.\n *\n * @param input the JSON-LD to flatten.\n * @param ctx the context to use to compact the flattened output, or null.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the flattened output.\n */\njsonld.flatten = async function(input, ctx, options) {\n  if(arguments.length < 1) {\n    return new TypeError('Could not flatten, too few arguments.');\n  }\n\n  if(typeof ctx === 'function') {\n    ctx = null;\n  } else {\n    ctx = ctx || null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  // do flattening\n  const flattened = _flatten(expanded);\n\n  if(ctx === null) {\n    // no compaction required\n    return flattened;\n  }\n\n  // compact result (force @graph option to true, skip expansion)\n  options.graph = true;\n  options.skipExpansion = true;\n  const compacted = await jsonld.compact(flattened, ctx, options);\n\n  return compacted;\n};\n\n/**\n * Performs JSON-LD framing.\n *\n * @param input the JSON-LD input to frame.\n * @param frame the JSON-LD frame to use.\n * @param [options] the framing options.\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [embed] default @embed flag: '@last', '@always', '@never', '@link'\n *            (default: '@last').\n *          [explicit] default @explicit flag (default: false).\n *          [requireAll] default @requireAll flag (default: true).\n *          [omitDefault] default @omitDefault flag (default: false).\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the framed output.\n */\njsonld.frame = async function(input, frame, options) {\n  if(arguments.length < 2) {\n    throw new TypeError('Could not frame, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    embed: '@once',\n    explicit: false,\n    requireAll: false,\n    omitDefault: false,\n    bnodesToClear: [],\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // if frame is a string, attempt to dereference remote document\n  if(_isString(frame)) {\n    // load remote doc\n    const remoteDoc = await jsonld.get(frame, options);\n    frame = remoteDoc.document;\n\n    if(remoteDoc.contextUrl) {\n      // inject link header @context into frame\n      let ctx = frame['@context'];\n      if(!ctx) {\n        ctx = remoteDoc.contextUrl;\n      } else if(_isArray(ctx)) {\n        ctx.push(remoteDoc.contextUrl);\n      } else {\n        ctx = [ctx, remoteDoc.contextUrl];\n      }\n      frame['@context'] = ctx;\n    }\n  }\n\n  const frameContext = frame ? frame['@context'] || {} : {};\n\n  // process context\n  const activeCtx = await jsonld.processContext(\n    _getInitialContext(options), frameContext, options);\n\n  // mode specific defaults\n  if(!options.hasOwnProperty('omitGraph')) {\n    options.omitGraph = _processingMode(activeCtx, 1.1);\n  }\n  if(!options.hasOwnProperty('pruneBlankNodeIdentifiers')) {\n    options.pruneBlankNodeIdentifiers = _processingMode(activeCtx, 1.1);\n  }\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  // expand frame\n  const opts = {...options};\n  opts.isFrame = true;\n  opts.keepFreeFloatingNodes = true;\n  const expandedFrame = await jsonld.expand(frame, opts);\n\n  // if the unexpanded frame includes a key expanding to @graph, frame the\n  // default graph, otherwise, the merged graph\n  const frameKeys = Object.keys(frame)\n    .map(key => _expandIri(activeCtx, key, {vocab: true}));\n  opts.merged = !frameKeys.includes('@graph');\n  opts.is11 = _processingMode(activeCtx, 1.1);\n\n  // do framing\n  const framed = _frameMergedOrDefault(expanded, expandedFrame, opts);\n\n  opts.graph = !options.omitGraph;\n  opts.skipExpansion = true;\n  opts.link = {};\n  opts.framing = true;\n  let compacted = await jsonld.compact(framed, frameContext, opts);\n\n  // replace @null with null, compacting arrays\n  opts.link = {};\n  compacted = _cleanupNull(compacted, opts);\n\n  return compacted;\n};\n\n/**\n * **Experimental**\n *\n * Links a JSON-LD document's nodes in memory.\n *\n * @param input the JSON-LD document to link.\n * @param [ctx] the JSON-LD context to apply.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the linked output.\n */\njsonld.link = async function(input, ctx, options) {\n  // API matches running frame with a wildcard frame and embed: '@link'\n  // get arguments\n  const frame = {};\n  if(ctx) {\n    frame['@context'] = ctx;\n  }\n  frame['@embed'] = '@link';\n  return jsonld.frame(input, frame, options);\n};\n\n/**\n * Performs RDF dataset normalization on the given input. The input is JSON-LD\n * unless the 'inputFormat' option is used. The output is an RDF dataset\n * unless the 'format' option is used.\n *\n * @param input the input to normalize as JSON-LD or as a format specified by\n *          the 'inputFormat' option.\n * @param [options] the options to use:\n *          [algorithm] the normalization algorithm to use, `URDNA2015` or\n *            `URGNA2012` (default: `URDNA2015`).\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false.\n *          [inputFormat] the format if input is not JSON-LD:\n *            'application/n-quads' for N-Quads.\n *          [format] the format if output is a string:\n *            'application/n-quads' for N-Quads.\n *          [documentLoader(url, options)] the document loader.\n *          [useNative] true to use a native canonize algorithm\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the normalized output.\n */\njsonld.normalize = jsonld.canonize = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not canonize, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    algorithm: 'URDNA2015',\n    skipExpansion: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if('inputFormat' in options) {\n    if(options.inputFormat !== 'application/n-quads' &&\n      options.inputFormat !== 'application/nquads') {\n      throw new JsonLdError(\n        'Unknown canonicalization input format.',\n        'jsonld.CanonizeError');\n    }\n    // TODO: `await` for async parsers\n    const parsedInput = NQuads.parse(input);\n\n    // do canonicalization\n    return canonize.canonize(parsedInput, options);\n  }\n\n  // convert to RDF dataset then do normalization\n  const opts = {...options};\n  delete opts.format;\n  opts.produceGeneralizedRdf = false;\n  const dataset = await jsonld.toRDF(input, opts);\n\n  // do canonicalization\n  return canonize.canonize(dataset, options);\n};\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset a serialized string of RDF in a format specified by the\n *          format option or an RDF dataset to convert.\n * @param [options] the options to use:\n *          [format] the format if dataset param must first be parsed:\n *            'application/n-quads' for N-Quads (default).\n *          [rdfParser] a custom RDF-parser to use to parse the dataset.\n *          [useRdfType] true to use rdf:type, false to use @type\n *            (default: false).\n *          [useNativeTypes] true to convert XSD types into native types\n *            (boolean, integer, double), false not to (default: false).\n *\n * @return a Promise that resolves to the JSON-LD document.\n */\njsonld.fromRDF = async function(dataset, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not convert from RDF, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    format: _isString(dataset) ? 'application/n-quads' : undefined\n  });\n\n  const {format} = options;\n  let {rdfParser} = options;\n\n  // handle special format\n  if(format) {\n    // check supported formats\n    rdfParser = rdfParser || _rdfParsers[format];\n    if(!rdfParser) {\n      throw new JsonLdError(\n        'Unknown input format.',\n        'jsonld.UnknownFormat', {format});\n    }\n  } else {\n    // no-op parser, assume dataset already parsed\n    rdfParser = () => dataset;\n  }\n\n  // rdfParser must be synchronous or return a promise, no callback support\n  const parsedDataset = await rdfParser(dataset);\n  return _fromRDF(parsedDataset, options);\n};\n\n/**\n * Outputs the RDF dataset found in the given JSON-LD object.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false.\n *          [format] the format to use to output a string:\n *            'application/n-quads' for N-Quads.\n *          [produceGeneralizedRdf] true to output generalized RDF, false\n *            to produce only standard RDF (default: false).\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the RDF dataset.\n */\njsonld.toRDF = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not convert to RDF, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    skipExpansion: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // TODO: support toRDF custom map?\n  let expanded;\n  if(options.skipExpansion) {\n    expanded = input;\n  } else {\n    // expand input\n    expanded = await jsonld.expand(input, options);\n  }\n\n  // output RDF dataset\n  const dataset = _toRDF(expanded, options);\n  if(options.format) {\n    if(options.format === 'application/n-quads' ||\n      options.format === 'application/nquads') {\n      return NQuads.serialize(dataset);\n    }\n    throw new JsonLdError(\n      'Unknown output format.',\n      'jsonld.UnknownFormat', {format: options.format});\n  }\n\n  return dataset;\n};\n\n/**\n * **Experimental**\n *\n * Recursively flattens the nodes in the given JSON-LD input into a merged\n * map of node ID => node. All graphs will be merged into the default graph.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the merged node map.\n */\njsonld.createNodeMap = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not create node map, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  return _createMergedNodeMap(expanded, options);\n};\n\n/**\n * **Experimental**\n *\n * Merges two or more JSON-LD documents into a single flattened document.\n *\n * @param docs the JSON-LD documents to merge together.\n * @param ctx the context to use to compact the merged result, or null.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *          [mergeNodes] true to merge properties for nodes with the same ID,\n *            false to ignore new properties for nodes with the same ID once\n *            the ID has been defined; note that this may not prevent merging\n *            new properties where a node is in the `object` position\n *            (default: true).\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the merged output.\n */\njsonld.merge = async function(docs, ctx, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not merge, too few arguments.');\n  }\n  if(!_isArray(docs)) {\n    throw new TypeError('Could not merge, \"docs\" must be an array.');\n  }\n\n  if(typeof ctx === 'function') {\n    ctx = null;\n  } else {\n    ctx = ctx || null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand all documents\n  const expanded = await Promise.all(docs.map(doc => {\n    const opts = {...options};\n    return jsonld.expand(doc, opts);\n  }));\n\n  let mergeNodes = true;\n  if('mergeNodes' in options) {\n    mergeNodes = options.mergeNodes;\n  }\n\n  const issuer = options.issuer || new IdentifierIssuer('_:b');\n  const graphs = {'@default': {}};\n\n  for(let i = 0; i < expanded.length; ++i) {\n    // uniquely relabel blank nodes\n    const doc = util.relabelBlankNodes(expanded[i], {\n      issuer: new IdentifierIssuer('_:b' + i + '-')\n    });\n\n    // add nodes to the shared node map graphs if merging nodes, to a\n    // separate graph set if not\n    const _graphs = (mergeNodes || i === 0) ? graphs : {'@default': {}};\n    _createNodeMap(doc, _graphs, '@default', issuer);\n\n    if(_graphs !== graphs) {\n      // merge document graphs but don't merge existing nodes\n      for(const graphName in _graphs) {\n        const _nodeMap = _graphs[graphName];\n        if(!(graphName in graphs)) {\n          graphs[graphName] = _nodeMap;\n          continue;\n        }\n        const nodeMap = graphs[graphName];\n        for(const key in _nodeMap) {\n          if(!(key in nodeMap)) {\n            nodeMap[key] = _nodeMap[key];\n          }\n        }\n      }\n    }\n  }\n\n  // add all non-default graphs to default graph\n  const defaultGraph = _mergeNodeMaps(graphs);\n\n  // produce flattened output\n  const flattened = [];\n  const keys = Object.keys(defaultGraph).sort();\n  for(let ki = 0; ki < keys.length; ++ki) {\n    const node = defaultGraph[keys[ki]];\n    // only add full subjects to top-level\n    if(!_isSubjectReference(node)) {\n      flattened.push(node);\n    }\n  }\n\n  if(ctx === null) {\n    return flattened;\n  }\n\n  // compact result (force @graph option to true, skip expansion)\n  options.graph = true;\n  options.skipExpansion = true;\n  const compacted = await jsonld.compact(flattened, ctx, options);\n\n  return compacted;\n};\n\n/**\n * The default document loader for external documents.\n *\n * @param url the URL to load.\n *\n * @return a promise that resolves to the remote document.\n */\nObject.defineProperty(jsonld, 'documentLoader', {\n  get: () => jsonld._documentLoader,\n  set: v => jsonld._documentLoader = v\n});\n// default document loader not implemented\njsonld.documentLoader = async url => {\n  throw new JsonLdError(\n    'Could not retrieve a JSON-LD document from the URL. URL ' +\n    'dereferencing not implemented.', 'jsonld.LoadDocumentError',\n    {code: 'loading document failed', url});\n};\n\n/**\n * Gets a remote JSON-LD document using the default document loader or\n * one given in the passed options.\n *\n * @param url the URL to fetch.\n * @param [options] the options to use:\n *          [documentLoader] the document loader to use.\n *\n * @return a Promise that resolves to the retrieved remote document.\n */\njsonld.get = async function(url, options) {\n  let load;\n  if(typeof options.documentLoader === 'function') {\n    load = options.documentLoader;\n  } else {\n    load = jsonld.documentLoader;\n  }\n\n  const remoteDoc = await load(url);\n\n  try {\n    if(!remoteDoc.document) {\n      throw new JsonLdError(\n        'No remote document found at the given URL.',\n        'jsonld.NullRemoteDocument');\n    }\n    if(_isString(remoteDoc.document)) {\n      remoteDoc.document = JSON.parse(remoteDoc.document);\n    }\n  } catch(e) {\n    throw new JsonLdError(\n      'Could not retrieve a JSON-LD document from the URL.',\n      'jsonld.LoadDocumentError', {\n        code: 'loading document failed',\n        cause: e,\n        remoteDoc\n      });\n  }\n\n  return remoteDoc;\n};\n\n/**\n * Processes a local context, resolving any URLs as necessary, and returns a\n * new active context.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param [options] the options to use:\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the new active context.\n */\njsonld.processContext = async function(\n  activeCtx, localCtx, options) {\n  // set default options\n  options = _setDefaults(options, {\n    base: '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // return initial context early for null context\n  if(localCtx === null) {\n    return _getInitialContext(options);\n  }\n\n  // get URLs in localCtx\n  localCtx = util.clone(localCtx);\n  if(!(_isObject(localCtx) && '@context' in localCtx)) {\n    localCtx = {'@context': localCtx};\n  }\n\n  return _processContext({activeCtx, localCtx, options});\n};\n\n// backwards compatibility\njsonld.getContextValue = (__webpack_require__(/*! ./context */ \"./node_modules/jsonld/lib/context.js\").getContextValue);\n\n/**\n * Document loaders.\n */\njsonld.documentLoaders = {};\n\n/**\n * Assigns the default document loader for external document URLs to a built-in\n * default. Supported types currently include: 'xhr' and 'node'.\n *\n * @param type the type to set.\n * @param [params] the parameters required to use the document loader.\n */\njsonld.useDocumentLoader = function(type) {\n  if(!(type in jsonld.documentLoaders)) {\n    throw new JsonLdError(\n      'Unknown document loader type: \"' + type + '\"',\n      'jsonld.UnknownDocumentLoader',\n      {type});\n  }\n\n  // set document loader\n  jsonld.documentLoader = jsonld.documentLoaders[type].apply(\n    jsonld, Array.prototype.slice.call(arguments, 1));\n};\n\n/**\n * Registers an RDF dataset parser by content-type, for use with\n * jsonld.fromRDF. An RDF dataset parser will always be given one parameter,\n * a string of input. An RDF dataset parser can be synchronous or\n * asynchronous (by returning a promise).\n *\n * @param contentType the content-type for the parser.\n * @param parser(input) the parser function (takes a string as a parameter\n *          and either returns an RDF dataset or a Promise that resolves to one.\n */\njsonld.registerRDFParser = function(contentType, parser) {\n  _rdfParsers[contentType] = parser;\n};\n\n/**\n * Unregisters an RDF dataset parser by content-type.\n *\n * @param contentType the content-type for the parser.\n */\njsonld.unregisterRDFParser = function(contentType) {\n  delete _rdfParsers[contentType];\n};\n\n// register the N-Quads RDF parser\njsonld.registerRDFParser('application/n-quads', NQuads.parse);\njsonld.registerRDFParser('application/nquads', NQuads.parse);\n\n/* URL API */\njsonld.url = __webpack_require__(/*! ./url */ \"./node_modules/jsonld/lib/url.js\");\n\n/* Utility API */\njsonld.util = util;\n// backwards compatibility\nObject.assign(jsonld, util);\n\n// reexpose API as jsonld.promises for backwards compatability\njsonld.promises = jsonld;\n\n// backwards compatibility\njsonld.RequestQueue = __webpack_require__(/*! ./RequestQueue */ \"./node_modules/jsonld/lib/RequestQueue.js\");\n\n/* WebIDL API */\njsonld.JsonLdProcessor = __webpack_require__(/*! ./JsonLdProcessor */ \"./node_modules/jsonld/lib/JsonLdProcessor.js\")(jsonld);\n\nplatform.setupGlobals(jsonld);\nplatform.setupDocumentLoaders(jsonld);\n\nfunction _setDefaults(options, {\n  documentLoader = jsonld.documentLoader,\n  ...defaults\n}) {\n  return Object.assign({}, {documentLoader}, defaults, options);\n}\n\n// end of jsonld API `wrapper` factory\nreturn jsonld;\n};\n\n// external APIs:\n\n// used to generate a new jsonld API instance\nconst factory = function() {\n  return wrapper(function() {\n    return factory();\n  });\n};\n\n// wrap the main jsonld API instance\nwrapper(factory);\n// export API\nmodule.exports = factory;\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/jsonld.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/nodeMap.js":
/*!********************************************!*\
  !*** ./node_modules/jsonld/lib/nodeMap.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {isKeyword} = __webpack_require__(/*! ./context */ \"./node_modules/jsonld/lib/context.js\");\nconst graphTypes = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Creates a merged JSON-LD node map (node ID => node).\n *\n * @param input the expanded JSON-LD to create a node map of.\n * @param [options] the options to use:\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *\n * @return the node map.\n */\napi.createMergedNodeMap = (input, options) => {\n  options = options || {};\n\n  // produce a map of all subjects and name each bnode\n  const issuer = options.issuer || new util.IdentifierIssuer('_:b');\n  const graphs = {'@default': {}};\n  api.createNodeMap(input, graphs, '@default', issuer);\n\n  // add all non-default graphs to default graph\n  return api.mergeNodeMaps(graphs);\n};\n\n/**\n * Recursively flattens the subjects in the given JSON-LD expanded input\n * into a node map.\n *\n * @param input the JSON-LD expanded input.\n * @param graphs a map of graph name to subject map.\n * @param graph the name of the current graph.\n * @param issuer the blank node identifier issuer.\n * @param name the name assigned to the current input if it is a bnode.\n * @param list the list to append to, null for none.\n */\napi.createNodeMap = (input, graphs, graph, issuer, name, list) => {\n  // recurse through array\n  if(types.isArray(input)) {\n    for(const node of input) {\n      api.createNodeMap(node, graphs, graph, issuer, undefined, list);\n    }\n    return;\n  }\n\n  // add non-object to list\n  if(!types.isObject(input)) {\n    if(list) {\n      list.push(input);\n    }\n    return;\n  }\n\n  // add values to list\n  if(graphTypes.isValue(input)) {\n    if('@type' in input) {\n      let type = input['@type'];\n      // rename @type blank node\n      if(type.indexOf('_:') === 0) {\n        input['@type'] = type = issuer.getId(type);\n      }\n    }\n    if(list) {\n      list.push(input);\n    }\n    return;\n  } else if(list && graphTypes.isList(input)) {\n    const _list = [];\n    api.createNodeMap(input['@list'], graphs, graph, issuer, name, _list);\n    list.push({'@list': _list});\n    return;\n  }\n\n  // Note: At this point, input must be a subject.\n\n  // spec requires @type to be named first, so assign names early\n  if('@type' in input) {\n    const types = input['@type'];\n    for(const type of types) {\n      if(type.indexOf('_:') === 0) {\n        issuer.getId(type);\n      }\n    }\n  }\n\n  // get name for subject\n  if(types.isUndefined(name)) {\n    name = graphTypes.isBlankNode(input) ?\n      issuer.getId(input['@id']) : input['@id'];\n  }\n\n  // add subject reference to list\n  if(list) {\n    list.push({'@id': name});\n  }\n\n  // create new subject or merge into existing one\n  const subjects = graphs[graph];\n  const subject = subjects[name] = subjects[name] || {};\n  subject['@id'] = name;\n  const properties = Object.keys(input).sort();\n  for(let property of properties) {\n    // skip @id\n    if(property === '@id') {\n      continue;\n    }\n\n    // handle reverse properties\n    if(property === '@reverse') {\n      const referencedNode = {'@id': name};\n      const reverseMap = input['@reverse'];\n      for(const reverseProperty in reverseMap) {\n        const items = reverseMap[reverseProperty];\n        for(const item of items) {\n          let itemName = item['@id'];\n          if(graphTypes.isBlankNode(item)) {\n            itemName = issuer.getId(itemName);\n          }\n          api.createNodeMap(item, graphs, graph, issuer, itemName);\n          util.addValue(\n            subjects[itemName], reverseProperty, referencedNode,\n            {propertyIsArray: true, allowDuplicate: false});\n        }\n      }\n      continue;\n    }\n\n    // recurse into graph\n    if(property === '@graph') {\n      // add graph subjects map entry\n      if(!(name in graphs)) {\n        graphs[name] = {};\n      }\n      api.createNodeMap(input[property], graphs, name, issuer);\n      continue;\n    }\n\n    // recurse into included\n    if(property === '@included') {\n      api.createNodeMap(input[property], graphs, graph, issuer);\n      continue;\n    }\n\n    // copy non-@type keywords\n    if(property !== '@type' && isKeyword(property)) {\n      if(property === '@index' && property in subject &&\n        (input[property] !== subject[property] ||\n        input[property]['@id'] !== subject[property]['@id'])) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; conflicting @index property detected.',\n          'jsonld.SyntaxError',\n          {code: 'conflicting indexes', subject});\n      }\n      subject[property] = input[property];\n      continue;\n    }\n\n    // iterate over objects\n    const objects = input[property];\n\n    // if property is a bnode, assign it a new id\n    if(property.indexOf('_:') === 0) {\n      property = issuer.getId(property);\n    }\n\n    // ensure property is added for empty arrays\n    if(objects.length === 0) {\n      util.addValue(subject, property, [], {propertyIsArray: true});\n      continue;\n    }\n    for(let o of objects) {\n      if(property === '@type') {\n        // rename @type blank nodes\n        o = (o.indexOf('_:') === 0) ? issuer.getId(o) : o;\n      }\n\n      // handle embedded subject or subject reference\n      if(graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {\n        // skip null @id\n        if('@id' in o && !o['@id']) {\n          continue;\n        }\n\n        // relabel blank node @id\n        const id = graphTypes.isBlankNode(o) ?\n          issuer.getId(o['@id']) : o['@id'];\n\n        // add reference and recurse\n        util.addValue(\n          subject, property, {'@id': id},\n          {propertyIsArray: true, allowDuplicate: false});\n        api.createNodeMap(o, graphs, graph, issuer, id);\n      } else if(graphTypes.isValue(o)) {\n        util.addValue(\n          subject, property, o,\n          {propertyIsArray: true, allowDuplicate: false});\n      } else if(graphTypes.isList(o)) {\n        // handle @list\n        const _list = [];\n        api.createNodeMap(o['@list'], graphs, graph, issuer, name, _list);\n        o = {'@list': _list};\n        util.addValue(\n          subject, property, o,\n          {propertyIsArray: true, allowDuplicate: false});\n      } else {\n        // handle @value\n        api.createNodeMap(o, graphs, graph, issuer, name);\n        util.addValue(\n          subject, property, o, {propertyIsArray: true, allowDuplicate: false});\n      }\n    }\n  }\n};\n\n/**\n * Merge separate named graphs into a single merged graph including\n * all nodes from the default graph and named graphs.\n *\n * @param graphs a map of graph name to subject map.\n *\n * @return the merged graph map.\n */\napi.mergeNodeMapGraphs = graphs => {\n  const merged = {};\n  for(const name of Object.keys(graphs).sort()) {\n    for(const id of Object.keys(graphs[name]).sort()) {\n      const node = graphs[name][id];\n      if(!(id in merged)) {\n        merged[id] = {'@id': id};\n      }\n      const mergedNode = merged[id];\n\n      for(const property of Object.keys(node).sort()) {\n        if(isKeyword(property) && property !== '@type') {\n          // copy keywords\n          mergedNode[property] = util.clone(node[property]);\n        } else {\n          // merge objects\n          for(const value of node[property]) {\n            util.addValue(\n              mergedNode, property, util.clone(value),\n              {propertyIsArray: true, allowDuplicate: false});\n          }\n        }\n      }\n    }\n  }\n\n  return merged;\n};\n\napi.mergeNodeMaps = graphs => {\n  // add all non-default graphs to default graph\n  const defaultGraph = graphs['@default'];\n  const graphNames = Object.keys(graphs).sort();\n  for(const graphName of graphNames) {\n    if(graphName === '@default') {\n      continue;\n    }\n    const nodeMap = graphs[graphName];\n    let subject = defaultGraph[graphName];\n    if(!subject) {\n      defaultGraph[graphName] = subject = {\n        '@id': graphName,\n        '@graph': []\n      };\n    } else if(!('@graph' in subject)) {\n      subject['@graph'] = [];\n    }\n    const graph = subject['@graph'];\n    for(const id of Object.keys(nodeMap).sort()) {\n      const node = nodeMap[id];\n      // only add full subjects\n      if(!graphTypes.isSubjectReference(node)) {\n        graph.push(node);\n      }\n    }\n  }\n  return defaultGraph;\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/nodeMap.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/platform-browser.js":
/*!*****************************************************!*\
  !*** ./node_modules/jsonld/lib/platform-browser.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst xhrLoader = __webpack_require__(/*! ./documentLoaders/xhr */ \"./node_modules/jsonld/lib/documentLoaders/xhr.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Setup browser document loaders.\n *\n * @param jsonld the jsonld api.\n */\napi.setupDocumentLoaders = function(jsonld) {\n  if(typeof XMLHttpRequest !== 'undefined') {\n    jsonld.documentLoaders.xhr = xhrLoader;\n    // use xhr document loader by default\n    jsonld.useDocumentLoader('xhr');\n  }\n};\n\n/**\n * Setup browser globals.\n *\n * @param jsonld the jsonld api.\n */\napi.setupGlobals = function(jsonld) {\n  // setup browser global JsonLdProcessor\n  if(typeof globalThis.JsonLdProcessor === 'undefined') {\n    Object.defineProperty(globalThis, 'JsonLdProcessor', {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: jsonld.JsonLdProcessor\n    });\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/platform-browser.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/toRdf.js":
/*!******************************************!*\
  !*** ./node_modules/jsonld/lib/toRdf.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {createNodeMap} = __webpack_require__(/*! ./nodeMap */ \"./node_modules/jsonld/lib/nodeMap.js\");\nconst {isKeyword} = __webpack_require__(/*! ./context */ \"./node_modules/jsonld/lib/context.js\");\nconst graphTypes = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\nconst jsonCanonicalize = __webpack_require__(/*! canonicalize */ \"./node_modules/canonicalize/lib/canonicalize.js\");\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\n\nconst {\n  // RDF,\n  // RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING,\n} = __webpack_require__(/*! ./constants */ \"./node_modules/jsonld/lib/constants.js\");\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = __webpack_require__(/*! ./url */ \"./node_modules/jsonld/lib/url.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Outputs an RDF dataset for the expanded JSON-LD input.\n *\n * @param input the expanded JSON-LD input.\n * @param options the RDF serialization options.\n *\n * @return the RDF dataset.\n */\napi.toRDF = (input, options) => {\n  // create node map for default graph (and any named graphs)\n  const issuer = new util.IdentifierIssuer('_:b');\n  const nodeMap = {'@default': {}};\n  createNodeMap(input, nodeMap, '@default', issuer);\n\n  const dataset = [];\n  const graphNames = Object.keys(nodeMap).sort();\n  for(const graphName of graphNames) {\n    let graphTerm;\n    if(graphName === '@default') {\n      graphTerm = {termType: 'DefaultGraph', value: ''};\n    } else if(_isAbsoluteIri(graphName)) {\n      if(graphName.startsWith('_:')) {\n        graphTerm = {termType: 'BlankNode'};\n      } else {\n        graphTerm = {termType: 'NamedNode'};\n      }\n      graphTerm.value = graphName;\n    } else {\n      // skip relative IRIs (not valid RDF)\n      continue;\n    }\n    _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);\n  }\n\n  return dataset;\n};\n\n/**\n * Adds RDF quads for a particular graph to the given dataset.\n *\n * @param dataset the dataset to append RDF quads to.\n * @param graph the graph to create RDF quads for.\n * @param graphTerm the graph term for each quad.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param options the RDF serialization options.\n *\n * @return the array of RDF triples for the given graph.\n */\nfunction _graphToRDF(dataset, graph, graphTerm, issuer, options) {\n  const ids = Object.keys(graph).sort();\n  for(const id of ids) {\n    const node = graph[id];\n    const properties = Object.keys(node).sort();\n    for(let property of properties) {\n      const items = node[property];\n      if(property === '@type') {\n        property = RDF_TYPE;\n      } else if(isKeyword(property)) {\n        continue;\n      }\n\n      for(const item of items) {\n        // RDF subject\n        const subject = {\n          termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: id\n        };\n\n        // skip relative IRI subjects (not valid RDF)\n        if(!_isAbsoluteIri(id)) {\n          continue;\n        }\n\n        // RDF predicate\n        const predicate = {\n          termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: property\n        };\n\n        // skip relative IRI predicates (not valid RDF)\n        if(!_isAbsoluteIri(property)) {\n          continue;\n        }\n\n        // skip blank node predicates unless producing generalized RDF\n        if(predicate.termType === 'BlankNode' &&\n          !options.produceGeneralizedRdf) {\n          continue;\n        }\n\n        // convert list, value or node object to triple\n        const object =\n          _objectToRDF(item, issuer, dataset, graphTerm, options.rdfDirection);\n        // skip null objects (they are relative IRIs)\n        if(object) {\n          dataset.push({\n            subject,\n            predicate,\n            object,\n            graph: graphTerm\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Converts a @list value into linked list of blank node RDF quads\n * (an RDF collection).\n *\n * @param list the @list value.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the array of quads to append to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the head of the list.\n */\nfunction _listToRDF(list, issuer, dataset, graphTerm, rdfDirection) {\n  const first = {termType: 'NamedNode', value: RDF_FIRST};\n  const rest = {termType: 'NamedNode', value: RDF_REST};\n  const nil = {termType: 'NamedNode', value: RDF_NIL};\n\n  const last = list.pop();\n  // Result is the head of the list\n  const result = last ? {termType: 'BlankNode', value: issuer.getId()} : nil;\n  let subject = result;\n\n  for(const item of list) {\n    const object = _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection);\n    const next = {termType: 'BlankNode', value: issuer.getId()};\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: next,\n      graph: graphTerm\n    });\n    subject = next;\n  }\n\n  // Tail of list\n  if(last) {\n    const object = _objectToRDF(last, issuer, dataset, graphTerm, rdfDirection);\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: nil,\n      graph: graphTerm\n    });\n  }\n\n  return result;\n}\n\n/**\n * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,\n * node object to an RDF resource, or adds a list.\n *\n * @param item the JSON-LD value or node object.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the dataset to append RDF quads to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the RDF literal or RDF resource.\n */\nfunction _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection) {\n  const object = {};\n\n  // convert value object to RDF\n  if(graphTypes.isValue(item)) {\n    object.termType = 'Literal';\n    object.value = undefined;\n    object.datatype = {\n      termType: 'NamedNode'\n    };\n    let value = item['@value'];\n    const datatype = item['@type'] || null;\n\n    // convert to XSD/JSON datatypes as appropriate\n    if(datatype === '@json') {\n      object.value = jsonCanonicalize(value);\n      object.datatype.value = RDF_JSON_LITERAL;\n    } else if(types.isBoolean(value)) {\n      object.value = value.toString();\n      object.datatype.value = datatype || XSD_BOOLEAN;\n    } else if(types.isDouble(value) || datatype === XSD_DOUBLE) {\n      if(!types.isDouble(value)) {\n        value = parseFloat(value);\n      }\n      // canonical double representation\n      object.value = value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n      object.datatype.value = datatype || XSD_DOUBLE;\n    } else if(types.isNumber(value)) {\n      object.value = value.toFixed(0);\n      object.datatype.value = datatype || XSD_INTEGER;\n    } else if(rdfDirection === 'i18n-datatype' &&\n      '@direction' in item) {\n      const datatype = 'https://www.w3.org/ns/i18n#' +\n        (item['@language'] || '') +\n        `_${item['@direction']}`;\n      object.datatype.value = datatype;\n      object.value = value;\n    } else if('@language' in item) {\n      object.value = value;\n      object.datatype.value = datatype || RDF_LANGSTRING;\n      object.language = item['@language'];\n    } else {\n      object.value = value;\n      object.datatype.value = datatype || XSD_STRING;\n    }\n  } else if(graphTypes.isList(item)) {\n    const _list =\n      _listToRDF(item['@list'], issuer, dataset, graphTerm, rdfDirection);\n    object.termType = _list.termType;\n    object.value = _list.value;\n  } else {\n    // convert string/node object to RDF\n    const id = types.isObject(item) ? item['@id'] : item;\n    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';\n    object.value = id;\n  }\n\n  // skip relative IRIs, not valid RDF\n  if(object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {\n    return null;\n  }\n\n  return object;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/toRdf.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/types.js":
/*!******************************************!*\
  !*** ./node_modules/jsonld/lib/types.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Returns true if the given value is an Array.\n *\n * @param v the value to check.\n *\n * @return true if the value is an Array, false if not.\n */\napi.isArray = Array.isArray;\n\n/**\n * Returns true if the given value is a Boolean.\n *\n * @param v the value to check.\n *\n * @return true if the value is a Boolean, false if not.\n */\napi.isBoolean = v => (typeof v === 'boolean' ||\n  Object.prototype.toString.call(v) === '[object Boolean]');\n\n/**\n * Returns true if the given value is a double.\n *\n * @param v the value to check.\n *\n * @return true if the value is a double, false if not.\n */\napi.isDouble = v => api.isNumber(v) &&\n  (String(v).indexOf('.') !== -1 || Math.abs(v) >= 1e21);\n\n/**\n * Returns true if the given value is an empty Object.\n *\n * @param v the value to check.\n *\n * @return true if the value is an empty Object, false if not.\n */\napi.isEmptyObject = v => api.isObject(v) && Object.keys(v).length === 0;\n\n/**\n * Returns true if the given value is a Number.\n *\n * @param v the value to check.\n *\n * @return true if the value is a Number, false if not.\n */\napi.isNumber = v => (typeof v === 'number' ||\n  Object.prototype.toString.call(v) === '[object Number]');\n\n/**\n * Returns true if the given value is numeric.\n *\n * @param v the value to check.\n *\n * @return true if the value is numeric, false if not.\n */\napi.isNumeric = v => !isNaN(parseFloat(v)) && isFinite(v);\n\n/**\n * Returns true if the given value is an Object.\n *\n * @param v the value to check.\n *\n * @return true if the value is an Object, false if not.\n */\napi.isObject = v => Object.prototype.toString.call(v) === '[object Object]';\n\n/**\n * Returns true if the given value is a String.\n *\n * @param v the value to check.\n *\n * @return true if the value is a String, false if not.\n */\napi.isString = v => (typeof v === 'string' ||\n  Object.prototype.toString.call(v) === '[object String]');\n\n/**\n * Returns true if the given value is undefined.\n *\n * @param v the value to check.\n *\n * @return true if the value is undefined, false if not.\n */\napi.isUndefined = v => typeof v === 'undefined';\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/types.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/url.js":
/*!****************************************!*\
  !*** ./node_modules/jsonld/lib/url.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n\nconst api = {};\nmodule.exports = api;\n\n// define URL parser\n// parseUri 1.2.2\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\n// with local jsonld.js modifications\napi.parsers = {\n  simple: {\n    // RFC 3986 basic parts\n    keys: [\n      'href', 'scheme', 'authority', 'path', 'query', 'fragment'\n    ],\n    /* eslint-disable-next-line max-len */\n    regex: /^(?:([^:\\/?#]+):)?(?:\\/\\/([^\\/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/\n  },\n  full: {\n    keys: [\n      'href', 'protocol', 'scheme', 'authority', 'auth', 'user', 'password',\n      'hostname', 'port', 'path', 'directory', 'file', 'query', 'fragment'\n    ],\n    /* eslint-disable-next-line max-len */\n    regex: /^(([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?(?:(((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/\n  }\n};\napi.parse = (str, parser) => {\n  const parsed = {};\n  const o = api.parsers[parser || 'full'];\n  const m = o.regex.exec(str);\n  let i = o.keys.length;\n  while(i--) {\n    parsed[o.keys[i]] = (m[i] === undefined) ? null : m[i];\n  }\n\n  // remove default ports in found in URLs\n  if((parsed.scheme === 'https' && parsed.port === '443') ||\n    (parsed.scheme === 'http' && parsed.port === '80')) {\n    parsed.href = parsed.href.replace(':' + parsed.port, '');\n    parsed.authority = parsed.authority.replace(':' + parsed.port, '');\n    parsed.port = null;\n  }\n\n  parsed.normalizedPath = api.removeDotSegments(parsed.path);\n  return parsed;\n};\n\n/**\n * Prepends a base IRI to the given relative IRI.\n *\n * @param base the base IRI.\n * @param iri the relative IRI.\n *\n * @return the absolute IRI.\n */\napi.prependBase = (base, iri) => {\n  // skip IRI processing\n  if(base === null) {\n    return iri;\n  }\n  // already an absolute IRI\n  if(api.isAbsolute(iri)) {\n    return iri;\n  }\n\n  // parse base if it is a string\n  if(!base || types.isString(base)) {\n    base = api.parse(base || '');\n  }\n\n  // parse given IRI\n  const rel = api.parse(iri);\n\n  // per RFC3986 5.2.2\n  const transform = {\n    protocol: base.protocol || ''\n  };\n\n  if(rel.authority !== null) {\n    transform.authority = rel.authority;\n    transform.path = rel.path;\n    transform.query = rel.query;\n  } else {\n    transform.authority = base.authority;\n\n    if(rel.path === '') {\n      transform.path = base.path;\n      if(rel.query !== null) {\n        transform.query = rel.query;\n      } else {\n        transform.query = base.query;\n      }\n    } else {\n      if(rel.path.indexOf('/') === 0) {\n        // IRI represents an absolute path\n        transform.path = rel.path;\n      } else {\n        // merge paths\n        let path = base.path;\n\n        // append relative path to the end of the last directory from base\n        path = path.substr(0, path.lastIndexOf('/') + 1);\n        if((path.length > 0 || base.authority) && path.substr(-1) !== '/') {\n          path += '/';\n        }\n        path += rel.path;\n\n        transform.path = path;\n      }\n      transform.query = rel.query;\n    }\n  }\n\n  if(rel.path !== '') {\n    // remove slashes and dots in path\n    transform.path = api.removeDotSegments(transform.path);\n  }\n\n  // construct URL\n  let rval = transform.protocol;\n  if(transform.authority !== null) {\n    rval += '//' + transform.authority;\n  }\n  rval += transform.path;\n  if(transform.query !== null) {\n    rval += '?' + transform.query;\n  }\n  if(rel.fragment !== null) {\n    rval += '#' + rel.fragment;\n  }\n\n  // handle empty base\n  if(rval === '') {\n    rval = './';\n  }\n\n  return rval;\n};\n\n/**\n * Removes a base IRI from the given absolute IRI.\n *\n * @param base the base IRI.\n * @param iri the absolute IRI.\n *\n * @return the relative IRI if relative to base, otherwise the absolute IRI.\n */\napi.removeBase = (base, iri) => {\n  // skip IRI processing\n  if(base === null) {\n    return iri;\n  }\n\n  if(!base || types.isString(base)) {\n    base = api.parse(base || '');\n  }\n\n  // establish base root\n  let root = '';\n  if(base.href !== '') {\n    root += (base.protocol || '') + '//' + (base.authority || '');\n  } else if(iri.indexOf('//')) {\n    // support network-path reference with empty base\n    root += '//';\n  }\n\n  // IRI not relative to base\n  if(iri.indexOf(root) !== 0) {\n    return iri;\n  }\n\n  // remove root from IRI and parse remainder\n  const rel = api.parse(iri.substr(root.length));\n\n  // remove path segments that match (do not remove last segment unless there\n  // is a hash or query)\n  const baseSegments = base.normalizedPath.split('/');\n  const iriSegments = rel.normalizedPath.split('/');\n  const last = (rel.fragment || rel.query) ? 0 : 1;\n  while(baseSegments.length > 0 && iriSegments.length > last) {\n    if(baseSegments[0] !== iriSegments[0]) {\n      break;\n    }\n    baseSegments.shift();\n    iriSegments.shift();\n  }\n\n  // use '../' for each non-matching base segment\n  let rval = '';\n  if(baseSegments.length > 0) {\n    // don't count the last segment (if it ends with '/' last path doesn't\n    // count and if it doesn't end with '/' it isn't a path)\n    baseSegments.pop();\n    for(let i = 0; i < baseSegments.length; ++i) {\n      rval += '../';\n    }\n  }\n\n  // prepend remaining segments\n  rval += iriSegments.join('/');\n\n  // add query and hash\n  if(rel.query !== null) {\n    rval += '?' + rel.query;\n  }\n  if(rel.fragment !== null) {\n    rval += '#' + rel.fragment;\n  }\n\n  // handle empty base\n  if(rval === '') {\n    rval = './';\n  }\n\n  return rval;\n};\n\n/**\n * Removes dot segments from a URL path.\n *\n * @param path the path to remove dot segments from.\n */\napi.removeDotSegments = path => {\n  // RFC 3986 5.2.4 (reworked)\n\n  // empty path shortcut\n  if(path.length === 0) {\n    return '';\n  }\n\n  const input = path.split('/');\n  const output = [];\n\n  while(input.length > 0) {\n    const next = input.shift();\n    const done = input.length === 0;\n\n    if(next === '.') {\n      if(done) {\n        // ensure output has trailing /\n        output.push('');\n      }\n      continue;\n    }\n\n    if(next === '..') {\n      output.pop();\n      if(done) {\n        // ensure output has trailing /\n        output.push('');\n      }\n      continue;\n    }\n\n    output.push(next);\n  }\n\n  // if path was absolute, ensure output has leading /\n  if(path[0] === '/' && output.length > 0 && output[0] !== '') {\n    output.unshift('');\n  }\n  if(output.length === 1 && output[0] === '') {\n    return '/';\n  }\n\n  return output.join('/');\n};\n\n// TODO: time better isAbsolute/isRelative checks using full regexes:\n// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html\n\n// regex to check for absolute IRI (starting scheme and ':') or blank node IRI\nconst isAbsoluteRegex = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^\\s]*$/;\n\n/**\n * Returns true if the given value is an absolute IRI or blank node IRI, false\n * if not.\n * Note: This weak check only checks for a correct starting scheme.\n *\n * @param v the value to check.\n *\n * @return true if the value is an absolute IRI, false if not.\n */\napi.isAbsolute = v => types.isString(v) && isAbsoluteRegex.test(v);\n\n/**\n * Returns true if the given value is a relative IRI, false if not.\n * Note: this is a weak check.\n *\n * @param v the value to check.\n *\n * @return true if the value is a relative IRI, false if not.\n */\napi.isRelative = v => types.isString(v);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/url.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/util.js":
/*!*****************************************!*\
  !*** ./node_modules/jsonld/lib/util.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst graphTypes = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n// TODO: move `IdentifierIssuer` to its own package\nconst IdentifierIssuer = (__webpack_require__(/*! rdf-canonize */ \"./node_modules/rdf-canonize/index.js\").IdentifierIssuer);\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\n\n// constants\nconst REGEX_LINK_HEADERS = /(?:<[^>]*?>|\"[^\"]*?\"|[^,])+/g;\nconst REGEX_LINK_HEADER = /\\s*<([^>]*?)>\\s*(?:;\\s*(.*))?/;\nconst REGEX_LINK_HEADER_PARAMS =\n  /(.*?)=(?:(?:\"([^\"]*?)\")|([^\"]*?))\\s*(?:(?:;\\s*)|$)/g;\n\nconst DEFAULTS = {\n  headers: {\n    accept: 'application/ld+json, application/json'\n  }\n};\n\nconst api = {};\nmodule.exports = api;\napi.IdentifierIssuer = IdentifierIssuer;\n\n/**\n * Clones an object, array, Map, Set, or string/number. If a typed JavaScript\n * object is given, such as a Date, it will be converted to a string.\n *\n * @param value the value to clone.\n *\n * @return the cloned value.\n */\napi.clone = function(value) {\n  if(value && typeof value === 'object') {\n    let rval;\n    if(types.isArray(value)) {\n      rval = [];\n      for(let i = 0; i < value.length; ++i) {\n        rval[i] = api.clone(value[i]);\n      }\n    } else if(value instanceof Map) {\n      rval = new Map();\n      for(const [k, v] of value) {\n        rval.set(k, api.clone(v));\n      }\n    } else if(value instanceof Set) {\n      rval = new Set();\n      for(const v of value) {\n        rval.add(api.clone(v));\n      }\n    } else if(types.isObject(value)) {\n      rval = {};\n      for(const key in value) {\n        rval[key] = api.clone(value[key]);\n      }\n    } else {\n      rval = value.toString();\n    }\n    return rval;\n  }\n  return value;\n};\n\n/**\n * Ensure a value is an array. If the value is an array, it is returned.\n * Otherwise, it is wrapped in an array.\n *\n * @param value the value to return as an array.\n *\n * @return the value as an array.\n */\napi.asArray = function(value) {\n  return Array.isArray(value) ? value : [value];\n};\n\n/**\n * Builds an HTTP headers object for making a JSON-LD request from custom\n * headers and asserts the `accept` header isn't overridden.\n *\n * @param headers an object of headers with keys as header names and values\n *          as header values.\n *\n * @return an object of headers with a valid `accept` header.\n */\napi.buildHeaders = (headers = {}) => {\n  const hasAccept = Object.keys(headers).some(\n    h => h.toLowerCase() === 'accept');\n\n  if(hasAccept) {\n    throw new RangeError(\n      'Accept header may not be specified; only \"' +\n      DEFAULTS.headers.accept + '\" is supported.');\n  }\n\n  return Object.assign({Accept: DEFAULTS.headers.accept}, headers);\n};\n\n/**\n * Parses a link header. The results will be key'd by the value of \"rel\".\n *\n * Link: <http://json-ld.org/contexts/person.jsonld>;\n * rel=\"http://www.w3.org/ns/json-ld#context\"; type=\"application/ld+json\"\n *\n * Parses as: {\n *   'http://www.w3.org/ns/json-ld#context': {\n *     target: http://json-ld.org/contexts/person.jsonld,\n *     type: 'application/ld+json'\n *   }\n * }\n *\n * If there is more than one \"rel\" with the same IRI, then entries in the\n * resulting map for that \"rel\" will be arrays.\n *\n * @param header the link header to parse.\n */\napi.parseLinkHeader = header => {\n  const rval = {};\n  // split on unbracketed/unquoted commas\n  const entries = header.match(REGEX_LINK_HEADERS);\n  for(let i = 0; i < entries.length; ++i) {\n    let match = entries[i].match(REGEX_LINK_HEADER);\n    if(!match) {\n      continue;\n    }\n    const result = {target: match[1]};\n    const params = match[2];\n    while((match = REGEX_LINK_HEADER_PARAMS.exec(params))) {\n      result[match[1]] = (match[2] === undefined) ? match[3] : match[2];\n    }\n    const rel = result['rel'] || '';\n    if(Array.isArray(rval[rel])) {\n      rval[rel].push(result);\n    } else if(rval.hasOwnProperty(rel)) {\n      rval[rel] = [rval[rel], result];\n    } else {\n      rval[rel] = result;\n    }\n  }\n  return rval;\n};\n\n/**\n * Throws an exception if the given value is not a valid @type value.\n *\n * @param v the value to check.\n */\napi.validateTypeValue = (v, isFrame) => {\n  if(types.isString(v)) {\n    return;\n  }\n\n  if(types.isArray(v) && v.every(vv => types.isString(vv))) {\n    return;\n  }\n  if(isFrame && types.isObject(v)) {\n    switch(Object.keys(v).length) {\n      case 0:\n        // empty object is wildcard\n        return;\n      case 1:\n        // default entry is all strings\n        if('@default' in v &&\n          api.asArray(v['@default']).every(vv => types.isString(vv))) {\n          return;\n        }\n    }\n  }\n\n  throw new JsonLdError(\n    'Invalid JSON-LD syntax; \"@type\" value must a string, an array of ' +\n    'strings, an empty object, ' +\n    'or a default object.', 'jsonld.SyntaxError',\n    {code: 'invalid type value', value: v});\n};\n\n/**\n * Returns true if the given subject has the given property.\n *\n * @param subject the subject to check.\n * @param property the property to look for.\n *\n * @return true if the subject has the given property, false if not.\n */\napi.hasProperty = (subject, property) => {\n  if(subject.hasOwnProperty(property)) {\n    const value = subject[property];\n    return (!types.isArray(value) || value.length > 0);\n  }\n  return false;\n};\n\n/**\n * Determines if the given value is a property of the given subject.\n *\n * @param subject the subject to check.\n * @param property the property to check.\n * @param value the value to check.\n *\n * @return true if the value exists, false if not.\n */\napi.hasValue = (subject, property, value) => {\n  if(api.hasProperty(subject, property)) {\n    let val = subject[property];\n    const isList = graphTypes.isList(val);\n    if(types.isArray(val) || isList) {\n      if(isList) {\n        val = val['@list'];\n      }\n      for(let i = 0; i < val.length; ++i) {\n        if(api.compareValues(value, val[i])) {\n          return true;\n        }\n      }\n    } else if(!types.isArray(value)) {\n      // avoid matching the set of values with an array value parameter\n      return api.compareValues(value, val);\n    }\n  }\n  return false;\n};\n\n/**\n * Adds a value to a subject. If the value is an array, all values in the\n * array will be added.\n *\n * @param subject the subject to add the value to.\n * @param property the property that relates the value to the subject.\n * @param value the value to add.\n * @param [options] the options to use:\n *        [propertyIsArray] true if the property is always an array, false\n *          if not (default: false).\n *        [valueIsArray] true if the value to be added should be preserved as\n *          an array (lists) (default: false).\n *        [allowDuplicate] true to allow duplicates, false not to (uses a\n *          simple shallow comparison of subject ID or value) (default: true).\n *        [prependValue] false to prepend value to any existing values.\n *          (default: false)\n */\napi.addValue = (subject, property, value, options) => {\n  options = options || {};\n  if(!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n  if(!('valueIsArray' in options)) {\n    options.valueIsArray = false;\n  }\n  if(!('allowDuplicate' in options)) {\n    options.allowDuplicate = true;\n  }\n  if(!('prependValue' in options)) {\n    options.prependValue = false;\n  }\n\n  if(options.valueIsArray) {\n    subject[property] = value;\n  } else if(types.isArray(value)) {\n    if(value.length === 0 && options.propertyIsArray &&\n      !subject.hasOwnProperty(property)) {\n      subject[property] = [];\n    }\n    if(options.prependValue) {\n      value = value.concat(subject[property]);\n      subject[property] = [];\n    }\n    for(let i = 0; i < value.length; ++i) {\n      api.addValue(subject, property, value[i], options);\n    }\n  } else if(subject.hasOwnProperty(property)) {\n    // check if subject already has value if duplicates not allowed\n    const hasValue = (!options.allowDuplicate &&\n      api.hasValue(subject, property, value));\n\n    // make property an array if value not present or always an array\n    if(!types.isArray(subject[property]) &&\n      (!hasValue || options.propertyIsArray)) {\n      subject[property] = [subject[property]];\n    }\n\n    // add new value\n    if(!hasValue) {\n      if(options.prependValue) {\n        subject[property].unshift(value);\n      } else {\n        subject[property].push(value);\n      }\n    }\n  } else {\n    // add new value as set or single value\n    subject[property] = options.propertyIsArray ? [value] : value;\n  }\n};\n\n/**\n * Gets all of the values for a subject's property as an array.\n *\n * @param subject the subject.\n * @param property the property.\n *\n * @return all of the values for a subject's property as an array.\n */\napi.getValues = (subject, property) => [].concat(subject[property] || []);\n\n/**\n * Removes a property from a subject.\n *\n * @param subject the subject.\n * @param property the property.\n */\napi.removeProperty = (subject, property) => {\n  delete subject[property];\n};\n\n/**\n * Removes a value from a subject.\n *\n * @param subject the subject.\n * @param property the property that relates the value to the subject.\n * @param value the value to remove.\n * @param [options] the options to use:\n *          [propertyIsArray] true if the property is always an array, false\n *            if not (default: false).\n */\napi.removeValue = (subject, property, value, options) => {\n  options = options || {};\n  if(!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n\n  // filter out value\n  const values = api.getValues(subject, property).filter(\n    e => !api.compareValues(e, value));\n\n  if(values.length === 0) {\n    api.removeProperty(subject, property);\n  } else if(values.length === 1 && !options.propertyIsArray) {\n    subject[property] = values[0];\n  } else {\n    subject[property] = values;\n  }\n};\n\n/**\n * Relabels all blank nodes in the given JSON-LD input.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [issuer] an IdentifierIssuer to use to label blank nodes.\n */\napi.relabelBlankNodes = (input, options) => {\n  options = options || {};\n  const issuer = options.issuer || new IdentifierIssuer('_:b');\n  return _labelBlankNodes(issuer, input);\n};\n\n/**\n * Compares two JSON-LD values for equality. Two JSON-LD values will be\n * considered equal if:\n *\n * 1. They are both primitives of the same type and value.\n * 2. They are both @values with the same @value, @type, @language,\n *   and @index, OR\n * 3. They both have @ids they are the same.\n *\n * @param v1 the first value.\n * @param v2 the second value.\n *\n * @return true if v1 and v2 are considered equal, false if not.\n */\napi.compareValues = (v1, v2) => {\n  // 1. equal primitives\n  if(v1 === v2) {\n    return true;\n  }\n\n  // 2. equal @values\n  if(graphTypes.isValue(v1) && graphTypes.isValue(v2) &&\n    v1['@value'] === v2['@value'] &&\n    v1['@type'] === v2['@type'] &&\n    v1['@language'] === v2['@language'] &&\n    v1['@index'] === v2['@index']) {\n    return true;\n  }\n\n  // 3. equal @ids\n  if(types.isObject(v1) &&\n    ('@id' in v1) &&\n    types.isObject(v2) &&\n    ('@id' in v2)) {\n    return v1['@id'] === v2['@id'];\n  }\n\n  return false;\n};\n\n/**\n * Compares two strings first based on length and then lexicographically.\n *\n * @param a the first string.\n * @param b the second string.\n *\n * @return -1 if a < b, 1 if a > b, 0 if a === b.\n */\napi.compareShortestLeast = (a, b) => {\n  if(a.length < b.length) {\n    return -1;\n  }\n  if(b.length < a.length) {\n    return 1;\n  }\n  if(a === b) {\n    return 0;\n  }\n  return (a < b) ? -1 : 1;\n};\n\n/**\n * Labels the blank nodes in the given value using the given IdentifierIssuer.\n *\n * @param issuer the IdentifierIssuer to use.\n * @param element the element with blank nodes to rename.\n *\n * @return the element.\n */\nfunction _labelBlankNodes(issuer, element) {\n  if(types.isArray(element)) {\n    for(let i = 0; i < element.length; ++i) {\n      element[i] = _labelBlankNodes(issuer, element[i]);\n    }\n  } else if(graphTypes.isList(element)) {\n    element['@list'] = _labelBlankNodes(issuer, element['@list']);\n  } else if(types.isObject(element)) {\n    // relabel blank node\n    if(graphTypes.isBlankNode(element)) {\n      element['@id'] = issuer.getId(element['@id']);\n    }\n\n    // recursively apply to all keys\n    const keys = Object.keys(element).sort();\n    for(let ki = 0; ki < keys.length; ++ki) {\n      const key = keys[ki];\n      if(key !== '@id') {\n        element[key] = _labelBlankNodes(issuer, element[key]);\n      }\n    }\n  }\n\n  return element;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/util.js?");

/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// A linked list to keep track of recently-used-ness\nconst Yallist = __webpack_require__(/*! yallist */ \"./node_modules/yallist/yallist.js\")\n\nconst MAX = Symbol('max')\nconst LENGTH = Symbol('length')\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator')\nconst ALLOW_STALE = Symbol('allowStale')\nconst MAX_AGE = Symbol('maxAge')\nconst DISPOSE = Symbol('dispose')\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')\nconst LRU_LIST = Symbol('lruList')\nconst CACHE = Symbol('cache')\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')\n\nconst naiveLength = () => 1\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nclass LRUCache {\n  constructor (options) {\n    if (typeof options === 'number')\n      options = { max: options }\n\n    if (!options)\n      options = {}\n\n    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n      throw new TypeError('max must be a non-negative number')\n    // Kind of weird to have a default max of Infinity, but oh well.\n    const max = this[MAX] = options.max || Infinity\n\n    const lc = options.length || naiveLength\n    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n    this[ALLOW_STALE] = options.stale || false\n    if (options.maxAge && typeof options.maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n    this[MAX_AGE] = options.maxAge || 0\n    this[DISPOSE] = options.dispose\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false\n    this.reset()\n  }\n\n  // resize the cache when the max changes.\n  set max (mL) {\n    if (typeof mL !== 'number' || mL < 0)\n      throw new TypeError('max must be a non-negative number')\n\n    this[MAX] = mL || Infinity\n    trim(this)\n  }\n  get max () {\n    return this[MAX]\n  }\n\n  set allowStale (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  }\n  get allowStale () {\n    return this[ALLOW_STALE]\n  }\n\n  set maxAge (mA) {\n    if (typeof mA !== 'number')\n      throw new TypeError('maxAge must be a non-negative number')\n\n    this[MAX_AGE] = mA\n    trim(this)\n  }\n  get maxAge () {\n    return this[MAX_AGE]\n  }\n\n  // resize the cache when the lengthCalculator changes.\n  set lengthCalculator (lC) {\n    if (typeof lC !== 'function')\n      lC = naiveLength\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      })\n    }\n    trim(this)\n  }\n  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n  get length () { return this[LENGTH] }\n  get itemCount () { return this[LRU_LIST].length }\n\n  rforEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev\n      forEachStep(this, fn, walker, thisp)\n      walker = prev\n    }\n  }\n\n  forEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next\n      forEachStep(this, fn, walker, thisp)\n      walker = next\n    }\n  }\n\n  keys () {\n    return this[LRU_LIST].toArray().map(k => k.key)\n  }\n\n  values () {\n    return this[LRU_LIST].toArray().map(k => k.value)\n  }\n\n  reset () {\n    if (this[DISPOSE] &&\n        this[LRU_LIST] &&\n        this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n    }\n\n    this[CACHE] = new Map() // hash of items by key\n    this[LRU_LIST] = new Yallist() // list of items in order of use recency\n    this[LENGTH] = 0 // length of items in the list\n  }\n\n  dump () {\n    return this[LRU_LIST].map(hit =>\n      isStale(this, hit) ? false : {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }).toArray().filter(h => h)\n  }\n\n  dumpLru () {\n    return this[LRU_LIST]\n  }\n\n  set (key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE]\n\n    if (maxAge && typeof maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n\n    const now = maxAge ? Date.now() : 0\n    const len = this[LENGTH_CALCULATOR](value, key)\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key))\n        return false\n      }\n\n      const node = this[CACHE].get(key)\n      const item = node.value\n\n      // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET])\n          this[DISPOSE](key, item.value)\n      }\n\n      item.now = now\n      item.maxAge = maxAge\n      item.value = value\n      this[LENGTH] += len - item.length\n      item.length = len\n      this.get(key)\n      trim(this)\n      return true\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE])\n        this[DISPOSE](key, value)\n\n      return false\n    }\n\n    this[LENGTH] += hit.length\n    this[LRU_LIST].unshift(hit)\n    this[CACHE].set(key, this[LRU_LIST].head)\n    trim(this)\n    return true\n  }\n\n  has (key) {\n    if (!this[CACHE].has(key)) return false\n    const hit = this[CACHE].get(key).value\n    return !isStale(this, hit)\n  }\n\n  get (key) {\n    return get(this, key, true)\n  }\n\n  peek (key) {\n    return get(this, key, false)\n  }\n\n  pop () {\n    const node = this[LRU_LIST].tail\n    if (!node)\n      return null\n\n    del(this, node)\n    return node.value\n  }\n\n  del (key) {\n    del(this, this[CACHE].get(key))\n  }\n\n  load (arr) {\n    // reset the cache\n    this.reset()\n\n    const now = Date.now()\n    // A previous serialized cache has the most recent items first\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l]\n      const expiresAt = hit.e || 0\n      if (expiresAt === 0)\n        // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v)\n      else {\n        const maxAge = expiresAt - now\n        // dont add already expired items\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge)\n        }\n      }\n    }\n  }\n\n  prune () {\n    this[CACHE].forEach((value, key) => get(this, key, false))\n  }\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key)\n  if (node) {\n    const hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE])\n        return undefined\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET])\n          node.value.now = Date.now()\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    return hit.value\n  }\n}\n\nconst isStale = (self, hit) => {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n    return false\n\n  const diff = Date.now() - hit.now\n  return hit.maxAge ? diff > hit.maxAge\n    : self[MAX_AGE] && (diff > self[MAX_AGE])\n}\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value\n    if (self[DISPOSE])\n      self[DISPOSE](hit.key, hit.value)\n\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\nclass Entry {\n  constructor (key, value, length, now, maxAge) {\n    this.key = key\n    this.value = value\n    this.length = length\n    this.now = now\n    this.maxAge = maxAge || 0\n  }\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE])\n      hit = undefined\n  }\n  if (hit)\n    fn.call(thisp, hit.value, hit.key, self)\n}\n\nmodule.exports = LRUCache\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/lru-cache/index.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/index.js":
/*!********************************************!*\
  !*** ./node_modules/rdf-canonize/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * An implementation of the RDF Dataset Normalization specification.\n *\n * @author Dave Longley\n *\n * Copyright 2010-2021 Digital Bazaar, Inc.\n */\nmodule.exports = __webpack_require__(/*! ./lib */ \"./node_modules/rdf-canonize/lib/index.js\");\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/index.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/IdentifierIssuer.js":
/*!***********************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/IdentifierIssuer.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class IdentifierIssuer {\n  /**\n   * Creates a new IdentifierIssuer. A IdentifierIssuer issues unique\n   * identifiers, keeping track of any previously issued identifiers.\n   *\n   * @param prefix the prefix to use ('<prefix><counter>').\n   * @param existing an existing Map to use.\n   * @param counter the counter to use.\n   */\n  constructor(prefix, existing = new Map(), counter = 0) {\n    this.prefix = prefix;\n    this._existing = existing;\n    this.counter = counter;\n  }\n\n  /**\n   * Copies this IdentifierIssuer.\n   *\n   * @return a copy of this IdentifierIssuer.\n   */\n  clone() {\n    const {prefix, _existing, counter} = this;\n    return new IdentifierIssuer(prefix, new Map(_existing), counter);\n  }\n\n  /**\n   * Gets the new identifier for the given old identifier, where if no old\n   * identifier is given a new identifier will be generated.\n   *\n   * @param [old] the old identifier to get the new identifier for.\n   *\n   * @return the new identifier.\n   */\n  getId(old) {\n    // return existing old identifier\n    const existing = old && this._existing.get(old);\n    if(existing) {\n      return existing;\n    }\n\n    // get next identifier\n    const identifier = this.prefix + this.counter;\n    this.counter++;\n\n    // save mapping\n    if(old) {\n      this._existing.set(old, identifier);\n    }\n\n    return identifier;\n  }\n\n  /**\n   * Returns true if the given old identifer has already been assigned a new\n   * identifier.\n   *\n   * @param old the old identifier to check.\n   *\n   * @return true if the old identifier has been assigned a new identifier,\n   *   false if not.\n   */\n  hasId(old) {\n    return this._existing.has(old);\n  }\n\n  /**\n   * Returns all of the IDs that have been issued new IDs in the order in\n   * which they were issued new IDs.\n   *\n   * @return the list of old IDs that has been issued new IDs in order.\n   */\n  getOldIds() {\n    return [...this._existing.keys()];\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/IdentifierIssuer.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/MessageDigest-browser.js":
/*!****************************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/MessageDigest-browser.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n\nconst crypto = self.crypto || self.msCrypto;\n\n// TODO: synchronous version no longer supported in browser\n\nmodule.exports = class MessageDigest {\n  /**\n   * Creates a new MessageDigest.\n   *\n   * @param algorithm the algorithm to use.\n   */\n  constructor(algorithm) {\n    // check if crypto.subtle is available\n    // check is here rather than top-level to only fail if class is used\n    if(!(crypto && crypto.subtle)) {\n      throw new Error('crypto.subtle not found.');\n    }\n    if(algorithm === 'sha256') {\n      this.algorithm = {name: 'SHA-256'};\n    } else if(algorithm === 'sha1') {\n      this.algorithm = {name: 'SHA-1'};\n    } else {\n      throw new Error(`Unsupport algorithm \"${algorithm}\".`);\n    }\n    this._content = '';\n  }\n\n  update(msg) {\n    this._content += msg;\n  }\n\n  async digest() {\n    const data = new TextEncoder().encode(this._content);\n    const buffer = new Uint8Array(\n      await crypto.subtle.digest(this.algorithm, data));\n    // return digest in hex\n    let hex = '';\n    for(let i = 0; i < buffer.length; ++i) {\n      hex += buffer[i].toString(16).padStart(2, '0');\n    }\n    return hex;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/MessageDigest-browser.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/NQuads.js":
/*!*************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/NQuads.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n// eslint-disable-next-line no-unused-vars\nconst TERMS = ['subject', 'predicate', 'object', 'graph'];\nconst RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nconst RDF_LANGSTRING = RDF + 'langString';\nconst XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';\n\nconst TYPE_NAMED_NODE = 'NamedNode';\nconst TYPE_BLANK_NODE = 'BlankNode';\nconst TYPE_LITERAL = 'Literal';\nconst TYPE_DEFAULT_GRAPH = 'DefaultGraph';\n\n// build regexes\nconst REGEX = {};\n(() => {\n  const iri = '(?:<([^:]+:[^>]*)>)';\n  // https://www.w3.org/TR/turtle/#grammar-production-BLANK_NODE_LABEL\n  const PN_CHARS_BASE =\n    'A-Z' + 'a-z' +\n    '\\u00C0-\\u00D6' +\n    '\\u00D8-\\u00F6' +\n    '\\u00F8-\\u02FF' +\n    '\\u0370-\\u037D' +\n    '\\u037F-\\u1FFF' +\n    '\\u200C-\\u200D' +\n    '\\u2070-\\u218F' +\n    '\\u2C00-\\u2FEF' +\n    '\\u3001-\\uD7FF' +\n    '\\uF900-\\uFDCF' +\n    '\\uFDF0-\\uFFFD';\n    // TODO:\n    //'\\u10000-\\uEFFFF';\n  const PN_CHARS_U =\n    PN_CHARS_BASE +\n    '_';\n  const PN_CHARS =\n    PN_CHARS_U +\n    '0-9' +\n    '-' +\n    '\\u00B7' +\n    '\\u0300-\\u036F' +\n    '\\u203F-\\u2040';\n  const BLANK_NODE_LABEL =\n    '(_:' +\n      '(?:[' + PN_CHARS_U + '0-9])' +\n      '(?:(?:[' + PN_CHARS + '.])*(?:[' + PN_CHARS + ']))?' +\n    ')';\n  const bnode = BLANK_NODE_LABEL;\n  const plain = '\"([^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*)\"';\n  const datatype = '(?:\\\\^\\\\^' + iri + ')';\n  const language = '(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))';\n  const literal = '(?:' + plain + '(?:' + datatype + '|' + language + ')?)';\n  const ws = '[ \\\\t]+';\n  const wso = '[ \\\\t]*';\n\n  // define quad part regexes\n  const subject = '(?:' + iri + '|' + bnode + ')' + ws;\n  const property = iri + ws;\n  const object = '(?:' + iri + '|' + bnode + '|' + literal + ')' + wso;\n  const graphName = '(?:\\\\.|(?:(?:' + iri + '|' + bnode + ')' + wso + '\\\\.))';\n\n  // end of line and empty regexes\n  REGEX.eoln = /(?:\\r\\n)|(?:\\n)|(?:\\r)/g;\n  REGEX.empty = new RegExp('^' + wso + '$');\n\n  // full quad regex\n  REGEX.quad = new RegExp(\n    '^' + wso + subject + property + object + graphName + wso + '$');\n})();\n\nmodule.exports = class NQuads {\n  /**\n   * Parses RDF in the form of N-Quads.\n   *\n   * @param input the N-Quads input to parse.\n   *\n   * @return an RDF dataset (an array of quads per http://rdf.js.org/).\n   */\n  static parse(input) {\n    // build RDF dataset\n    const dataset = [];\n\n    const graphs = {};\n\n    // split N-Quad input into lines\n    const lines = input.split(REGEX.eoln);\n    let lineNumber = 0;\n    for(const line of lines) {\n      lineNumber++;\n\n      // skip empty lines\n      if(REGEX.empty.test(line)) {\n        continue;\n      }\n\n      // parse quad\n      const match = line.match(REGEX.quad);\n      if(match === null) {\n        throw new Error('N-Quads parse error on line ' + lineNumber + '.');\n      }\n\n      // create RDF quad\n      const quad = {subject: null, predicate: null, object: null, graph: null};\n\n      // get subject\n      if(match[1] !== undefined) {\n        quad.subject = {termType: TYPE_NAMED_NODE, value: match[1]};\n      } else {\n        quad.subject = {termType: TYPE_BLANK_NODE, value: match[2]};\n      }\n\n      // get predicate\n      quad.predicate = {termType: TYPE_NAMED_NODE, value: match[3]};\n\n      // get object\n      if(match[4] !== undefined) {\n        quad.object = {termType: TYPE_NAMED_NODE, value: match[4]};\n      } else if(match[5] !== undefined) {\n        quad.object = {termType: TYPE_BLANK_NODE, value: match[5]};\n      } else {\n        quad.object = {\n          termType: TYPE_LITERAL,\n          value: undefined,\n          datatype: {\n            termType: TYPE_NAMED_NODE\n          }\n        };\n        if(match[7] !== undefined) {\n          quad.object.datatype.value = match[7];\n        } else if(match[8] !== undefined) {\n          quad.object.datatype.value = RDF_LANGSTRING;\n          quad.object.language = match[8];\n        } else {\n          quad.object.datatype.value = XSD_STRING;\n        }\n        quad.object.value = _unescape(match[6]);\n      }\n\n      // get graph\n      if(match[9] !== undefined) {\n        quad.graph = {\n          termType: TYPE_NAMED_NODE,\n          value: match[9]\n        };\n      } else if(match[10] !== undefined) {\n        quad.graph = {\n          termType: TYPE_BLANK_NODE,\n          value: match[10]\n        };\n      } else {\n        quad.graph = {\n          termType: TYPE_DEFAULT_GRAPH,\n          value: ''\n        };\n      }\n\n      // only add quad if it is unique in its graph\n      if(!(quad.graph.value in graphs)) {\n        graphs[quad.graph.value] = [quad];\n        dataset.push(quad);\n      } else {\n        let unique = true;\n        const quads = graphs[quad.graph.value];\n        for(const q of quads) {\n          if(_compareTriples(q, quad)) {\n            unique = false;\n            break;\n          }\n        }\n        if(unique) {\n          quads.push(quad);\n          dataset.push(quad);\n        }\n      }\n    }\n\n    return dataset;\n  }\n\n  /**\n   * Converts an RDF dataset to N-Quads.\n   *\n   * @param dataset (array of quads) the RDF dataset to convert.\n   *\n   * @return the N-Quads string.\n   */\n  static serialize(dataset) {\n    if(!Array.isArray(dataset)) {\n      dataset = NQuads.legacyDatasetToQuads(dataset);\n    }\n    const quads = [];\n    for(const quad of dataset) {\n      quads.push(NQuads.serializeQuad(quad));\n    }\n    return quads.sort().join('');\n  }\n\n  /**\n   * Converts an RDF quad to an N-Quad string (a single quad).\n   *\n   * @param quad the RDF quad convert.\n   *\n   * @return the N-Quad string.\n   */\n  static serializeQuad(quad) {\n    const s = quad.subject;\n    const p = quad.predicate;\n    const o = quad.object;\n    const g = quad.graph;\n\n    let nquad = '';\n\n    // subject can only be NamedNode or BlankNode\n    if(s.termType === TYPE_NAMED_NODE) {\n      nquad += `<${s.value}>`;\n    } else {\n      nquad += `${s.value}`;\n    }\n\n    // predicate can only be NamedNode\n    nquad += ` <${p.value}> `;\n\n    // object is NamedNode, BlankNode, or Literal\n    if(o.termType === TYPE_NAMED_NODE) {\n      nquad += `<${o.value}>`;\n    } else if(o.termType === TYPE_BLANK_NODE) {\n      nquad += o.value;\n    } else {\n      nquad += `\"${_escape(o.value)}\"`;\n      if(o.datatype.value === RDF_LANGSTRING) {\n        if(o.language) {\n          nquad += `@${o.language}`;\n        }\n      } else if(o.datatype.value !== XSD_STRING) {\n        nquad += `^^<${o.datatype.value}>`;\n      }\n    }\n\n    // graph can only be NamedNode or BlankNode (or DefaultGraph, but that\n    // does not add to `nquad`)\n    if(g.termType === TYPE_NAMED_NODE) {\n      nquad += ` <${g.value}>`;\n    } else if(g.termType === TYPE_BLANK_NODE) {\n      nquad += ` ${g.value}`;\n    }\n\n    nquad += ' .\\n';\n    return nquad;\n  }\n\n  /**\n   * Converts a legacy-formatted dataset to an array of quads dataset per\n   * http://rdf.js.org/.\n   *\n   * @param dataset the legacy dataset to convert.\n   *\n   * @return the array of quads dataset.\n   */\n  static legacyDatasetToQuads(dataset) {\n    const quads = [];\n\n    const termTypeMap = {\n      'blank node': TYPE_BLANK_NODE,\n      IRI: TYPE_NAMED_NODE,\n      literal: TYPE_LITERAL\n    };\n\n    for(const graphName in dataset) {\n      const triples = dataset[graphName];\n      triples.forEach(triple => {\n        const quad = {};\n        for(const componentName in triple) {\n          const oldComponent = triple[componentName];\n          const newComponent = {\n            termType: termTypeMap[oldComponent.type],\n            value: oldComponent.value\n          };\n          if(newComponent.termType === TYPE_LITERAL) {\n            newComponent.datatype = {\n              termType: TYPE_NAMED_NODE\n            };\n            if('datatype' in oldComponent) {\n              newComponent.datatype.value = oldComponent.datatype;\n            }\n            if('language' in oldComponent) {\n              if(!('datatype' in oldComponent)) {\n                newComponent.datatype.value = RDF_LANGSTRING;\n              }\n              newComponent.language = oldComponent.language;\n            } else if(!('datatype' in oldComponent)) {\n              newComponent.datatype.value = XSD_STRING;\n            }\n          }\n          quad[componentName] = newComponent;\n        }\n        if(graphName === '@default') {\n          quad.graph = {\n            termType: TYPE_DEFAULT_GRAPH,\n            value: ''\n          };\n        } else {\n          quad.graph = {\n            termType: graphName.startsWith('_:') ?\n              TYPE_BLANK_NODE : TYPE_NAMED_NODE,\n            value: graphName\n          };\n        }\n        quads.push(quad);\n      });\n    }\n\n    return quads;\n  }\n};\n\n/**\n * Compares two RDF triples for equality.\n *\n * @param t1 the first triple.\n * @param t2 the second triple.\n *\n * @return true if the triples are the same, false if not.\n */\nfunction _compareTriples(t1, t2) {\n  // compare subject and object types first as it is the quickest check\n  if(!(t1.subject.termType === t2.subject.termType &&\n    t1.object.termType === t2.object.termType)) {\n    return false;\n  }\n  // compare values\n  if(!(t1.subject.value === t2.subject.value &&\n    t1.predicate.value === t2.predicate.value &&\n    t1.object.value === t2.object.value)) {\n    return false;\n  }\n  if(t1.object.termType !== TYPE_LITERAL) {\n    // no `datatype` or `language` to check\n    return true;\n  }\n  return (\n    (t1.object.datatype.termType === t2.object.datatype.termType) &&\n    (t1.object.language === t2.object.language) &&\n    (t1.object.datatype.value === t2.object.datatype.value)\n  );\n}\n\nconst _escapeRegex = /[\"\\\\\\n\\r]/g;\n/**\n * Escape string to N-Quads literal\n */\nfunction _escape(s) {\n  return s.replace(_escapeRegex, function(match) {\n    switch(match) {\n      case '\"': return '\\\\\"';\n      case '\\\\': return '\\\\\\\\';\n      case '\\n': return '\\\\n';\n      case '\\r': return '\\\\r';\n    }\n  });\n}\n\nconst _unescapeRegex =\n  /(?:\\\\([tbnrf\"'\\\\]))|(?:\\\\u([0-9A-Fa-f]{4}))|(?:\\\\U([0-9A-Fa-f]{8}))/g;\n/**\n * Unescape N-Quads literal to string\n */\nfunction _unescape(s) {\n  return s.replace(_unescapeRegex, function(match, code, u, U) {\n    if(code) {\n      switch(code) {\n        case 't': return '\\t';\n        case 'b': return '\\b';\n        case 'n': return '\\n';\n        case 'r': return '\\r';\n        case 'f': return '\\f';\n        case '\"': return '\"';\n        case '\\'': return '\\'';\n        case '\\\\': return '\\\\';\n      }\n    }\n    if(u) {\n      return String.fromCharCode(parseInt(u, 16));\n    }\n    if(U) {\n      // FIXME: support larger values\n      throw new Error('Unsupported U escape');\n    }\n  });\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/NQuads.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/Permuter.js":
/*!***************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/Permuter.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n// TODO: convert to ES6 iterable?\n\nmodule.exports = class Permuter {\n  /**\n   * A Permuter iterates over all possible permutations of the given array\n   * of elements.\n   *\n   * @param list the array of elements to iterate over.\n   */\n  constructor(list) {\n    // original array\n    this.current = list.sort();\n    // indicates whether there are more permutations\n    this.done = false;\n    // directional info for permutation algorithm\n    this.dir = new Map();\n    for(let i = 0; i < list.length; ++i) {\n      this.dir.set(list[i], true);\n    }\n  }\n\n  /**\n   * Returns true if there is another permutation.\n   *\n   * @return true if there is another permutation, false if not.\n   */\n  hasNext() {\n    return !this.done;\n  }\n\n  /**\n   * Gets the next permutation. Call hasNext() to ensure there is another one\n   * first.\n   *\n   * @return the next permutation.\n   */\n  next() {\n    // copy current permutation to return it\n    const {current, dir} = this;\n    const rval = current.slice();\n\n    /* Calculate the next permutation using the Steinhaus-Johnson-Trotter\n     permutation algorithm. */\n\n    // get largest mobile element k\n    // (mobile: element is greater than the one it is looking at)\n    let k = null;\n    let pos = 0;\n    const length = current.length;\n    for(let i = 0; i < length; ++i) {\n      const element = current[i];\n      const left = dir.get(element);\n      if((k === null || element > k) &&\n        ((left && i > 0 && element > current[i - 1]) ||\n        (!left && i < (length - 1) && element > current[i + 1]))) {\n        k = element;\n        pos = i;\n      }\n    }\n\n    // no more permutations\n    if(k === null) {\n      this.done = true;\n    } else {\n      // swap k and the element it is looking at\n      const swap = dir.get(k) ? pos - 1 : pos + 1;\n      current[pos] = current[swap];\n      current[swap] = k;\n\n      // reverse the direction of all elements larger than k\n      for(const element of current) {\n        if(element > k) {\n          dir.set(element, !dir.get(element));\n        }\n      }\n    }\n\n    return rval;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/Permuter.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/URDNA2015.js":
/*!****************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/URDNA2015.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst IdentifierIssuer = __webpack_require__(/*! ./IdentifierIssuer */ \"./node_modules/rdf-canonize/lib/IdentifierIssuer.js\");\nconst MessageDigest = __webpack_require__(/*! ./MessageDigest */ \"./node_modules/rdf-canonize/lib/MessageDigest-browser.js\");\nconst Permuter = __webpack_require__(/*! ./Permuter */ \"./node_modules/rdf-canonize/lib/Permuter.js\");\nconst NQuads = __webpack_require__(/*! ./NQuads */ \"./node_modules/rdf-canonize/lib/NQuads.js\");\n\nmodule.exports = class URDNA2015 {\n  constructor() {\n    this.name = 'URDNA2015';\n    this.blankNodeInfo = new Map();\n    this.canonicalIssuer = new IdentifierIssuer('_:c14n');\n    this.hashAlgorithm = 'sha256';\n    this.quads = null;\n  }\n\n  // 4.4) Normalization Algorithm\n  async main(dataset) {\n    this.quads = dataset;\n\n    // 1) Create the normalization state.\n    // 2) For every quad in input dataset:\n    for(const quad of dataset) {\n      // 2.1) For each blank node that occurs in the quad, add a reference\n      // to the quad using the blank node identifier in the blank node to\n      // quads map, creating a new entry if necessary.\n      this._addBlankNodeQuadInfo({quad, component: quad.subject});\n      this._addBlankNodeQuadInfo({quad, component: quad.object});\n      this._addBlankNodeQuadInfo({quad, component: quad.graph});\n    }\n\n    // 3) Create a list of non-normalized blank node identifiers\n    // non-normalized identifiers and populate it using the keys from the\n    // blank node to quads map.\n    // Note: We use a map here and it was generated during step 2.\n\n    // 4) `simple` flag is skipped -- loop is optimized away. This optimization\n    // is permitted because there was a typo in the hash first degree quads\n    // algorithm in the URDNA2015 spec that was implemented widely making it\n    // such that it could not be fixed; the result was that the loop only\n    // needs to be run once and the first degree quad hashes will never change.\n    // 5.1-5.2 are skipped; first degree quad hashes are generated just once\n    // for all non-normalized blank nodes.\n\n    // 5.3) For each blank node identifier identifier in non-normalized\n    // identifiers:\n    const hashToBlankNodes = new Map();\n    const nonNormalized = [...this.blankNodeInfo.keys()];\n    let i = 0;\n    for(const id of nonNormalized) {\n      // Note: batch hashing first degree quads 100 at a time\n      if(++i % 100 === 0) {\n        await this._yield();\n      }\n      // steps 5.3.1 and 5.3.2:\n      await this._hashAndTrackBlankNode({id, hashToBlankNodes});\n    }\n\n    // 5.4) For each hash to identifier list mapping in hash to blank\n    // nodes map, lexicographically-sorted by hash:\n    const hashes = [...hashToBlankNodes.keys()].sort();\n    // optimize away second sort, gather non-unique hashes in order as we go\n    const nonUnique = [];\n    for(const hash of hashes) {\n      // 5.4.1) If the length of identifier list is greater than 1,\n      // continue to the next mapping.\n      const idList = hashToBlankNodes.get(hash);\n      if(idList.length > 1) {\n        nonUnique.push(idList);\n        continue;\n      }\n\n      // 5.4.2) Use the Issue Identifier algorithm, passing canonical\n      // issuer and the single blank node identifier in identifier\n      // list, identifier, to issue a canonical replacement identifier\n      // for identifier.\n      const id = idList[0];\n      this.canonicalIssuer.getId(id);\n\n      // Note: These steps are skipped, optimized away since the loop\n      // only needs to be run once.\n      // 5.4.3) Remove identifier from non-normalized identifiers.\n      // 5.4.4) Remove hash from the hash to blank nodes map.\n      // 5.4.5) Set simple to true.\n    }\n\n    // 6) For each hash to identifier list mapping in hash to blank nodes map,\n    // lexicographically-sorted by hash:\n    // Note: sort optimized away, use `nonUnique`.\n    for(const idList of nonUnique) {\n      // 6.1) Create hash path list where each item will be a result of\n      // running the Hash N-Degree Quads algorithm.\n      const hashPathList = [];\n\n      // 6.2) For each blank node identifier identifier in identifier list:\n      for(const id of idList) {\n        // 6.2.1) If a canonical identifier has already been issued for\n        // identifier, continue to the next identifier.\n        if(this.canonicalIssuer.hasId(id)) {\n          continue;\n        }\n\n        // 6.2.2) Create temporary issuer, an identifier issuer\n        // initialized with the prefix _:b.\n        const issuer = new IdentifierIssuer('_:b');\n\n        // 6.2.3) Use the Issue Identifier algorithm, passing temporary\n        // issuer and identifier, to issue a new temporary blank node\n        // identifier for identifier.\n        issuer.getId(id);\n\n        // 6.2.4) Run the Hash N-Degree Quads algorithm, passing\n        // temporary issuer, and append the result to the hash path list.\n        const result = await this.hashNDegreeQuads(id, issuer);\n        hashPathList.push(result);\n      }\n\n      // 6.3) For each result in the hash path list,\n      // lexicographically-sorted by the hash in result:\n      hashPathList.sort(_stringHashCompare);\n      for(const result of hashPathList) {\n        // 6.3.1) For each blank node identifier, existing identifier,\n        // that was issued a temporary identifier by identifier issuer\n        // in result, issue a canonical identifier, in the same order,\n        // using the Issue Identifier algorithm, passing canonical\n        // issuer and existing identifier.\n        const oldIds = result.issuer.getOldIds();\n        for(const id of oldIds) {\n          this.canonicalIssuer.getId(id);\n        }\n      }\n    }\n\n    /* Note: At this point all blank nodes in the set of RDF quads have been\n    assigned canonical identifiers, which have been stored in the canonical\n    issuer. Here each quad is updated by assigning each of its blank nodes\n    its new identifier. */\n\n    // 7) For each quad, quad, in input dataset:\n    const normalized = [];\n    for(const quad of this.quads) {\n      // 7.1) Create a copy, quad copy, of quad and replace any existing\n      // blank node identifiers using the canonical identifiers\n      // previously issued by canonical issuer.\n      // Note: We optimize with shallow copies here.\n      const q = {...quad};\n      q.subject = this._useCanonicalId({component: q.subject});\n      q.object = this._useCanonicalId({component: q.object});\n      q.graph = this._useCanonicalId({component: q.graph});\n      // 7.2) Add quad copy to the normalized dataset.\n      normalized.push(NQuads.serializeQuad(q));\n    }\n\n    // sort normalized output\n    normalized.sort();\n\n    // 8) Return the normalized dataset.\n    return normalized.join('');\n  }\n\n  // 4.6) Hash First Degree Quads\n  async hashFirstDegreeQuads(id) {\n    // 1) Initialize nquads to an empty list. It will be used to store quads in\n    // N-Quads format.\n    const nquads = [];\n\n    // 2) Get the list of quads `quads` associated with the reference blank node\n    // identifier in the blank node to quads map.\n    const info = this.blankNodeInfo.get(id);\n    const quads = info.quads;\n\n    // 3) For each quad `quad` in `quads`:\n    for(const quad of quads) {\n      // 3.1) Serialize the quad in N-Quads format with the following special\n      // rule:\n\n      // 3.1.1) If any component in quad is an blank node, then serialize it\n      // using a special identifier as follows:\n      const copy = {\n        subject: null, predicate: quad.predicate, object: null, graph: null\n      };\n      // 3.1.2) If the blank node's existing blank node identifier matches\n      // the reference blank node identifier then use the blank node\n      // identifier _:a, otherwise, use the blank node identifier _:z.\n      copy.subject = this.modifyFirstDegreeComponent(\n        id, quad.subject, 'subject');\n      copy.object = this.modifyFirstDegreeComponent(\n        id, quad.object, 'object');\n      copy.graph = this.modifyFirstDegreeComponent(\n        id, quad.graph, 'graph');\n      nquads.push(NQuads.serializeQuad(copy));\n    }\n\n    // 4) Sort nquads in lexicographical order.\n    nquads.sort();\n\n    // 5) Return the hash that results from passing the sorted, joined nquads\n    // through the hash algorithm.\n    const md = new MessageDigest(this.hashAlgorithm);\n    for(const nquad of nquads) {\n      md.update(nquad);\n    }\n    info.hash = await md.digest();\n    return info.hash;\n  }\n\n  // 4.7) Hash Related Blank Node\n  async hashRelatedBlankNode(related, quad, issuer, position) {\n    // 1) Set the identifier to use for related, preferring first the canonical\n    // identifier for related if issued, second the identifier issued by issuer\n    // if issued, and last, if necessary, the result of the Hash First Degree\n    // Quads algorithm, passing related.\n    let id;\n    if(this.canonicalIssuer.hasId(related)) {\n      id = this.canonicalIssuer.getId(related);\n    } else if(issuer.hasId(related)) {\n      id = issuer.getId(related);\n    } else {\n      id = this.blankNodeInfo.get(related).hash;\n    }\n\n    // 2) Initialize a string input to the value of position.\n    // Note: We use a hash object instead.\n    const md = new MessageDigest(this.hashAlgorithm);\n    md.update(position);\n\n    // 3) If position is not g, append <, the value of the predicate in quad,\n    // and > to input.\n    if(position !== 'g') {\n      md.update(this.getRelatedPredicate(quad));\n    }\n\n    // 4) Append identifier to input.\n    md.update(id);\n\n    // 5) Return the hash that results from passing input through the hash\n    // algorithm.\n    return md.digest();\n  }\n\n  // 4.8) Hash N-Degree Quads\n  async hashNDegreeQuads(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    // Note: 2) and 3) handled within `createHashToRelated`\n    const md = new MessageDigest(this.hashAlgorithm);\n    const hashToRelated = await this.createHashToRelated(id, issuer);\n\n    // 4) Create an empty string, data to hash.\n    // Note: We created a hash object `md` above instead.\n\n    // 5) For each related hash to blank node list mapping in hash to related\n    // blank nodes map, sorted lexicographically by related hash:\n    const hashes = [...hashToRelated.keys()].sort();\n    for(const hash of hashes) {\n      // 5.1) Append the related hash to the data to hash.\n      md.update(hash);\n\n      // 5.2) Create a string chosen path.\n      let chosenPath = '';\n\n      // 5.3) Create an unset chosen issuer variable.\n      let chosenIssuer;\n\n      // 5.4) For each permutation of blank node list:\n      const permuter = new Permuter(hashToRelated.get(hash));\n      let i = 0;\n      while(permuter.hasNext()) {\n        const permutation = permuter.next();\n        // Note: batch permutations 3 at a time\n        if(++i % 3 === 0) {\n          await this._yield();\n        }\n\n        // 5.4.1) Create a copy of issuer, issuer copy.\n        let issuerCopy = issuer.clone();\n\n        // 5.4.2) Create a string path.\n        let path = '';\n\n        // 5.4.3) Create a recursion list, to store blank node identifiers\n        // that must be recursively processed by this algorithm.\n        const recursionList = [];\n\n        // 5.4.4) For each related in permutation:\n        let nextPermutation = false;\n        for(const related of permutation) {\n          // 5.4.4.1) If a canonical identifier has been issued for\n          // related, append it to path.\n          if(this.canonicalIssuer.hasId(related)) {\n            path += this.canonicalIssuer.getId(related);\n          } else {\n            // 5.4.4.2) Otherwise:\n            // 5.4.4.2.1) If issuer copy has not issued an identifier for\n            // related, append related to recursion list.\n            if(!issuerCopy.hasId(related)) {\n              recursionList.push(related);\n            }\n            // 5.4.4.2.2) Use the Issue Identifier algorithm, passing\n            // issuer copy and related and append the result to path.\n            path += issuerCopy.getId(related);\n          }\n\n          // 5.4.4.3) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.5) For each related in recursion list:\n        for(const related of recursionList) {\n          // 5.4.5.1) Set result to the result of recursively executing\n          // the Hash N-Degree Quads algorithm, passing related for\n          // identifier and issuer copy for path identifier issuer.\n          const result = await this.hashNDegreeQuads(related, issuerCopy);\n\n          // 5.4.5.2) Use the Issue Identifier algorithm, passing issuer\n          // copy and related and append the result to path.\n          path += issuerCopy.getId(related);\n\n          // 5.4.5.3) Append <, the hash in result, and > to path.\n          path += `<${result.hash}>`;\n\n          // 5.4.5.4) Set issuer copy to the identifier issuer in\n          // result.\n          issuerCopy = result.issuer;\n\n          // 5.4.5.5) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.6) If chosen path is empty or path is lexicographically\n        // less than chosen path, set chosen path to path and chosen\n        // issuer to issuer copy.\n        if(chosenPath.length === 0 || path < chosenPath) {\n          chosenPath = path;\n          chosenIssuer = issuerCopy;\n        }\n      }\n\n      // 5.5) Append chosen path to data to hash.\n      md.update(chosenPath);\n\n      // 5.6) Replace issuer, by reference, with chosen issuer.\n      issuer = chosenIssuer;\n    }\n\n    // 6) Return issuer and the hash that results from passing data to hash\n    // through the hash algorithm.\n    return {hash: await md.digest(), issuer};\n  }\n\n  // helper for modifying component during Hash First Degree Quads\n  modifyFirstDegreeComponent(id, component) {\n    if(component.termType !== 'BlankNode') {\n      return component;\n    }\n    /* Note: A mistake in the URDNA2015 spec that made its way into\n    implementations (and therefore must stay to avoid interop breakage)\n    resulted in an assigned canonical ID, if available for\n    `component.value`, not being used in place of `_:a`/`_:z`, so\n    we don't use it here. */\n    return {\n      termType: 'BlankNode',\n      value: component.value === id ? '_:a' : '_:z'\n    };\n  }\n\n  // helper for getting a related predicate\n  getRelatedPredicate(quad) {\n    return `<${quad.predicate.value}>`;\n  }\n\n  // helper for creating hash to related blank nodes map\n  async createHashToRelated(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    const hashToRelated = new Map();\n\n    // 2) Get a reference, quads, to the list of quads in the blank node to\n    // quads map for the key identifier.\n    const quads = this.blankNodeInfo.get(id).quads;\n\n    // 3) For each quad in quads:\n    let i = 0;\n    for(const quad of quads) {\n      // Note: batch hashing related blank node quads 100 at a time\n      if(++i % 100 === 0) {\n        await this._yield();\n      }\n      // 3.1) For each component in quad, if component is the subject, object,\n      // and graph name and it is a blank node that is not identified by\n      // identifier:\n      // steps 3.1.1 and 3.1.2 occur in helpers:\n      await Promise.all([\n        this._addRelatedBlankNodeHash({\n          quad, component: quad.subject, position: 's',\n          id, issuer, hashToRelated\n        }),\n        this._addRelatedBlankNodeHash({\n          quad, component: quad.object, position: 'o',\n          id, issuer, hashToRelated\n        }),\n        this._addRelatedBlankNodeHash({\n          quad, component: quad.graph, position: 'g',\n          id, issuer, hashToRelated\n        })\n      ]);\n    }\n\n    return hashToRelated;\n  }\n\n  async _hashAndTrackBlankNode({id, hashToBlankNodes}) {\n    // 5.3.1) Create a hash, hash, according to the Hash First Degree\n    // Quads algorithm.\n    const hash = await this.hashFirstDegreeQuads(id);\n\n    // 5.3.2) Add hash and identifier to hash to blank nodes map,\n    // creating a new entry if necessary.\n    const idList = hashToBlankNodes.get(hash);\n    if(!idList) {\n      hashToBlankNodes.set(hash, [id]);\n    } else {\n      idList.push(id);\n    }\n  }\n\n  _addBlankNodeQuadInfo({quad, component}) {\n    if(component.termType !== 'BlankNode') {\n      return;\n    }\n    const id = component.value;\n    const info = this.blankNodeInfo.get(id);\n    if(info) {\n      info.quads.add(quad);\n    } else {\n      this.blankNodeInfo.set(id, {quads: new Set([quad]), hash: null});\n    }\n  }\n\n  async _addRelatedBlankNodeHash(\n    {quad, component, position, id, issuer, hashToRelated}) {\n    if(!(component.termType === 'BlankNode' && component.value !== id)) {\n      return;\n    }\n    // 3.1.1) Set hash to the result of the Hash Related Blank Node\n    // algorithm, passing the blank node identifier for component as\n    // related, quad, path identifier issuer as issuer, and position as\n    // either s, o, or g based on whether component is a subject, object,\n    // graph name, respectively.\n    const related = component.value;\n    const hash = await this.hashRelatedBlankNode(\n      related, quad, issuer, position);\n\n    // 3.1.2) Add a mapping of hash to the blank node identifier for\n    // component to hash to related blank nodes map, adding an entry as\n    // necessary.\n    const entries = hashToRelated.get(hash);\n    if(entries) {\n      entries.push(related);\n    } else {\n      hashToRelated.set(hash, [related]);\n    }\n  }\n\n  _useCanonicalId({component}) {\n    if(component.termType === 'BlankNode' &&\n      !component.value.startsWith(this.canonicalIssuer.prefix)) {\n      return {\n        termType: 'BlankNode',\n        value: this.canonicalIssuer.getId(component.value)\n      };\n    }\n    return component;\n  }\n\n  async _yield() {\n    return new Promise(resolve => setImmediate(resolve));\n  }\n};\n\nfunction _stringHashCompare(a, b) {\n  return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/URDNA2015.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/URDNA2015Sync.js":
/*!********************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/URDNA2015Sync.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst IdentifierIssuer = __webpack_require__(/*! ./IdentifierIssuer */ \"./node_modules/rdf-canonize/lib/IdentifierIssuer.js\");\nconst MessageDigest = __webpack_require__(/*! ./MessageDigest */ \"./node_modules/rdf-canonize/lib/MessageDigest-browser.js\");\nconst Permuter = __webpack_require__(/*! ./Permuter */ \"./node_modules/rdf-canonize/lib/Permuter.js\");\nconst NQuads = __webpack_require__(/*! ./NQuads */ \"./node_modules/rdf-canonize/lib/NQuads.js\");\n\nmodule.exports = class URDNA2015Sync {\n  constructor() {\n    this.name = 'URDNA2015';\n    this.blankNodeInfo = new Map();\n    this.canonicalIssuer = new IdentifierIssuer('_:c14n');\n    this.hashAlgorithm = 'sha256';\n    this.quads = null;\n  }\n\n  // 4.4) Normalization Algorithm\n  main(dataset) {\n    this.quads = dataset;\n\n    // 1) Create the normalization state.\n    // 2) For every quad in input dataset:\n    for(const quad of dataset) {\n      // 2.1) For each blank node that occurs in the quad, add a reference\n      // to the quad using the blank node identifier in the blank node to\n      // quads map, creating a new entry if necessary.\n      this._addBlankNodeQuadInfo({quad, component: quad.subject});\n      this._addBlankNodeQuadInfo({quad, component: quad.object});\n      this._addBlankNodeQuadInfo({quad, component: quad.graph});\n    }\n\n    // 3) Create a list of non-normalized blank node identifiers\n    // non-normalized identifiers and populate it using the keys from the\n    // blank node to quads map.\n    // Note: We use a map here and it was generated during step 2.\n\n    // 4) `simple` flag is skipped -- loop is optimized away. This optimization\n    // is permitted because there was a typo in the hash first degree quads\n    // algorithm in the URDNA2015 spec that was implemented widely making it\n    // such that it could not be fixed; the result was that the loop only\n    // needs to be run once and the first degree quad hashes will never change.\n    // 5.1-5.2 are skipped; first degree quad hashes are generated just once\n    // for all non-normalized blank nodes.\n\n    // 5.3) For each blank node identifier identifier in non-normalized\n    // identifiers:\n    const hashToBlankNodes = new Map();\n    const nonNormalized = [...this.blankNodeInfo.keys()];\n    for(const id of nonNormalized) {\n      // steps 5.3.1 and 5.3.2:\n      this._hashAndTrackBlankNode({id, hashToBlankNodes});\n    }\n\n    // 5.4) For each hash to identifier list mapping in hash to blank\n    // nodes map, lexicographically-sorted by hash:\n    const hashes = [...hashToBlankNodes.keys()].sort();\n    // optimize away second sort, gather non-unique hashes in order as we go\n    const nonUnique = [];\n    for(const hash of hashes) {\n      // 5.4.1) If the length of identifier list is greater than 1,\n      // continue to the next mapping.\n      const idList = hashToBlankNodes.get(hash);\n      if(idList.length > 1) {\n        nonUnique.push(idList);\n        continue;\n      }\n\n      // 5.4.2) Use the Issue Identifier algorithm, passing canonical\n      // issuer and the single blank node identifier in identifier\n      // list, identifier, to issue a canonical replacement identifier\n      // for identifier.\n      const id = idList[0];\n      this.canonicalIssuer.getId(id);\n\n      // Note: These steps are skipped, optimized away since the loop\n      // only needs to be run once.\n      // 5.4.3) Remove identifier from non-normalized identifiers.\n      // 5.4.4) Remove hash from the hash to blank nodes map.\n      // 5.4.5) Set simple to true.\n    }\n\n    // 6) For each hash to identifier list mapping in hash to blank nodes map,\n    // lexicographically-sorted by hash:\n    // Note: sort optimized away, use `nonUnique`.\n    for(const idList of nonUnique) {\n      // 6.1) Create hash path list where each item will be a result of\n      // running the Hash N-Degree Quads algorithm.\n      const hashPathList = [];\n\n      // 6.2) For each blank node identifier identifier in identifier list:\n      for(const id of idList) {\n        // 6.2.1) If a canonical identifier has already been issued for\n        // identifier, continue to the next identifier.\n        if(this.canonicalIssuer.hasId(id)) {\n          continue;\n        }\n\n        // 6.2.2) Create temporary issuer, an identifier issuer\n        // initialized with the prefix _:b.\n        const issuer = new IdentifierIssuer('_:b');\n\n        // 6.2.3) Use the Issue Identifier algorithm, passing temporary\n        // issuer and identifier, to issue a new temporary blank node\n        // identifier for identifier.\n        issuer.getId(id);\n\n        // 6.2.4) Run the Hash N-Degree Quads algorithm, passing\n        // temporary issuer, and append the result to the hash path list.\n        const result = this.hashNDegreeQuads(id, issuer);\n        hashPathList.push(result);\n      }\n\n      // 6.3) For each result in the hash path list,\n      // lexicographically-sorted by the hash in result:\n      hashPathList.sort(_stringHashCompare);\n      for(const result of hashPathList) {\n        // 6.3.1) For each blank node identifier, existing identifier,\n        // that was issued a temporary identifier by identifier issuer\n        // in result, issue a canonical identifier, in the same order,\n        // using the Issue Identifier algorithm, passing canonical\n        // issuer and existing identifier.\n        const oldIds = result.issuer.getOldIds();\n        for(const id of oldIds) {\n          this.canonicalIssuer.getId(id);\n        }\n      }\n    }\n\n    /* Note: At this point all blank nodes in the set of RDF quads have been\n    assigned canonical identifiers, which have been stored in the canonical\n    issuer. Here each quad is updated by assigning each of its blank nodes\n    its new identifier. */\n\n    // 7) For each quad, quad, in input dataset:\n    const normalized = [];\n    for(const quad of this.quads) {\n      // 7.1) Create a copy, quad copy, of quad and replace any existing\n      // blank node identifiers using the canonical identifiers\n      // previously issued by canonical issuer.\n      // Note: We optimize with shallow copies here.\n      const q = {...quad};\n      q.subject = this._useCanonicalId({component: q.subject});\n      q.object = this._useCanonicalId({component: q.object});\n      q.graph = this._useCanonicalId({component: q.graph});\n      // 7.2) Add quad copy to the normalized dataset.\n      normalized.push(NQuads.serializeQuad(q));\n    }\n\n    // sort normalized output\n    normalized.sort();\n\n    // 8) Return the normalized dataset.\n    return normalized.join('');\n  }\n\n  // 4.6) Hash First Degree Quads\n  hashFirstDegreeQuads(id) {\n    // 1) Initialize nquads to an empty list. It will be used to store quads in\n    // N-Quads format.\n    const nquads = [];\n\n    // 2) Get the list of quads `quads` associated with the reference blank node\n    // identifier in the blank node to quads map.\n    const info = this.blankNodeInfo.get(id);\n    const quads = info.quads;\n\n    // 3) For each quad `quad` in `quads`:\n    for(const quad of quads) {\n      // 3.1) Serialize the quad in N-Quads format with the following special\n      // rule:\n\n      // 3.1.1) If any component in quad is an blank node, then serialize it\n      // using a special identifier as follows:\n      const copy = {\n        subject: null, predicate: quad.predicate, object: null, graph: null\n      };\n      // 3.1.2) If the blank node's existing blank node identifier matches\n      // the reference blank node identifier then use the blank node\n      // identifier _:a, otherwise, use the blank node identifier _:z.\n      copy.subject = this.modifyFirstDegreeComponent(\n        id, quad.subject, 'subject');\n      copy.object = this.modifyFirstDegreeComponent(\n        id, quad.object, 'object');\n      copy.graph = this.modifyFirstDegreeComponent(\n        id, quad.graph, 'graph');\n      nquads.push(NQuads.serializeQuad(copy));\n    }\n\n    // 4) Sort nquads in lexicographical order.\n    nquads.sort();\n\n    // 5) Return the hash that results from passing the sorted, joined nquads\n    // through the hash algorithm.\n    const md = new MessageDigest(this.hashAlgorithm);\n    for(const nquad of nquads) {\n      md.update(nquad);\n    }\n    info.hash = md.digest();\n    return info.hash;\n  }\n\n  // 4.7) Hash Related Blank Node\n  hashRelatedBlankNode(related, quad, issuer, position) {\n    // 1) Set the identifier to use for related, preferring first the canonical\n    // identifier for related if issued, second the identifier issued by issuer\n    // if issued, and last, if necessary, the result of the Hash First Degree\n    // Quads algorithm, passing related.\n    let id;\n    if(this.canonicalIssuer.hasId(related)) {\n      id = this.canonicalIssuer.getId(related);\n    } else if(issuer.hasId(related)) {\n      id = issuer.getId(related);\n    } else {\n      id = this.blankNodeInfo.get(related).hash;\n    }\n\n    // 2) Initialize a string input to the value of position.\n    // Note: We use a hash object instead.\n    const md = new MessageDigest(this.hashAlgorithm);\n    md.update(position);\n\n    // 3) If position is not g, append <, the value of the predicate in quad,\n    // and > to input.\n    if(position !== 'g') {\n      md.update(this.getRelatedPredicate(quad));\n    }\n\n    // 4) Append identifier to input.\n    md.update(id);\n\n    // 5) Return the hash that results from passing input through the hash\n    // algorithm.\n    return md.digest();\n  }\n\n  // 4.8) Hash N-Degree Quads\n  hashNDegreeQuads(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    // Note: 2) and 3) handled within `createHashToRelated`\n    const md = new MessageDigest(this.hashAlgorithm);\n    const hashToRelated = this.createHashToRelated(id, issuer);\n\n    // 4) Create an empty string, data to hash.\n    // Note: We created a hash object `md` above instead.\n\n    // 5) For each related hash to blank node list mapping in hash to related\n    // blank nodes map, sorted lexicographically by related hash:\n    const hashes = [...hashToRelated.keys()].sort();\n    for(const hash of hashes) {\n      // 5.1) Append the related hash to the data to hash.\n      md.update(hash);\n\n      // 5.2) Create a string chosen path.\n      let chosenPath = '';\n\n      // 5.3) Create an unset chosen issuer variable.\n      let chosenIssuer;\n\n      // 5.4) For each permutation of blank node list:\n      const permuter = new Permuter(hashToRelated.get(hash));\n      while(permuter.hasNext()) {\n        const permutation = permuter.next();\n\n        // 5.4.1) Create a copy of issuer, issuer copy.\n        let issuerCopy = issuer.clone();\n\n        // 5.4.2) Create a string path.\n        let path = '';\n\n        // 5.4.3) Create a recursion list, to store blank node identifiers\n        // that must be recursively processed by this algorithm.\n        const recursionList = [];\n\n        // 5.4.4) For each related in permutation:\n        let nextPermutation = false;\n        for(const related of permutation) {\n          // 5.4.4.1) If a canonical identifier has been issued for\n          // related, append it to path.\n          if(this.canonicalIssuer.hasId(related)) {\n            path += this.canonicalIssuer.getId(related);\n          } else {\n            // 5.4.4.2) Otherwise:\n            // 5.4.4.2.1) If issuer copy has not issued an identifier for\n            // related, append related to recursion list.\n            if(!issuerCopy.hasId(related)) {\n              recursionList.push(related);\n            }\n            // 5.4.4.2.2) Use the Issue Identifier algorithm, passing\n            // issuer copy and related and append the result to path.\n            path += issuerCopy.getId(related);\n          }\n\n          // 5.4.4.3) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.5) For each related in recursion list:\n        for(const related of recursionList) {\n          // 5.4.5.1) Set result to the result of recursively executing\n          // the Hash N-Degree Quads algorithm, passing related for\n          // identifier and issuer copy for path identifier issuer.\n          const result = this.hashNDegreeQuads(related, issuerCopy);\n\n          // 5.4.5.2) Use the Issue Identifier algorithm, passing issuer\n          // copy and related and append the result to path.\n          path += issuerCopy.getId(related);\n\n          // 5.4.5.3) Append <, the hash in result, and > to path.\n          path += `<${result.hash}>`;\n\n          // 5.4.5.4) Set issuer copy to the identifier issuer in\n          // result.\n          issuerCopy = result.issuer;\n\n          // 5.4.5.5) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.6) If chosen path is empty or path is lexicographically\n        // less than chosen path, set chosen path to path and chosen\n        // issuer to issuer copy.\n        if(chosenPath.length === 0 || path < chosenPath) {\n          chosenPath = path;\n          chosenIssuer = issuerCopy;\n        }\n      }\n\n      // 5.5) Append chosen path to data to hash.\n      md.update(chosenPath);\n\n      // 5.6) Replace issuer, by reference, with chosen issuer.\n      issuer = chosenIssuer;\n    }\n\n    // 6) Return issuer and the hash that results from passing data to hash\n    // through the hash algorithm.\n    return {hash: md.digest(), issuer};\n  }\n\n  // helper for modifying component during Hash First Degree Quads\n  modifyFirstDegreeComponent(id, component) {\n    if(component.termType !== 'BlankNode') {\n      return component;\n    }\n    /* Note: A mistake in the URDNA2015 spec that made its way into\n    implementations (and therefore must stay to avoid interop breakage)\n    resulted in an assigned canonical ID, if available for\n    `component.value`, not being used in place of `_:a`/`_:z`, so\n    we don't use it here. */\n    return {\n      termType: 'BlankNode',\n      value: component.value === id ? '_:a' : '_:z'\n    };\n  }\n\n  // helper for getting a related predicate\n  getRelatedPredicate(quad) {\n    return `<${quad.predicate.value}>`;\n  }\n\n  // helper for creating hash to related blank nodes map\n  createHashToRelated(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    const hashToRelated = new Map();\n\n    // 2) Get a reference, quads, to the list of quads in the blank node to\n    // quads map for the key identifier.\n    const quads = this.blankNodeInfo.get(id).quads;\n\n    // 3) For each quad in quads:\n    for(const quad of quads) {\n      // 3.1) For each component in quad, if component is the subject, object,\n      // or graph name and it is a blank node that is not identified by\n      // identifier:\n      // steps 3.1.1 and 3.1.2 occur in helpers:\n      this._addRelatedBlankNodeHash({\n        quad, component: quad.subject, position: 's',\n        id, issuer, hashToRelated\n      });\n      this._addRelatedBlankNodeHash({\n        quad, component: quad.object, position: 'o',\n        id, issuer, hashToRelated\n      });\n      this._addRelatedBlankNodeHash({\n        quad, component: quad.graph, position: 'g',\n        id, issuer, hashToRelated\n      });\n    }\n\n    return hashToRelated;\n  }\n\n  _hashAndTrackBlankNode({id, hashToBlankNodes}) {\n    // 5.3.1) Create a hash, hash, according to the Hash First Degree\n    // Quads algorithm.\n    const hash = this.hashFirstDegreeQuads(id);\n\n    // 5.3.2) Add hash and identifier to hash to blank nodes map,\n    // creating a new entry if necessary.\n    const idList = hashToBlankNodes.get(hash);\n    if(!idList) {\n      hashToBlankNodes.set(hash, [id]);\n    } else {\n      idList.push(id);\n    }\n  }\n\n  _addBlankNodeQuadInfo({quad, component}) {\n    if(component.termType !== 'BlankNode') {\n      return;\n    }\n    const id = component.value;\n    const info = this.blankNodeInfo.get(id);\n    if(info) {\n      info.quads.add(quad);\n    } else {\n      this.blankNodeInfo.set(id, {quads: new Set([quad]), hash: null});\n    }\n  }\n\n  _addRelatedBlankNodeHash(\n    {quad, component, position, id, issuer, hashToRelated}) {\n    if(!(component.termType === 'BlankNode' && component.value !== id)) {\n      return;\n    }\n    // 3.1.1) Set hash to the result of the Hash Related Blank Node\n    // algorithm, passing the blank node identifier for component as\n    // related, quad, path identifier issuer as issuer, and position as\n    // either s, o, or g based on whether component is a subject, object,\n    // graph name, respectively.\n    const related = component.value;\n    const hash = this.hashRelatedBlankNode(related, quad, issuer, position);\n\n    // 3.1.2) Add a mapping of hash to the blank node identifier for\n    // component to hash to related blank nodes map, adding an entry as\n    // necessary.\n    const entries = hashToRelated.get(hash);\n    if(entries) {\n      entries.push(related);\n    } else {\n      hashToRelated.set(hash, [related]);\n    }\n  }\n\n  _useCanonicalId({component}) {\n    if(component.termType === 'BlankNode' &&\n      !component.value.startsWith(this.canonicalIssuer.prefix)) {\n      return {\n        termType: 'BlankNode',\n        value: this.canonicalIssuer.getId(component.value)\n      };\n    }\n    return component;\n  }\n};\n\nfunction _stringHashCompare(a, b) {\n  return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/URDNA2015Sync.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/URGNA2012.js":
/*!****************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/URGNA2012.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst URDNA2015 = __webpack_require__(/*! ./URDNA2015 */ \"./node_modules/rdf-canonize/lib/URDNA2015.js\");\n\nmodule.exports = class URDNA2012 extends URDNA2015 {\n  constructor() {\n    super();\n    this.name = 'URGNA2012';\n    this.hashAlgorithm = 'sha1';\n  }\n\n  // helper for modifying component during Hash First Degree Quads\n  modifyFirstDegreeComponent(id, component, key) {\n    if(component.termType !== 'BlankNode') {\n      return component;\n    }\n    if(key === 'graph') {\n      return {\n        termType: 'BlankNode',\n        value: '_:g'\n      };\n    }\n    return {\n      termType: 'BlankNode',\n      value: (component.value === id ? '_:a' : '_:z')\n    };\n  }\n\n  // helper for getting a related predicate\n  getRelatedPredicate(quad) {\n    return quad.predicate.value;\n  }\n\n  // helper for creating hash to related blank nodes map\n  async createHashToRelated(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    const hashToRelated = new Map();\n\n    // 2) Get a reference, quads, to the list of quads in the blank node to\n    // quads map for the key identifier.\n    const quads = this.blankNodeInfo.get(id).quads;\n\n    // 3) For each quad in quads:\n    let i = 0;\n    for(const quad of quads) {\n      // 3.1) If the quad's subject is a blank node that does not match\n      // identifier, set hash to the result of the Hash Related Blank Node\n      // algorithm, passing the blank node identifier for subject as related,\n      // quad, path identifier issuer as issuer, and p as position.\n      let position;\n      let related;\n      if(quad.subject.termType === 'BlankNode' && quad.subject.value !== id) {\n        related = quad.subject.value;\n        position = 'p';\n      } else if(\n        quad.object.termType === 'BlankNode' && quad.object.value !== id) {\n        // 3.2) Otherwise, if quad's object is a blank node that does not match\n        // identifier, to the result of the Hash Related Blank Node algorithm,\n        // passing the blank node identifier for object as related, quad, path\n        // identifier issuer as issuer, and r as position.\n        related = quad.object.value;\n        position = 'r';\n      } else {\n        // 3.3) Otherwise, continue to the next quad.\n        continue;\n      }\n      // Note: batch hashing related blank nodes 100 at a time\n      if(++i % 100 === 0) {\n        await this._yield();\n      }\n      // 3.4) Add a mapping of hash to the blank node identifier for the\n      // component that matched (subject or object) to hash to related blank\n      // nodes map, adding an entry as necessary.\n      const hash = await this.hashRelatedBlankNode(\n        related, quad, issuer, position);\n      const entries = hashToRelated.get(hash);\n      if(entries) {\n        entries.push(related);\n      } else {\n        hashToRelated.set(hash, [related]);\n      }\n    }\n\n    return hashToRelated;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/URGNA2012.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/URGNA2012Sync.js":
/*!********************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/URGNA2012Sync.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst URDNA2015Sync = __webpack_require__(/*! ./URDNA2015Sync */ \"./node_modules/rdf-canonize/lib/URDNA2015Sync.js\");\n\nmodule.exports = class URDNA2012Sync extends URDNA2015Sync {\n  constructor() {\n    super();\n    this.name = 'URGNA2012';\n    this.hashAlgorithm = 'sha1';\n  }\n\n  // helper for modifying component during Hash First Degree Quads\n  modifyFirstDegreeComponent(id, component, key) {\n    if(component.termType !== 'BlankNode') {\n      return component;\n    }\n    if(key === 'graph') {\n      return {\n        termType: 'BlankNode',\n        value: '_:g'\n      };\n    }\n    return {\n      termType: 'BlankNode',\n      value: (component.value === id ? '_:a' : '_:z')\n    };\n  }\n\n  // helper for getting a related predicate\n  getRelatedPredicate(quad) {\n    return quad.predicate.value;\n  }\n\n  // helper for creating hash to related blank nodes map\n  createHashToRelated(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    const hashToRelated = new Map();\n\n    // 2) Get a reference, quads, to the list of quads in the blank node to\n    // quads map for the key identifier.\n    const quads = this.blankNodeInfo.get(id).quads;\n\n    // 3) For each quad in quads:\n    for(const quad of quads) {\n      // 3.1) If the quad's subject is a blank node that does not match\n      // identifier, set hash to the result of the Hash Related Blank Node\n      // algorithm, passing the blank node identifier for subject as related,\n      // quad, path identifier issuer as issuer, and p as position.\n      let position;\n      let related;\n      if(quad.subject.termType === 'BlankNode' && quad.subject.value !== id) {\n        related = quad.subject.value;\n        position = 'p';\n      } else if(\n        quad.object.termType === 'BlankNode' && quad.object.value !== id) {\n        // 3.2) Otherwise, if quad's object is a blank node that does not match\n        // identifier, to the result of the Hash Related Blank Node algorithm,\n        // passing the blank node identifier for object as related, quad, path\n        // identifier issuer as issuer, and r as position.\n        related = quad.object.value;\n        position = 'r';\n      } else {\n        // 3.3) Otherwise, continue to the next quad.\n        continue;\n      }\n      // 3.4) Add a mapping of hash to the blank node identifier for the\n      // component that matched (subject or object) to hash to related blank\n      // nodes map, adding an entry as necessary.\n      const hash = this.hashRelatedBlankNode(related, quad, issuer, position);\n      const entries = hashToRelated.get(hash);\n      if(entries) {\n        entries.push(related);\n      } else {\n        hashToRelated.set(hash, [related]);\n      }\n    }\n\n    return hashToRelated;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/URGNA2012Sync.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * An implementation of the RDF Dataset Normalization specification.\n * This library works in the browser and node.js.\n *\n * BSD 3-Clause License\n * Copyright (c) 2016-2021 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\nconst URDNA2015 = __webpack_require__(/*! ./URDNA2015 */ \"./node_modules/rdf-canonize/lib/URDNA2015.js\");\nconst URGNA2012 = __webpack_require__(/*! ./URGNA2012 */ \"./node_modules/rdf-canonize/lib/URGNA2012.js\");\nconst URDNA2015Sync = __webpack_require__(/*! ./URDNA2015Sync */ \"./node_modules/rdf-canonize/lib/URDNA2015Sync.js\");\nconst URGNA2012Sync = __webpack_require__(/*! ./URGNA2012Sync */ \"./node_modules/rdf-canonize/lib/URGNA2012Sync.js\");\n\n// optional native support\nlet rdfCanonizeNative;\ntry {\n  rdfCanonizeNative = __webpack_require__(/*! rdf-canonize-native */ \"?2b19\");\n} catch(e) {}\n\nconst api = {};\nmodule.exports = api;\n\n// expose helpers\napi.NQuads = __webpack_require__(/*! ./NQuads */ \"./node_modules/rdf-canonize/lib/NQuads.js\");\napi.IdentifierIssuer = __webpack_require__(/*! ./IdentifierIssuer */ \"./node_modules/rdf-canonize/lib/IdentifierIssuer.js\");\n\n/**\n * Get or set native API.\n *\n * @param api the native API.\n *\n * @return the currently set native API.\n */\napi._rdfCanonizeNative = function(api) {\n  if(api) {\n    rdfCanonizeNative = api;\n  }\n  return rdfCanonizeNative;\n};\n\n/**\n * Asynchronously canonizes an RDF dataset.\n *\n * @param dataset the dataset to canonize.\n * @param options the options to use:\n *          algorithm the canonicalization algorithm to use, `URDNA2015` or\n *            `URGNA2012`.\n *          [useNative] use native implementation (default: false).\n *\n * @return a Promise that resolves to the canonicalized RDF Dataset.\n */\napi.canonize = async function(dataset, options) {\n  // back-compat with legacy dataset\n  if(!Array.isArray(dataset)) {\n    dataset = api.NQuads.legacyDatasetToQuads(dataset);\n  }\n\n  if(options.useNative) {\n    if(!rdfCanonizeNative) {\n      throw new Error('rdf-canonize-native not available');\n    }\n    // TODO: convert native algorithm to Promise-based async\n    return new Promise((resolve, reject) =>\n      rdfCanonizeNative.canonize(dataset, options, (err, canonical) =>\n        err ? reject(err) : resolve(canonical)));\n  }\n\n  if(options.algorithm === 'URDNA2015') {\n    return new URDNA2015(options).main(dataset);\n  }\n  if(options.algorithm === 'URGNA2012') {\n    return new URGNA2012(options).main(dataset);\n  }\n  if(!('algorithm' in options)) {\n    throw new Error('No RDF Dataset Canonicalization algorithm specified.');\n  }\n  throw new Error(\n    'Invalid RDF Dataset Canonicalization algorithm: ' + options.algorithm);\n};\n\n/**\n * This method is no longer available in the public API, it is for testing\n * only. It synchronously canonizes an RDF dataset and does not work in the\n * browser.\n *\n * @param dataset the dataset to canonize.\n * @param options the options to use:\n *          algorithm the canonicalization algorithm to use, `URDNA2015` or\n *            `URGNA2012`.\n *          [useNative] use native implementation (default: false).\n *\n * @return the RDF dataset in canonical form.\n */\napi._canonizeSync = function(dataset, options) {\n  // back-compat with legacy dataset\n  if(!Array.isArray(dataset)) {\n    dataset = api.NQuads.legacyDatasetToQuads(dataset);\n  }\n\n  if(options.useNative) {\n    if(rdfCanonizeNative) {\n      return rdfCanonizeNative.canonizeSync(dataset, options);\n    }\n    throw new Error('rdf-canonize-native not available');\n  }\n  if(options.algorithm === 'URDNA2015') {\n    return new URDNA2015Sync(options).main(dataset);\n  }\n  if(options.algorithm === 'URGNA2012') {\n    return new URGNA2012Sync(options).main(dataset);\n  }\n  if(!('algorithm' in options)) {\n    throw new Error('No RDF Dataset Canonicalization algorithm specified.');\n  }\n  throw new Error(\n    'Invalid RDF Dataset Canonicalization algorithm: ' + options.algorithm);\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/index.js?");

/***/ }),

/***/ "./node_modules/security-context/dist/module.js":
/*!******************************************************!*\
  !*** ./node_modules/security-context/dist/module.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"constants\": () => (/* binding */ main_2),\n/* harmony export */   \"contexts\": () => (/* binding */ main_1)\n/* harmony export */ });\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar main = createCommonjsModule(function (module, exports) {\n!function(e,i){for(var t in i)e[t]=i[t];}(exports,function(e){var i={};function t(a){if(i[a])return i[a].exports;var r=i[a]={i:a,l:!1,exports:{}};return e[a].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return t.m=e,t.c=i,t.d=function(e,i,a){t.o(e,i)||Object.defineProperty(e,i,{enumerable:!0,get:a});},t.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0});},t.t=function(e,i){if(1&i&&(e=t(e)),8&i)return e;if(4&i&&\"object\"==typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(t.r(a),Object.defineProperty(a,\"default\",{enumerable:!0,value:e}),2&i&&\"string\"!=typeof e)for(var r in e)t.d(a,r,function(i){return e[i]}.bind(null,r));return a},t.n=function(e){var i=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(i,\"a\",i),i},t.o=function(e,i){return Object.prototype.hasOwnProperty.call(e,i)},t.p=\"\",t(t.s=0)}([function(e,i,t){const a=i.contexts=new Map,r=i.constants=t(1);a.set(r.SECURITY_CONTEXT_V1_URL,t(2)),a.set(r.SECURITY_CONTEXT_V2_URL,t(3));},function(e,i,t){i.SECURITY_CONTEXT_V1_URL=\"https://w3id.org/security/v1\",i.SECURITY_CONTEXT_V2_URL=\"https://w3id.org/security/v2\";},function(e,i){e.exports={\"@context\":{id:\"@id\",type:\"@type\",dc:\"http://purl.org/dc/terms/\",sec:\"https://w3id.org/security#\",xsd:\"http://www.w3.org/2001/XMLSchema#\",EcdsaKoblitzSignature2016:\"sec:EcdsaKoblitzSignature2016\",Ed25519Signature2018:\"sec:Ed25519Signature2018\",EncryptedMessage:\"sec:EncryptedMessage\",GraphSignature2012:\"sec:GraphSignature2012\",LinkedDataSignature2015:\"sec:LinkedDataSignature2015\",LinkedDataSignature2016:\"sec:LinkedDataSignature2016\",CryptographicKey:\"sec:Key\",authenticationTag:\"sec:authenticationTag\",canonicalizationAlgorithm:\"sec:canonicalizationAlgorithm\",cipherAlgorithm:\"sec:cipherAlgorithm\",cipherData:\"sec:cipherData\",cipherKey:\"sec:cipherKey\",created:{\"@id\":\"dc:created\",\"@type\":\"xsd:dateTime\"},creator:{\"@id\":\"dc:creator\",\"@type\":\"@id\"},digestAlgorithm:\"sec:digestAlgorithm\",digestValue:\"sec:digestValue\",domain:\"sec:domain\",encryptionKey:\"sec:encryptionKey\",expiration:{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},expires:{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},initializationVector:\"sec:initializationVector\",iterationCount:\"sec:iterationCount\",nonce:\"sec:nonce\",normalizationAlgorithm:\"sec:normalizationAlgorithm\",owner:{\"@id\":\"sec:owner\",\"@type\":\"@id\"},password:\"sec:password\",privateKey:{\"@id\":\"sec:privateKey\",\"@type\":\"@id\"},privateKeyPem:\"sec:privateKeyPem\",publicKey:{\"@id\":\"sec:publicKey\",\"@type\":\"@id\"},publicKeyBase58:\"sec:publicKeyBase58\",publicKeyPem:\"sec:publicKeyPem\",publicKeyWif:\"sec:publicKeyWif\",publicKeyService:{\"@id\":\"sec:publicKeyService\",\"@type\":\"@id\"},revoked:{\"@id\":\"sec:revoked\",\"@type\":\"xsd:dateTime\"},salt:\"sec:salt\",signature:\"sec:signature\",signatureAlgorithm:\"sec:signingAlgorithm\",signatureValue:\"sec:signatureValue\"}};},function(e,i){e.exports={\"@context\":[{\"@version\":1.1},\"https://w3id.org/security/v1\",{AesKeyWrappingKey2019:\"sec:AesKeyWrappingKey2019\",DeleteKeyOperation:\"sec:DeleteKeyOperation\",DeriveSecretOperation:\"sec:DeriveSecretOperation\",EcdsaSecp256k1Signature2019:\"sec:EcdsaSecp256k1Signature2019\",EcdsaSecp256r1Signature2019:\"sec:EcdsaSecp256r1Signature2019\",EcdsaSecp256k1VerificationKey2019:\"sec:EcdsaSecp256k1VerificationKey2019\",EcdsaSecp256r1VerificationKey2019:\"sec:EcdsaSecp256r1VerificationKey2019\",Ed25519Signature2018:\"sec:Ed25519Signature2018\",Ed25519VerificationKey2018:\"sec:Ed25519VerificationKey2018\",EquihashProof2018:\"sec:EquihashProof2018\",ExportKeyOperation:\"sec:ExportKeyOperation\",GenerateKeyOperation:\"sec:GenerateKeyOperation\",KmsOperation:\"sec:KmsOperation\",RevokeKeyOperation:\"sec:RevokeKeyOperation\",RsaSignature2018:\"sec:RsaSignature2018\",RsaVerificationKey2018:\"sec:RsaVerificationKey2018\",Sha256HmacKey2019:\"sec:Sha256HmacKey2019\",SignOperation:\"sec:SignOperation\",UnwrapKeyOperation:\"sec:UnwrapKeyOperation\",VerifyOperation:\"sec:VerifyOperation\",WrapKeyOperation:\"sec:WrapKeyOperation\",X25519KeyAgreementKey2019:\"sec:X25519KeyAgreementKey2019\",allowedAction:\"sec:allowedAction\",assertionMethod:{\"@id\":\"sec:assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},authentication:{\"@id\":\"sec:authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},capability:{\"@id\":\"sec:capability\",\"@type\":\"@id\"},capabilityAction:\"sec:capabilityAction\",capabilityChain:{\"@id\":\"sec:capabilityChain\",\"@type\":\"@id\",\"@container\":\"@list\"},capabilityDelegation:{\"@id\":\"sec:capabilityDelegationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},capabilityInvocation:{\"@id\":\"sec:capabilityInvocationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},caveat:{\"@id\":\"sec:caveat\",\"@type\":\"@id\",\"@container\":\"@set\"},challenge:\"sec:challenge\",ciphertext:\"sec:ciphertext\",controller:{\"@id\":\"sec:controller\",\"@type\":\"@id\"},delegator:{\"@id\":\"sec:delegator\",\"@type\":\"@id\"},equihashParameterK:{\"@id\":\"sec:equihashParameterK\",\"@type\":\"xsd:integer\"},equihashParameterN:{\"@id\":\"sec:equihashParameterN\",\"@type\":\"xsd:integer\"},invocationTarget:{\"@id\":\"sec:invocationTarget\",\"@type\":\"@id\"},invoker:{\"@id\":\"sec:invoker\",\"@type\":\"@id\"},jws:\"sec:jws\",keyAgreement:{\"@id\":\"sec:keyAgreementMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},kmsModule:{\"@id\":\"sec:kmsModule\"},parentCapability:{\"@id\":\"sec:parentCapability\",\"@type\":\"@id\"},plaintext:\"sec:plaintext\",proof:{\"@id\":\"sec:proof\",\"@type\":\"@id\",\"@container\":\"@graph\"},proofPurpose:{\"@id\":\"sec:proofPurpose\",\"@type\":\"@vocab\"},proofValue:\"sec:proofValue\",referenceId:\"sec:referenceId\",unwrappedKey:\"sec:unwrappedKey\",verificationMethod:{\"@id\":\"sec:verificationMethod\",\"@type\":\"@id\"},verifyData:\"sec:verifyData\",wrappedKey:\"sec:wrappedKey\"}]};}]));\n});\n\nvar main$1 = unwrapExports(main);\nvar main_1 = main.contexts;\nvar main_2 = main.constants;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (main$1);\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/security-context/dist/module.js?");

/***/ }),

/***/ "./node_modules/serialize-error/index.js":
/*!***********************************************!*\
  !*** ./node_modules/serialize-error/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nclass NonError extends Error {\n\tconstructor(message) {\n\t\tsuper(NonError._prepareSuperMessage(message));\n\t\tObject.defineProperty(this, 'name', {\n\t\t\tvalue: 'NonError',\n\t\t\tconfigurable: true,\n\t\t\twritable: true\n\t\t});\n\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, NonError);\n\t\t}\n\t}\n\n\tstatic _prepareSuperMessage(message) {\n\t\ttry {\n\t\t\treturn JSON.stringify(message);\n\t\t} catch {\n\t\t\treturn String(message);\n\t\t}\n\t}\n}\n\nconst commonProperties = [\n\t{property: 'name', enumerable: false},\n\t{property: 'message', enumerable: false},\n\t{property: 'stack', enumerable: false},\n\t{property: 'code', enumerable: true}\n];\n\nconst isCalled = Symbol('.toJSON called');\n\nconst toJSON = from => {\n\tfrom[isCalled] = true;\n\tconst json = from.toJSON();\n\tdelete from[isCalled];\n\treturn json;\n};\n\nconst destroyCircular = ({\n\tfrom,\n\tseen,\n\tto_,\n\tforceEnumerable,\n\tmaxDepth,\n\tdepth\n}) => {\n\tconst to = to_ || (Array.isArray(from) ? [] : {});\n\n\tseen.push(from);\n\n\tif (depth >= maxDepth) {\n\t\treturn to;\n\t}\n\n\tif (typeof from.toJSON === 'function' && from[isCalled] !== true) {\n\t\treturn toJSON(from);\n\t}\n\n\tfor (const [key, value] of Object.entries(from)) {\n\t\tif (typeof Buffer === 'function' && Buffer.isBuffer(value)) {\n\t\t\tto[key] = '[object Buffer]';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (typeof value === 'function') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!value || typeof value !== 'object') {\n\t\t\tto[key] = value;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!seen.includes(from[key])) {\n\t\t\tdepth++;\n\n\t\t\tto[key] = destroyCircular({\n\t\t\t\tfrom: from[key],\n\t\t\t\tseen: seen.slice(),\n\t\t\t\tforceEnumerable,\n\t\t\t\tmaxDepth,\n\t\t\t\tdepth\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\n\t\tto[key] = '[Circular]';\n\t}\n\n\tfor (const {property, enumerable} of commonProperties) {\n\t\tif (typeof from[property] === 'string') {\n\t\t\tObject.defineProperty(to, property, {\n\t\t\t\tvalue: from[property],\n\t\t\t\tenumerable: forceEnumerable ? true : enumerable,\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true\n\t\t\t});\n\t\t}\n\t}\n\n\treturn to;\n};\n\nconst serializeError = (value, options = {}) => {\n\tconst {maxDepth = Number.POSITIVE_INFINITY} = options;\n\n\tif (typeof value === 'object' && value !== null) {\n\t\treturn destroyCircular({\n\t\t\tfrom: value,\n\t\t\tseen: [],\n\t\t\tforceEnumerable: true,\n\t\t\tmaxDepth,\n\t\t\tdepth: 0\n\t\t});\n\t}\n\n\t// People sometimes throw things besides Error objects…\n\tif (typeof value === 'function') {\n\t\t// `JSON.stringify()` discards functions. We do too, unless a function is thrown directly.\n\t\treturn `[Function: ${(value.name || 'anonymous')}]`;\n\t}\n\n\treturn value;\n};\n\nconst deserializeError = (value, options = {}) => {\n\tconst {maxDepth = Number.POSITIVE_INFINITY} = options;\n\n\tif (value instanceof Error) {\n\t\treturn value;\n\t}\n\n\tif (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n\t\tconst newError = new Error(); // eslint-disable-line unicorn/error-message\n\t\tdestroyCircular({\n\t\t\tfrom: value,\n\t\t\tseen: [],\n\t\t\tto_: newError,\n\t\t\tmaxDepth,\n\t\t\tdepth: 0\n\t\t});\n\t\treturn newError;\n\t}\n\n\treturn new NonError(value);\n};\n\nmodule.exports = {\n\tserializeError,\n\tdeserializeError\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/serialize-error/index.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof __webpack_require__.g === \"undefined\" ? this : __webpack_require__.g : self));\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/yallist/iterator.js":
/*!******************************************!*\
  !*** ./node_modules/yallist/iterator.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/yallist/iterator.js?");

/***/ }),

/***/ "./node_modules/yallist/yallist.js":
/*!*****************************************!*\
  !*** ./node_modules/yallist/yallist.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  __webpack_require__(/*! ./iterator.js */ \"./node_modules/yallist/iterator.js\")(Yallist)\n} catch (er) {}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/yallist/yallist.js?");

/***/ }),

/***/ "?25ed":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://respec-vc/crypto_(ignored)?");

/***/ }),

/***/ "?2b19":
/*!*************************************!*\
  !*** rdf-canonize-native (ignored) ***!
  \*************************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://respec-vc/rdf-canonize-native_(ignored)?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/index.js":
/*!*************************************************!*\
  !*** ./node_modules/jose/dist/browser/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"compactDecrypt\": () => (/* reexport safe */ _jwe_compact_decrypt_js__WEBPACK_IMPORTED_MODULE_0__.compactDecrypt),\n/* harmony export */   \"flattenedDecrypt\": () => (/* reexport safe */ _jwe_flattened_decrypt_js__WEBPACK_IMPORTED_MODULE_1__.flattenedDecrypt),\n/* harmony export */   \"generalDecrypt\": () => (/* reexport safe */ _jwe_general_decrypt_js__WEBPACK_IMPORTED_MODULE_2__.generalDecrypt),\n/* harmony export */   \"GeneralEncrypt\": () => (/* reexport safe */ _jwe_general_encrypt_js__WEBPACK_IMPORTED_MODULE_3__.GeneralEncrypt),\n/* harmony export */   \"compactVerify\": () => (/* reexport safe */ _jws_compact_verify_js__WEBPACK_IMPORTED_MODULE_4__.compactVerify),\n/* harmony export */   \"flattenedVerify\": () => (/* reexport safe */ _jws_flattened_verify_js__WEBPACK_IMPORTED_MODULE_5__.flattenedVerify),\n/* harmony export */   \"generalVerify\": () => (/* reexport safe */ _jws_general_verify_js__WEBPACK_IMPORTED_MODULE_6__.generalVerify),\n/* harmony export */   \"jwtVerify\": () => (/* reexport safe */ _jwt_verify_js__WEBPACK_IMPORTED_MODULE_7__.jwtVerify),\n/* harmony export */   \"jwtDecrypt\": () => (/* reexport safe */ _jwt_decrypt_js__WEBPACK_IMPORTED_MODULE_8__.jwtDecrypt),\n/* harmony export */   \"CompactEncrypt\": () => (/* reexport safe */ _jwe_compact_encrypt_js__WEBPACK_IMPORTED_MODULE_9__.CompactEncrypt),\n/* harmony export */   \"FlattenedEncrypt\": () => (/* reexport safe */ _jwe_flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_10__.FlattenedEncrypt),\n/* harmony export */   \"CompactSign\": () => (/* reexport safe */ _jws_compact_sign_js__WEBPACK_IMPORTED_MODULE_11__.CompactSign),\n/* harmony export */   \"FlattenedSign\": () => (/* reexport safe */ _jws_flattened_sign_js__WEBPACK_IMPORTED_MODULE_12__.FlattenedSign),\n/* harmony export */   \"GeneralSign\": () => (/* reexport safe */ _jws_general_sign_js__WEBPACK_IMPORTED_MODULE_13__.GeneralSign),\n/* harmony export */   \"SignJWT\": () => (/* reexport safe */ _jwt_sign_js__WEBPACK_IMPORTED_MODULE_14__.SignJWT),\n/* harmony export */   \"EncryptJWT\": () => (/* reexport safe */ _jwt_encrypt_js__WEBPACK_IMPORTED_MODULE_15__.EncryptJWT),\n/* harmony export */   \"calculateJwkThumbprint\": () => (/* reexport safe */ _jwk_thumbprint_js__WEBPACK_IMPORTED_MODULE_16__.calculateJwkThumbprint),\n/* harmony export */   \"EmbeddedJWK\": () => (/* reexport safe */ _jwk_embedded_js__WEBPACK_IMPORTED_MODULE_17__.EmbeddedJWK),\n/* harmony export */   \"createRemoteJWKSet\": () => (/* reexport safe */ _jwks_remote_js__WEBPACK_IMPORTED_MODULE_18__.createRemoteJWKSet),\n/* harmony export */   \"UnsecuredJWT\": () => (/* reexport safe */ _jwt_unsecured_js__WEBPACK_IMPORTED_MODULE_19__.UnsecuredJWT),\n/* harmony export */   \"exportPKCS8\": () => (/* reexport safe */ _key_export_js__WEBPACK_IMPORTED_MODULE_20__.exportPKCS8),\n/* harmony export */   \"exportSPKI\": () => (/* reexport safe */ _key_export_js__WEBPACK_IMPORTED_MODULE_20__.exportSPKI),\n/* harmony export */   \"exportJWK\": () => (/* reexport safe */ _key_export_js__WEBPACK_IMPORTED_MODULE_20__.exportJWK),\n/* harmony export */   \"importSPKI\": () => (/* reexport safe */ _key_import_js__WEBPACK_IMPORTED_MODULE_21__.importSPKI),\n/* harmony export */   \"importPKCS8\": () => (/* reexport safe */ _key_import_js__WEBPACK_IMPORTED_MODULE_21__.importPKCS8),\n/* harmony export */   \"importX509\": () => (/* reexport safe */ _key_import_js__WEBPACK_IMPORTED_MODULE_21__.importX509),\n/* harmony export */   \"importJWK\": () => (/* reexport safe */ _key_import_js__WEBPACK_IMPORTED_MODULE_21__.importJWK),\n/* harmony export */   \"decodeProtectedHeader\": () => (/* reexport safe */ _util_decode_protected_header_js__WEBPACK_IMPORTED_MODULE_22__.decodeProtectedHeader),\n/* harmony export */   \"errors\": () => (/* reexport module object */ _util_errors_js__WEBPACK_IMPORTED_MODULE_23__),\n/* harmony export */   \"generateKeyPair\": () => (/* reexport safe */ _key_generate_key_pair_js__WEBPACK_IMPORTED_MODULE_24__.generateKeyPair),\n/* harmony export */   \"generateSecret\": () => (/* reexport safe */ _key_generate_secret_js__WEBPACK_IMPORTED_MODULE_25__.generateSecret),\n/* harmony export */   \"base64url\": () => (/* reexport module object */ _util_base64url_js__WEBPACK_IMPORTED_MODULE_26__)\n/* harmony export */ });\n/* harmony import */ var _jwe_compact_decrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jwe/compact/decrypt.js */ \"./node_modules/jose/dist/browser/jwe/compact/decrypt.js\");\n/* harmony import */ var _jwe_flattened_decrypt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jwe/flattened/decrypt.js */ \"./node_modules/jose/dist/browser/jwe/flattened/decrypt.js\");\n/* harmony import */ var _jwe_general_decrypt_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jwe/general/decrypt.js */ \"./node_modules/jose/dist/browser/jwe/general/decrypt.js\");\n/* harmony import */ var _jwe_general_encrypt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./jwe/general/encrypt.js */ \"./node_modules/jose/dist/browser/jwe/general/encrypt.js\");\n/* harmony import */ var _jws_compact_verify_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jws/compact/verify.js */ \"./node_modules/jose/dist/browser/jws/compact/verify.js\");\n/* harmony import */ var _jws_flattened_verify_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./jws/flattened/verify.js */ \"./node_modules/jose/dist/browser/jws/flattened/verify.js\");\n/* harmony import */ var _jws_general_verify_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./jws/general/verify.js */ \"./node_modules/jose/dist/browser/jws/general/verify.js\");\n/* harmony import */ var _jwt_verify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./jwt/verify.js */ \"./node_modules/jose/dist/browser/jwt/verify.js\");\n/* harmony import */ var _jwt_decrypt_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./jwt/decrypt.js */ \"./node_modules/jose/dist/browser/jwt/decrypt.js\");\n/* harmony import */ var _jwe_compact_encrypt_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./jwe/compact/encrypt.js */ \"./node_modules/jose/dist/browser/jwe/compact/encrypt.js\");\n/* harmony import */ var _jwe_flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./jwe/flattened/encrypt.js */ \"./node_modules/jose/dist/browser/jwe/flattened/encrypt.js\");\n/* harmony import */ var _jws_compact_sign_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./jws/compact/sign.js */ \"./node_modules/jose/dist/browser/jws/compact/sign.js\");\n/* harmony import */ var _jws_flattened_sign_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./jws/flattened/sign.js */ \"./node_modules/jose/dist/browser/jws/flattened/sign.js\");\n/* harmony import */ var _jws_general_sign_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./jws/general/sign.js */ \"./node_modules/jose/dist/browser/jws/general/sign.js\");\n/* harmony import */ var _jwt_sign_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./jwt/sign.js */ \"./node_modules/jose/dist/browser/jwt/sign.js\");\n/* harmony import */ var _jwt_encrypt_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./jwt/encrypt.js */ \"./node_modules/jose/dist/browser/jwt/encrypt.js\");\n/* harmony import */ var _jwk_thumbprint_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./jwk/thumbprint.js */ \"./node_modules/jose/dist/browser/jwk/thumbprint.js\");\n/* harmony import */ var _jwk_embedded_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./jwk/embedded.js */ \"./node_modules/jose/dist/browser/jwk/embedded.js\");\n/* harmony import */ var _jwks_remote_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./jwks/remote.js */ \"./node_modules/jose/dist/browser/jwks/remote.js\");\n/* harmony import */ var _jwt_unsecured_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./jwt/unsecured.js */ \"./node_modules/jose/dist/browser/jwt/unsecured.js\");\n/* harmony import */ var _key_export_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./key/export.js */ \"./node_modules/jose/dist/browser/key/export.js\");\n/* harmony import */ var _key_import_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./key/import.js */ \"./node_modules/jose/dist/browser/key/import.js\");\n/* harmony import */ var _util_decode_protected_header_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./util/decode_protected_header.js */ \"./node_modules/jose/dist/browser/util/decode_protected_header.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _key_generate_key_pair_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./key/generate_key_pair.js */ \"./node_modules/jose/dist/browser/key/generate_key_pair.js\");\n/* harmony import */ var _key_generate_secret_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./key/generate_secret.js */ \"./node_modules/jose/dist/browser/key/generate_secret.js\");\n/* harmony import */ var _util_base64url_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./util/base64url.js */ \"./node_modules/jose/dist/browser/util/base64url.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/index.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwe/compact/decrypt.js":
/*!***************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwe/compact/decrypt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"compactDecrypt\": () => (/* binding */ compactDecrypt)\n/* harmony export */ });\n/* harmony import */ var _flattened_decrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/decrypt.js */ \"./node_modules/jose/dist/browser/jwe/flattened/decrypt.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n\n\n\nasync function compactDecrypt(jwe, key, options) {\n    if (jwe instanceof Uint8Array) {\n        jwe = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_2__.decoder.decode(jwe);\n    }\n    if (typeof jwe !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('Compact JWE must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length, } = jwe.split('.');\n    if (length !== 5) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('Invalid Compact JWE');\n    }\n    const decrypted = await (0,_flattened_decrypt_js__WEBPACK_IMPORTED_MODULE_0__.flattenedDecrypt)({\n        ciphertext: (ciphertext || undefined),\n        iv: (iv || undefined),\n        protected: protectedHeader || undefined,\n        tag: (tag || undefined),\n        encrypted_key: encryptedKey || undefined,\n    }, key, options);\n    const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: decrypted.key };\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwe/compact/decrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwe/compact/encrypt.js":
/*!***************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwe/compact/encrypt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CompactEncrypt\": () => (/* binding */ CompactEncrypt)\n/* harmony export */ });\n/* harmony import */ var _flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/encrypt.js */ \"./node_modules/jose/dist/browser/jwe/flattened/encrypt.js\");\n\nclass CompactEncrypt {\n    constructor(plaintext) {\n        this._flattened = new _flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_0__.FlattenedEncrypt(plaintext);\n    }\n    setContentEncryptionKey(cek) {\n        this._flattened.setContentEncryptionKey(cek);\n        return this;\n    }\n    setInitializationVector(iv) {\n        this._flattened.setInitializationVector(iv);\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        this._flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    setKeyManagementParameters(parameters) {\n        this._flattened.setKeyManagementParameters(parameters);\n        return this;\n    }\n    async encrypt(key, options) {\n        const jwe = await this._flattened.encrypt(key, options);\n        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join('.');\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwe/compact/encrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwe/flattened/decrypt.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwe/flattened/decrypt.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"flattenedDecrypt\": () => (/* binding */ flattenedDecrypt)\n/* harmony export */ });\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _runtime_decrypt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../runtime/decrypt.js */ \"./node_modules/jose/dist/browser/runtime/decrypt.js\");\n/* harmony import */ var _runtime_zlib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../runtime/zlib.js */ \"./node_modules/jose/dist/browser/runtime/zlib.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/is_disjoint.js */ \"./node_modules/jose/dist/browser/lib/is_disjoint.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n/* harmony import */ var _lib_decrypt_key_management_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/decrypt_key_management.js */ \"./node_modules/jose/dist/browser/lib/decrypt_key_management.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_cek_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../lib/cek.js */ \"./node_modules/jose/dist/browser/lib/cek.js\");\n/* harmony import */ var _lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../lib/validate_crit.js */ \"./node_modules/jose/dist/browser/lib/validate_crit.js\");\n/* harmony import */ var _lib_validate_algorithms_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../lib/validate_algorithms.js */ \"./node_modules/jose/dist/browser/lib/validate_algorithms.js\");\n\n\n\n\n\n\n\n\n\n\n\nasync function flattenedDecrypt(jwe, key, options) {\n    var _a;\n    if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(jwe)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('Flattened JWE must be an object');\n    }\n    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('JOSE Header missing');\n    }\n    if (typeof jwe.iv !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('JWE Initialization Vector missing or incorrect type');\n    }\n    if (typeof jwe.ciphertext !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('JWE Ciphertext missing or incorrect type');\n    }\n    if (typeof jwe.tag !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('JWE Authentication Tag missing or incorrect type');\n    }\n    if (jwe.protected !== undefined && typeof jwe.protected !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('JWE Protected Header incorrect type');\n    }\n    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('JWE Encrypted Key incorrect type');\n    }\n    if (jwe.aad !== undefined && typeof jwe.aad !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('JWE AAD incorrect type');\n    }\n    if (jwe.header !== undefined && !(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(jwe.header)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('JWE Shared Unprotected Header incorrect type');\n    }\n    if (jwe.unprotected !== undefined && !(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(jwe.unprotected)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type');\n    }\n    let parsedProt;\n    if (jwe.protected) {\n        const protectedHeader = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jwe.protected);\n        try {\n            parsedProt = JSON.parse(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_7__.decoder.decode(protectedHeader));\n        }\n        catch (_b) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('JWE Protected Header is invalid');\n        }\n    }\n    if (!(0,_lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(parsedProt, jwe.header, jwe.unprotected)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jwe.header,\n        ...jwe.unprotected,\n    };\n    (0,_lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(_util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n    if (joseHeader.zip !== undefined) {\n        if (!parsedProt || !parsedProt.zip) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n        }\n        if (joseHeader.zip !== 'DEF') {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JOSENotSupported('Unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n        }\n    }\n    const { alg, enc } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('missing JWE Algorithm (alg) in JWE Header');\n    }\n    if (typeof enc !== 'string' || !enc) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header');\n    }\n    const keyManagementAlgorithms = options && (0,_lib_validate_algorithms_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])('keyManagementAlgorithms', options.keyManagementAlgorithms);\n    const contentEncryptionAlgorithms = options &&\n        (0,_lib_validate_algorithms_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms);\n    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n    }\n    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JOSEAlgNotAllowed('\"enc\" (Encryption Algorithm) Header Parameter not allowed');\n    }\n    let encryptedKey;\n    if (jwe.encrypted_key !== undefined) {\n        encryptedKey = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jwe.encrypted_key);\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jwe);\n        resolvedKey = true;\n    }\n    let cek;\n    try {\n        cek = await (0,_lib_decrypt_key_management_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(alg, key, encryptedKey, joseHeader);\n    }\n    catch (err) {\n        if (err instanceof TypeError) {\n            throw err;\n        }\n        cek = (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(enc);\n    }\n    const iv = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jwe.iv);\n    const tag = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jwe.tag);\n    const protectedHeader = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_7__.encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : '');\n    let additionalData;\n    if (jwe.aad !== undefined) {\n        additionalData = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_7__.concat)(protectedHeader, _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_7__.encoder.encode('.'), _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_7__.encoder.encode(jwe.aad));\n    }\n    else {\n        additionalData = protectedHeader;\n    }\n    let plaintext = await (0,_runtime_decrypt_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(enc, cek, (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jwe.ciphertext), iv, tag, additionalData);\n    if (joseHeader.zip === 'DEF') {\n        plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || _runtime_zlib_js__WEBPACK_IMPORTED_MODULE_2__.inflate)(plaintext);\n    }\n    const result = { plaintext };\n    if (jwe.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jwe.aad !== undefined) {\n        result.additionalAuthenticatedData = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jwe.aad);\n    }\n    if (jwe.unprotected !== undefined) {\n        result.sharedUnprotectedHeader = jwe.unprotected;\n    }\n    if (jwe.header !== undefined) {\n        result.unprotectedHeader = jwe.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwe/flattened/decrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwe/flattened/encrypt.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwe/flattened/encrypt.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"unprotected\": () => (/* binding */ unprotected),\n/* harmony export */   \"FlattenedEncrypt\": () => (/* binding */ FlattenedEncrypt)\n/* harmony export */ });\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _runtime_encrypt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../runtime/encrypt.js */ \"./node_modules/jose/dist/browser/runtime/encrypt.js\");\n/* harmony import */ var _runtime_zlib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../runtime/zlib.js */ \"./node_modules/jose/dist/browser/runtime/zlib.js\");\n/* harmony import */ var _lib_iv_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/iv.js */ \"./node_modules/jose/dist/browser/lib/iv.js\");\n/* harmony import */ var _lib_encrypt_key_management_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/encrypt_key_management.js */ \"./node_modules/jose/dist/browser/lib/encrypt_key_management.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/is_disjoint.js */ \"./node_modules/jose/dist/browser/lib/is_disjoint.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../lib/validate_crit.js */ \"./node_modules/jose/dist/browser/lib/validate_crit.js\");\n\n\n\n\n\n\n\n\n\nconst unprotected = Symbol();\nclass FlattenedEncrypt {\n    constructor(plaintext) {\n        if (!(plaintext instanceof Uint8Array)) {\n            throw new TypeError('plaintext must be an instance of Uint8Array');\n        }\n        this._plaintext = plaintext;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._sharedUnprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    async encrypt(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n        }\n        if (!(0,_lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n            ...this._sharedUnprotectedHeader,\n        };\n        (0,_lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(_util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        if (joseHeader.zip !== undefined) {\n            if (!this._protectedHeader || !this._protectedHeader.zip) {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n            }\n            if (joseHeader.zip !== 'DEF') {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JOSENotSupported('Unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n            }\n        }\n        const { alg, enc } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        if (typeof enc !== 'string' || !enc) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n        }\n        let encryptedKey;\n        if (alg === 'dir') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');\n            }\n        }\n        else if (alg === 'ECDH-ES') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');\n            }\n        }\n        let cek;\n        {\n            let parameters;\n            ({ cek, encryptedKey, parameters } = await (0,_lib_encrypt_key_management_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(alg, enc, key, this._cek, this._keyManagementParameters));\n            if (parameters) {\n                if (options && unprotected in options) {\n                    if (!this._unprotectedHeader) {\n                        this.setUnprotectedHeader(parameters);\n                    }\n                    else {\n                        this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };\n                    }\n                }\n                else {\n                    if (!this._protectedHeader) {\n                        this.setProtectedHeader(parameters);\n                    }\n                    else {\n                        this._protectedHeader = { ...this._protectedHeader, ...parameters };\n                    }\n                }\n            }\n        }\n        this._iv || (this._iv = (0,_lib_iv_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(enc));\n        let additionalData;\n        let protectedHeader;\n        let aadMember;\n        if (this._protectedHeader) {\n            protectedHeader = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_7__.encoder.encode((0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_7__.encoder.encode('');\n        }\n        if (this._aad) {\n            aadMember = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(this._aad);\n            additionalData = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_7__.concat)(protectedHeader, _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_7__.encoder.encode('.'), _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_7__.encoder.encode(aadMember));\n        }\n        else {\n            additionalData = protectedHeader;\n        }\n        let ciphertext;\n        let tag;\n        if (joseHeader.zip === 'DEF') {\n            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || _runtime_zlib_js__WEBPACK_IMPORTED_MODULE_2__.deflate)(this._plaintext);\n            ({ ciphertext, tag } = await (0,_runtime_encrypt_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(enc, deflated, cek, this._iv, additionalData));\n        }\n        else {\n            ;\n            ({ ciphertext, tag } = await (0,_runtime_encrypt_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(enc, this._plaintext, cek, this._iv, additionalData));\n        }\n        const jwe = {\n            ciphertext: (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(ciphertext),\n            iv: (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(this._iv),\n            tag: (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(tag),\n        };\n        if (encryptedKey) {\n            jwe.encrypted_key = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(encryptedKey);\n        }\n        if (aadMember) {\n            jwe.aad = aadMember;\n        }\n        if (this._protectedHeader) {\n            jwe.protected = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_7__.decoder.decode(protectedHeader);\n        }\n        if (this._sharedUnprotectedHeader) {\n            jwe.unprotected = this._sharedUnprotectedHeader;\n        }\n        if (this._unprotectedHeader) {\n            jwe.header = this._unprotectedHeader;\n        }\n        return jwe;\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwe/flattened/encrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwe/general/decrypt.js":
/*!***************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwe/general/decrypt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generalDecrypt\": () => (/* binding */ generalDecrypt)\n/* harmony export */ });\n/* harmony import */ var _flattened_decrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/decrypt.js */ \"./node_modules/jose/dist/browser/jwe/flattened/decrypt.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n\n\n\nasync function generalDecrypt(jwe, key, options) {\n    if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(jwe)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('General JWE must be an object');\n    }\n    if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(_lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('JWE Recipients missing or incorrect type');\n    }\n    if (!jwe.recipients.length) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('JWE Recipients has no members');\n    }\n    for (const recipient of jwe.recipients) {\n        try {\n            return await (0,_flattened_decrypt_js__WEBPACK_IMPORTED_MODULE_0__.flattenedDecrypt)({\n                aad: jwe.aad,\n                ciphertext: jwe.ciphertext,\n                encrypted_key: recipient.encrypted_key,\n                header: recipient.header,\n                iv: jwe.iv,\n                protected: jwe.protected,\n                tag: jwe.tag,\n                unprotected: jwe.unprotected,\n            }, key, options);\n        }\n        catch (_a) {\n        }\n    }\n    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEDecryptionFailed();\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwe/general/decrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwe/general/encrypt.js":
/*!***************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwe/general/encrypt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GeneralEncrypt\": () => (/* binding */ GeneralEncrypt)\n/* harmony export */ });\n/* harmony import */ var _flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/encrypt.js */ \"./node_modules/jose/dist/browser/jwe/flattened/encrypt.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_cek_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/cek.js */ \"./node_modules/jose/dist/browser/lib/cek.js\");\n/* harmony import */ var _lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/is_disjoint.js */ \"./node_modules/jose/dist/browser/lib/is_disjoint.js\");\n/* harmony import */ var _lib_encrypt_key_management_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/encrypt_key_management.js */ \"./node_modules/jose/dist/browser/lib/encrypt_key_management.js\");\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/validate_crit.js */ \"./node_modules/jose/dist/browser/lib/validate_crit.js\");\n\n\n\n\n\n\n\nconst recipientRef = new WeakMap();\nclass IndividualRecipient {\n    setUnprotectedHeader(unprotectedHeader) {\n        const ref = recipientRef.get(this);\n        if (ref.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        ref.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n}\nclass GeneralEncrypt {\n    constructor(plaintext) {\n        this._recipients = [];\n        this._plaintext = plaintext;\n    }\n    addRecipient(key, options) {\n        const recipient = new IndividualRecipient();\n        recipientRef.set(recipient, { key, options: { crit: options === null || options === void 0 ? void 0 : options.crit } });\n        this._recipients.push(recipient);\n        return recipient;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    async encrypt(options) {\n        var _a, _b;\n        if (!this._recipients.length) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('at least one recipient must be added');\n        }\n        options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };\n        if (this._recipients.length === 1) {\n            const { unprotectedHeader, options: recipientOpts, key, } = recipientRef.get(this._recipients[0]);\n            const flattened = await new _flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_0__.FlattenedEncrypt(this._plaintext)\n                .setAdditionalAuthenticatedData(this._aad)\n                .setProtectedHeader(this._protectedHeader)\n                .setSharedUnprotectedHeader(this._unprotectedHeader)\n                .setUnprotectedHeader(unprotectedHeader)\n                .encrypt(key, { ...recipientOpts, ...options });\n            let jwe = {\n                ciphertext: flattened.ciphertext,\n                iv: flattened.iv,\n                recipients: [{}],\n                tag: flattened.tag,\n            };\n            if (flattened.aad)\n                jwe.aad = flattened.aad;\n            if (flattened.protected)\n                jwe.protected = flattened.protected;\n            if (flattened.unprotected)\n                jwe.unprotected = flattened.unprotected;\n            if (flattened.encrypted_key)\n                jwe.recipients[0].encrypted_key = flattened.encrypted_key;\n            if (flattened.header)\n                jwe.recipients[0].header = flattened.header;\n            return jwe;\n        }\n        let enc;\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            const { unprotectedHeader, options: recipientOpts } = recipientRef.get(recipient);\n            if (!(0,_lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this._protectedHeader, this._unprotectedHeader, unprotectedHeader)) {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n            }\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...unprotectedHeader,\n            };\n            const { alg } = joseHeader;\n            if (typeof alg !== 'string' || !alg) {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n            }\n            if (alg === 'dir' || alg === 'ECDH-ES') {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('\"dir\" and \"ECDH-ES\" alg may only be used with a single recipient');\n            }\n            if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n            }\n            if (!enc) {\n                enc = joseHeader.enc;\n            }\n            else if (enc !== joseHeader.enc) {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter must be the same for all recipients');\n            }\n            (0,_lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(_util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid, new Map(), recipientOpts === null || recipientOpts === void 0 ? void 0 : recipientOpts.crit, this._protectedHeader, joseHeader);\n            if (joseHeader.zip !== undefined) {\n                if (!this._protectedHeader || !this._protectedHeader.zip) {\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n                }\n            }\n        }\n        const cek = (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(enc);\n        let jwe = {\n            ciphertext: '',\n            iv: '',\n            recipients: [],\n            tag: '',\n        };\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            const target = {};\n            jwe.recipients.push(target);\n            const { unprotectedHeader, options: recipientOpts, key } = recipientRef.get(recipient);\n            if (i === 0) {\n                const flattened = await new _flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_0__.FlattenedEncrypt(this._plaintext)\n                    .setAdditionalAuthenticatedData(this._aad)\n                    .setContentEncryptionKey(cek)\n                    .setProtectedHeader(this._protectedHeader)\n                    .setSharedUnprotectedHeader(this._unprotectedHeader)\n                    .setUnprotectedHeader(unprotectedHeader)\n                    .encrypt(key, { ...recipientOpts, ...options, [_flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_0__.unprotected]: true });\n                jwe.ciphertext = flattened.ciphertext;\n                jwe.iv = flattened.iv;\n                jwe.tag = flattened.tag;\n                if (flattened.aad)\n                    jwe.aad = flattened.aad;\n                if (flattened.protected)\n                    jwe.protected = flattened.protected;\n                if (flattened.unprotected)\n                    jwe.unprotected = flattened.unprotected;\n                target.encrypted_key = flattened.encrypted_key;\n                if (flattened.header)\n                    target.header = flattened.header;\n                continue;\n            }\n            const { encryptedKey, parameters } = await (0,_lib_encrypt_key_management_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((unprotectedHeader === null || unprotectedHeader === void 0 ? void 0 : unprotectedHeader.alg) || ((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.alg) || ((_b = this._unprotectedHeader) === null || _b === void 0 ? void 0 : _b.alg), enc, key, cek);\n            target.encrypted_key = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_5__.encode)(encryptedKey);\n            if (unprotectedHeader || parameters)\n                target.header = { ...unprotectedHeader, ...parameters };\n        }\n        return jwe;\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwe/general/encrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwk/embedded.js":
/*!********************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwk/embedded.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EmbeddedJWK\": () => (/* binding */ EmbeddedJWK)\n/* harmony export */ });\n/* harmony import */ var _key_import_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../key/import.js */ \"./node_modules/jose/dist/browser/key/import.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\n\n\nasync function EmbeddedJWK(protectedHeader, token) {\n    const joseHeader = {\n        ...protectedHeader,\n        ...token.header,\n    };\n    if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(joseHeader.jwk)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('\"jwk\" (JSON Web Key) Header Parameter must be a JSON object');\n    }\n    const key = await (0,_key_import_js__WEBPACK_IMPORTED_MODULE_0__.importJWK)({ ...joseHeader.jwk, ext: true }, joseHeader.alg, true);\n    if (key instanceof Uint8Array || key.type !== 'public') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('\"jwk\" (JSON Web Key) Header Parameter must be a public key');\n    }\n    return key;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwk/embedded.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwk/thumbprint.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwk/thumbprint.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"calculateJwkThumbprint\": () => (/* binding */ calculateJwkThumbprint)\n/* harmony export */ });\n/* harmony import */ var _runtime_digest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/digest.js */ \"./node_modules/jose/dist/browser/runtime/digest.js\");\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n\n\n\n\n\nconst check = (value, description) => {\n    if (typeof value !== 'string' || !value) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWKInvalid(`${description} missing or invalid`);\n    }\n};\nasync function calculateJwkThumbprint(jwk, digestAlgorithm = 'sha256') {\n    if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    let components;\n    switch (jwk.kty) {\n        case 'EC':\n            check(jwk.crv, '\"crv\" (Curve) Parameter');\n            check(jwk.x, '\"x\" (X Coordinate) Parameter');\n            check(jwk.y, '\"y\" (Y Coordinate) Parameter');\n            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };\n            break;\n        case 'OKP':\n            check(jwk.crv, '\"crv\" (Subtype of Key Pair) Parameter');\n            check(jwk.x, '\"x\" (Public Key) Parameter');\n            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };\n            break;\n        case 'RSA':\n            check(jwk.e, '\"e\" (Exponent) Parameter');\n            check(jwk.n, '\"n\" (Modulus) Parameter');\n            components = { e: jwk.e, kty: jwk.kty, n: jwk.n };\n            break;\n        case 'oct':\n            check(jwk.k, '\"k\" (Key Value) Parameter');\n            components = { k: jwk.k, kty: jwk.kty };\n            break;\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported('\"kty\" (Key Type) Parameter missing or unsupported');\n    }\n    const data = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__.encoder.encode(JSON.stringify(components));\n    return (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_1__.encode)(await (0,_runtime_digest_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(digestAlgorithm, data));\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwk/thumbprint.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwks/remote.js":
/*!*******************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwks/remote.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createRemoteJWKSet\": () => (/* binding */ createRemoteJWKSet)\n/* harmony export */ });\n/* harmony import */ var _runtime_fetch_jwks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/fetch_jwks.js */ \"./node_modules/jose/dist/browser/runtime/fetch_jwks.js\");\n/* harmony import */ var _key_import_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../key/import.js */ \"./node_modules/jose/dist/browser/key/import.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n\n\n\n\nfunction getKtyFromAlg(alg) {\n    switch (typeof alg === 'string' && alg.substr(0, 2)) {\n        case 'RS':\n        case 'PS':\n            return 'RSA';\n        case 'ES':\n            return 'EC';\n        case 'Ed':\n            return 'OKP';\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported('Unsupported \"alg\" value for a JSON Web Key Set');\n    }\n}\nfunction isJWKLike(key) {\n    return (0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(key);\n}\nclass RemoteJWKSet {\n    constructor(url, options) {\n        this._cached = new WeakMap();\n        if (!(url instanceof URL)) {\n            throw new TypeError('url must be an instance of URL');\n        }\n        this._url = new URL(url.href);\n        this._options = { agent: options === null || options === void 0 ? void 0 : options.agent };\n        this._timeoutDuration =\n            typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5000;\n        this._cooldownDuration =\n            typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 30000;\n    }\n    coolingDown() {\n        if (!this._cooldownStarted) {\n            return false;\n        }\n        return Date.now() < this._cooldownStarted + this._cooldownDuration;\n    }\n    async getKey(protectedHeader) {\n        if (!this._jwks) {\n            await this.reload();\n        }\n        const candidates = this._jwks.keys.filter((jwk) => {\n            let candidate = jwk.kty === getKtyFromAlg(protectedHeader.alg);\n            if (candidate && typeof protectedHeader.kid === 'string') {\n                candidate = protectedHeader.kid === jwk.kid;\n            }\n            if (candidate && typeof jwk.alg === 'string') {\n                candidate = protectedHeader.alg === jwk.alg;\n            }\n            if (candidate && typeof jwk.use === 'string') {\n                candidate = jwk.use === 'sig';\n            }\n            if (candidate && Array.isArray(jwk.key_ops)) {\n                candidate = jwk.key_ops.includes('verify');\n            }\n            if (candidate && protectedHeader.alg === 'EdDSA') {\n                candidate = jwk.crv === 'Ed25519' || jwk.crv === 'Ed448';\n            }\n            if (candidate) {\n                switch (protectedHeader.alg) {\n                    case 'ES256':\n                        candidate = jwk.crv === 'P-256';\n                        break;\n                    case 'ES256K':\n                        candidate = jwk.crv === 'secp256k1';\n                        break;\n                    case 'ES384':\n                        candidate = jwk.crv === 'P-384';\n                        break;\n                    case 'ES512':\n                        candidate = jwk.crv === 'P-521';\n                        break;\n                    default:\n                }\n            }\n            return candidate;\n        });\n        const { 0: jwk, length } = candidates;\n        if (length === 0) {\n            if (this.coolingDown() === false) {\n                await this.reload();\n                return this.getKey(protectedHeader);\n            }\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWKSNoMatchingKey();\n        }\n        else if (length !== 1) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWKSMultipleMatchingKeys();\n        }\n        const cached = this._cached.get(jwk) || this._cached.set(jwk, {}).get(jwk);\n        if (cached[protectedHeader.alg] === undefined) {\n            const keyObject = await (0,_key_import_js__WEBPACK_IMPORTED_MODULE_1__.importJWK)({ ...jwk, ext: true }, protectedHeader.alg);\n            if (keyObject instanceof Uint8Array || keyObject.type !== 'public') {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWKSInvalid('JSON Web Key Set members must be public keys');\n            }\n            cached[protectedHeader.alg] = keyObject;\n        }\n        return cached[protectedHeader.alg];\n    }\n    async reload() {\n        if (!this._pendingFetch) {\n            this._pendingFetch = (0,_runtime_fetch_jwks_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this._url, this._timeoutDuration, this._options)\n                .then((json) => {\n                if (typeof json !== 'object' ||\n                    !json ||\n                    !Array.isArray(json.keys) ||\n                    !json.keys.every(isJWKLike)) {\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWKSInvalid('JSON Web Key Set malformed');\n                }\n                this._jwks = { keys: json.keys };\n                this._cooldownStarted = Date.now();\n                this._pendingFetch = undefined;\n            })\n                .catch((err) => {\n                this._pendingFetch = undefined;\n                throw err;\n            });\n        }\n        await this._pendingFetch;\n    }\n}\nfunction createRemoteJWKSet(url, options) {\n    return RemoteJWKSet.prototype.getKey.bind(new RemoteJWKSet(url, options));\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwks/remote.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jws/compact/sign.js":
/*!************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jws/compact/sign.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CompactSign\": () => (/* binding */ CompactSign)\n/* harmony export */ });\n/* harmony import */ var _flattened_sign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/sign.js */ \"./node_modules/jose/dist/browser/jws/flattened/sign.js\");\n\nclass CompactSign {\n    constructor(payload) {\n        this._flattened = new _flattened_sign_js__WEBPACK_IMPORTED_MODULE_0__.FlattenedSign(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this._flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this._flattened.sign(key, options);\n        if (jws.payload === undefined) {\n            throw new TypeError('use the flattened module for creating JWS with b64: false');\n        }\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jws/compact/sign.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jws/compact/verify.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jws/compact/verify.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"compactVerify\": () => (/* binding */ compactVerify)\n/* harmony export */ });\n/* harmony import */ var _flattened_verify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/verify.js */ \"./node_modules/jose/dist/browser/jws/flattened/verify.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n\n\n\nasync function compactVerify(jws, key, options) {\n    if (jws instanceof Uint8Array) {\n        jws = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_2__.decoder.decode(jws);\n    }\n    if (typeof jws !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWSInvalid('Compact JWS must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');\n    if (length !== 3) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWSInvalid('Invalid Compact JWS');\n    }\n    const verified = await (0,_flattened_verify_js__WEBPACK_IMPORTED_MODULE_0__.flattenedVerify)({\n        payload: (payload || undefined),\n        protected: protectedHeader || undefined,\n        signature: (signature || undefined),\n    }, key, options);\n    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jws/compact/verify.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jws/flattened/sign.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jws/flattened/sign.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FlattenedSign\": () => (/* binding */ FlattenedSign)\n/* harmony export */ });\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _runtime_sign_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../runtime/sign.js */ \"./node_modules/jose/dist/browser/runtime/sign.js\");\n/* harmony import */ var _lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/is_disjoint.js */ \"./node_modules/jose/dist/browser/lib/is_disjoint.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_check_key_type_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../lib/check_key_type.js */ \"./node_modules/jose/dist/browser/lib/check_key_type.js\");\n/* harmony import */ var _lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/validate_crit.js */ \"./node_modules/jose/dist/browser/lib/validate_crit.js\");\n\n\n\n\n\n\n\nclass FlattenedSign {\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this._payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!(0,_lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this._protectedHeader, this._unprotectedHeader)) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n        };\n        const extensions = (0,_lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(_util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this._protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        (0,_lib_check_key_type_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(alg, key, 'sign');\n        let payload = this._payload;\n        if (b64) {\n            payload = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__.encoder.encode((0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(payload));\n        }\n        let protectedHeader;\n        if (this._protectedHeader) {\n            protectedHeader = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__.encoder.encode((0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__.encoder.encode('');\n        }\n        const data = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__.concat)(protectedHeader, _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__.encoder.encode('.'), payload);\n        const signature = await (0,_runtime_sign_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(alg, key, data);\n        const jws = {\n            signature: (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(signature),\n            payload: '',\n        };\n        if (b64) {\n            jws.payload = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__.decoder.decode(payload);\n        }\n        if (this._unprotectedHeader) {\n            jws.header = this._unprotectedHeader;\n        }\n        if (this._protectedHeader) {\n            jws.protected = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__.decoder.decode(protectedHeader);\n        }\n        return jws;\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jws/flattened/sign.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jws/flattened/verify.js":
/*!****************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jws/flattened/verify.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"flattenedVerify\": () => (/* binding */ flattenedVerify)\n/* harmony export */ });\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _runtime_verify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../runtime/verify.js */ \"./node_modules/jose/dist/browser/runtime/verify.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/is_disjoint.js */ \"./node_modules/jose/dist/browser/lib/is_disjoint.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n/* harmony import */ var _lib_check_key_type_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/check_key_type.js */ \"./node_modules/jose/dist/browser/lib/check_key_type.js\");\n/* harmony import */ var _lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../lib/validate_crit.js */ \"./node_modules/jose/dist/browser/lib/validate_crit.js\");\n/* harmony import */ var _lib_validate_algorithms_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../lib/validate_algorithms.js */ \"./node_modules/jose/dist/browser/lib/validate_algorithms.js\");\n\n\n\n\n\n\n\n\n\nasync function flattenedVerify(jws, key, options) {\n    var _a;\n    if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(jws)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(jws.header)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        const protectedHeader = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jws.protected);\n        try {\n            parsedProt = JSON.parse(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__.decoder.decode(protectedHeader));\n        }\n        catch (_b) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Protected Header is invalid');\n        }\n    }\n    if (!(0,_lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(parsedProt, jws.header)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = (0,_lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(_util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && (0,_lib_validate_algorithms_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n    }\n    (0,_lib_check_key_type_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(alg, key, 'verify');\n    const data = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__.concat)(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__.encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__.encoder.encode('.'), typeof jws.payload === 'string' ? _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__.encoder.encode(jws.payload) : jws.payload);\n    const signature = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jws.signature);\n    const verified = await (0,_runtime_verify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(alg, key, signature, data);\n    if (!verified) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        payload = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jws.payload);\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__.encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jws/flattened/verify.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jws/general/sign.js":
/*!************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jws/general/sign.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GeneralSign\": () => (/* binding */ GeneralSign)\n/* harmony export */ });\n/* harmony import */ var _flattened_sign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/sign.js */ \"./node_modules/jose/dist/browser/jws/flattened/sign.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\n\nconst signatureRef = new WeakMap();\nclass IndividualSignature {\n    setProtectedHeader(protectedHeader) {\n        const ref = signatureRef.get(this);\n        if (ref.protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        ref.protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        const ref = signatureRef.get(this);\n        if (ref.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        ref.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n}\nclass GeneralSign {\n    constructor(payload) {\n        this._signatures = [];\n        this._payload = payload;\n    }\n    addSignature(key, options) {\n        const signature = new IndividualSignature();\n        signatureRef.set(signature, { key, options });\n        this._signatures.push(signature);\n        return signature;\n    }\n    async sign() {\n        if (!this._signatures.length) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWSInvalid('at least one signature must be added');\n        }\n        const jws = {\n            signatures: [],\n            payload: '',\n        };\n        let payloads = new Set();\n        await Promise.all(this._signatures.map(async (sig) => {\n            const { protectedHeader, unprotectedHeader, options, key } = signatureRef.get(sig);\n            const flattened = new _flattened_sign_js__WEBPACK_IMPORTED_MODULE_0__.FlattenedSign(this._payload);\n            if (protectedHeader) {\n                flattened.setProtectedHeader(protectedHeader);\n            }\n            if (unprotectedHeader) {\n                flattened.setUnprotectedHeader(unprotectedHeader);\n            }\n            const { payload, ...rest } = await flattened.sign(key, options);\n            payloads.add(payload);\n            jws.payload = payload;\n            jws.signatures.push(rest);\n        }));\n        if (payloads.size !== 1) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWSInvalid('inconsistent use of JWS Unencoded Payload Option (RFC7797)');\n        }\n        return jws;\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jws/general/sign.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jws/general/verify.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jws/general/verify.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generalVerify\": () => (/* binding */ generalVerify)\n/* harmony export */ });\n/* harmony import */ var _flattened_verify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/verify.js */ \"./node_modules/jose/dist/browser/jws/flattened/verify.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n\n\n\nasync function generalVerify(jws, key, options) {\n    if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(jws)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWSInvalid('General JWS must be an object');\n    }\n    if (!Array.isArray(jws.signatures) || !jws.signatures.every(_lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWSInvalid('JWS Signatures missing or incorrect type');\n    }\n    for (const signature of jws.signatures) {\n        try {\n            return await (0,_flattened_verify_js__WEBPACK_IMPORTED_MODULE_0__.flattenedVerify)({\n                header: signature.header,\n                payload: jws.payload,\n                protected: signature.protected,\n                signature: signature.signature,\n            }, key, options);\n        }\n        catch (_a) {\n        }\n    }\n    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWSSignatureVerificationFailed();\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jws/general/verify.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwt/decrypt.js":
/*!*******************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwt/decrypt.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"jwtDecrypt\": () => (/* binding */ jwtDecrypt)\n/* harmony export */ });\n/* harmony import */ var _jwe_compact_decrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../jwe/compact/decrypt.js */ \"./node_modules/jose/dist/browser/jwe/compact/decrypt.js\");\n/* harmony import */ var _lib_jwt_claims_set_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/jwt_claims_set.js */ \"./node_modules/jose/dist/browser/lib/jwt_claims_set.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\n\n\nasync function jwtDecrypt(jwt, key, options) {\n    const decrypted = await (0,_jwe_compact_decrypt_js__WEBPACK_IMPORTED_MODULE_0__.compactDecrypt)(jwt, key, options);\n    const payload = (0,_lib_jwt_claims_set_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(decrypted.protectedHeader, decrypted.plaintext, options);\n    const { protectedHeader } = decrypted;\n    if (protectedHeader.iss !== undefined && protectedHeader.iss !== payload.iss) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWTClaimValidationFailed('replicated \"iss\" claim header parameter mismatch', 'iss', 'mismatch');\n    }\n    if (protectedHeader.sub !== undefined && protectedHeader.sub !== payload.sub) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWTClaimValidationFailed('replicated \"sub\" claim header parameter mismatch', 'sub', 'mismatch');\n    }\n    if (protectedHeader.aud !== undefined &&\n        JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWTClaimValidationFailed('replicated \"aud\" claim header parameter mismatch', 'aud', 'mismatch');\n    }\n    const result = { payload, protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: decrypted.key };\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwt/decrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwt/encrypt.js":
/*!*******************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwt/encrypt.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EncryptJWT\": () => (/* binding */ EncryptJWT)\n/* harmony export */ });\n/* harmony import */ var _jwe_compact_encrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../jwe/compact/encrypt.js */ \"./node_modules/jose/dist/browser/jwe/compact/encrypt.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _produce_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./produce.js */ \"./node_modules/jose/dist/browser/jwt/produce.js\");\n\n\n\nclass EncryptJWT extends _produce_js__WEBPACK_IMPORTED_MODULE_2__.ProduceJWT {\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    replicateIssuerAsHeader() {\n        this._replicateIssuerAsHeader = true;\n        return this;\n    }\n    replicateSubjectAsHeader() {\n        this._replicateSubjectAsHeader = true;\n        return this;\n    }\n    replicateAudienceAsHeader() {\n        this._replicateAudienceAsHeader = true;\n        return this;\n    }\n    async encrypt(key, options) {\n        const enc = new _jwe_compact_encrypt_js__WEBPACK_IMPORTED_MODULE_0__.CompactEncrypt(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__.encoder.encode(JSON.stringify(this._payload)));\n        if (this._replicateIssuerAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };\n        }\n        if (this._replicateSubjectAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };\n        }\n        if (this._replicateAudienceAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };\n        }\n        enc.setProtectedHeader(this._protectedHeader);\n        if (this._iv) {\n            enc.setInitializationVector(this._iv);\n        }\n        if (this._cek) {\n            enc.setContentEncryptionKey(this._cek);\n        }\n        if (this._keyManagementParameters) {\n            enc.setKeyManagementParameters(this._keyManagementParameters);\n        }\n        return enc.encrypt(key, options);\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwt/encrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwt/produce.js":
/*!*******************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwt/produce.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ProduceJWT\": () => (/* binding */ ProduceJWT)\n/* harmony export */ });\n/* harmony import */ var _lib_epoch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/epoch.js */ \"./node_modules/jose/dist/browser/lib/epoch.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n/* harmony import */ var _lib_secs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/secs.js */ \"./node_modules/jose/dist/browser/lib/secs.js\");\n\n\n\nclass ProduceJWT {\n    constructor(payload) {\n        if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(payload)) {\n            throw new TypeError('JWT Claims Set MUST be an object');\n        }\n        this._payload = payload;\n    }\n    setIssuer(issuer) {\n        this._payload = { ...this._payload, iss: issuer };\n        return this;\n    }\n    setSubject(subject) {\n        this._payload = { ...this._payload, sub: subject };\n        return this;\n    }\n    setAudience(audience) {\n        this._payload = { ...this._payload, aud: audience };\n        return this;\n    }\n    setJti(jwtId) {\n        this._payload = { ...this._payload, jti: jwtId };\n        return this;\n    }\n    setNotBefore(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, nbf: input };\n        }\n        else {\n            this._payload = { ...this._payload, nbf: (0,_lib_epoch_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(new Date()) + (0,_lib_secs_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(input) };\n        }\n        return this;\n    }\n    setExpirationTime(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, exp: input };\n        }\n        else {\n            this._payload = { ...this._payload, exp: (0,_lib_epoch_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(new Date()) + (0,_lib_secs_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(input) };\n        }\n        return this;\n    }\n    setIssuedAt(input) {\n        if (typeof input === 'undefined') {\n            this._payload = { ...this._payload, iat: (0,_lib_epoch_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(new Date()) };\n        }\n        else {\n            this._payload = { ...this._payload, iat: input };\n        }\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwt/produce.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwt/sign.js":
/*!****************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwt/sign.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SignJWT\": () => (/* binding */ SignJWT)\n/* harmony export */ });\n/* harmony import */ var _jws_compact_sign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../jws/compact/sign.js */ \"./node_modules/jose/dist/browser/jws/compact/sign.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _produce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./produce.js */ \"./node_modules/jose/dist/browser/jwt/produce.js\");\n\n\n\n\nclass SignJWT extends _produce_js__WEBPACK_IMPORTED_MODULE_3__.ProduceJWT {\n    setProtectedHeader(protectedHeader) {\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        var _a;\n        const sig = new _jws_compact_sign_js__WEBPACK_IMPORTED_MODULE_0__.CompactSign(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_2__.encoder.encode(JSON.stringify(this._payload)));\n        sig.setProtectedHeader(this._protectedHeader);\n        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) &&\n            this._protectedHeader.crit.includes('b64') &&\n            this._protectedHeader.b64 === false) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwt/sign.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwt/unsecured.js":
/*!*********************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwt/unsecured.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UnsecuredJWT\": () => (/* binding */ UnsecuredJWT)\n/* harmony export */ });\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_jwt_claims_set_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/jwt_claims_set.js */ \"./node_modules/jose/dist/browser/lib/jwt_claims_set.js\");\n/* harmony import */ var _produce_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./produce.js */ \"./node_modules/jose/dist/browser/jwt/produce.js\");\n\n\n\n\n\nclass UnsecuredJWT extends _produce_js__WEBPACK_IMPORTED_MODULE_4__.ProduceJWT {\n    encode() {\n        const header = _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode(JSON.stringify({ alg: 'none' }));\n        const payload = _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode(JSON.stringify(this._payload));\n        return `${header}.${payload}.`;\n    }\n    static decode(jwt, options) {\n        if (typeof jwt !== 'string') {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWTInvalid('Unsecured JWT must be a string');\n        }\n        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split('.');\n        if (length !== 3 || signature !== '') {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWTInvalid('Invalid Unsecured JWT');\n        }\n        let header;\n        try {\n            header = JSON.parse(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__.decoder.decode(_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode(encodedHeader)));\n            if (header.alg !== 'none')\n                throw new Error();\n        }\n        catch (_a) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWTInvalid('Invalid Unsecured JWT');\n        }\n        const payload = (0,_lib_jwt_claims_set_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(header, _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode(encodedPayload), options);\n        return { payload, header };\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwt/unsecured.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwt/verify.js":
/*!******************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwt/verify.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"jwtVerify\": () => (/* binding */ jwtVerify)\n/* harmony export */ });\n/* harmony import */ var _jws_compact_verify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../jws/compact/verify.js */ \"./node_modules/jose/dist/browser/jws/compact/verify.js\");\n/* harmony import */ var _lib_jwt_claims_set_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/jwt_claims_set.js */ \"./node_modules/jose/dist/browser/lib/jwt_claims_set.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\n\n\nasync function jwtVerify(jwt, key, options) {\n    var _a;\n    const verified = await (0,_jws_compact_verify_js__WEBPACK_IMPORTED_MODULE_0__.compactVerify)(jwt, key, options);\n    if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes('b64')) && verified.protectedHeader.b64 === false) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWTInvalid('JWTs MUST NOT use unencoded payload');\n    }\n    const payload = (0,_lib_jwt_claims_set_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(verified.protectedHeader, verified.payload, options);\n    const result = { payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwt/verify.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/key/export.js":
/*!******************************************************!*\
  !*** ./node_modules/jose/dist/browser/key/export.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"exportSPKI\": () => (/* binding */ exportSPKI),\n/* harmony export */   \"exportPKCS8\": () => (/* binding */ exportPKCS8),\n/* harmony export */   \"exportJWK\": () => (/* binding */ exportJWK)\n/* harmony export */ });\n/* harmony import */ var _runtime_asn1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/asn1.js */ \"./node_modules/jose/dist/browser/runtime/asn1.js\");\n/* harmony import */ var _runtime_key_to_jwk_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/key_to_jwk.js */ \"./node_modules/jose/dist/browser/runtime/key_to_jwk.js\");\n\n\n\nasync function exportSPKI(key) {\n    return (0,_runtime_asn1_js__WEBPACK_IMPORTED_MODULE_0__.toSPKI)(key);\n}\nasync function exportPKCS8(key) {\n    return (0,_runtime_asn1_js__WEBPACK_IMPORTED_MODULE_0__.toPKCS8)(key);\n}\nasync function exportJWK(key) {\n    return (0,_runtime_key_to_jwk_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(key);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/key/export.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/key/generate_key_pair.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jose/dist/browser/key/generate_key_pair.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generateKeyPair\": () => (/* binding */ generateKeyPair)\n/* harmony export */ });\n/* harmony import */ var _runtime_generate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/generate.js */ \"./node_modules/jose/dist/browser/runtime/generate.js\");\n\nasync function generateKeyPair(alg, options) {\n    return (0,_runtime_generate_js__WEBPACK_IMPORTED_MODULE_0__.generateKeyPair)(alg, options);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/key/generate_key_pair.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/key/generate_secret.js":
/*!***************************************************************!*\
  !*** ./node_modules/jose/dist/browser/key/generate_secret.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generateSecret\": () => (/* binding */ generateSecret)\n/* harmony export */ });\n/* harmony import */ var _runtime_generate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/generate.js */ \"./node_modules/jose/dist/browser/runtime/generate.js\");\n\nasync function generateSecret(alg, options) {\n    return (0,_runtime_generate_js__WEBPACK_IMPORTED_MODULE_0__.generateSecret)(alg, options);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/key/generate_secret.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/key/import.js":
/*!******************************************************!*\
  !*** ./node_modules/jose/dist/browser/key/import.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"importSPKI\": () => (/* binding */ importSPKI),\n/* harmony export */   \"importX509\": () => (/* binding */ importX509),\n/* harmony export */   \"importPKCS8\": () => (/* binding */ importPKCS8),\n/* harmony export */   \"importJWK\": () => (/* binding */ importJWK)\n/* harmony export */ });\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _runtime_asn1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/asn1.js */ \"./node_modules/jose/dist/browser/runtime/asn1.js\");\n/* harmony import */ var _runtime_jwk_to_key_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../runtime/jwk_to_key.js */ \"./node_modules/jose/dist/browser/runtime/jwk_to_key.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_format_pem_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/format_pem.js */ \"./node_modules/jose/dist/browser/lib/format_pem.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n\n\n\n\n\n\n\nfunction getElement(seq) {\n    let result = [];\n    let next = 0;\n    while (next < seq.length) {\n        let nextPart = parseElement(seq.subarray(next));\n        result.push(nextPart);\n        next += nextPart.byteLength;\n    }\n    return result;\n}\nfunction parseElement(bytes) {\n    let position = 0;\n    let tag = bytes[0] & 0x1f;\n    position++;\n    if (tag === 0x1f) {\n        tag = 0;\n        while (bytes[position] >= 0x80) {\n            tag = tag * 128 + bytes[position] - 0x80;\n            position++;\n        }\n        tag = tag * 128 + bytes[position] - 0x80;\n        position++;\n    }\n    let length = 0;\n    if (bytes[position] < 0x80) {\n        length = bytes[position];\n        position++;\n    }\n    else {\n        let numberOfDigits = bytes[position] & 0x7f;\n        position++;\n        length = 0;\n        for (let i = 0; i < numberOfDigits; i++) {\n            length = length * 256 + bytes[position];\n            position++;\n        }\n    }\n    if (length === 0x80) {\n        length = 0;\n        while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {\n            length++;\n        }\n        const byteLength = position + length + 2;\n        return {\n            byteLength,\n            contents: bytes.subarray(position, position + length),\n            raw: bytes.subarray(0, byteLength),\n        };\n    }\n    const byteLength = position + length;\n    return {\n        byteLength,\n        contents: bytes.subarray(position, byteLength),\n        raw: bytes.subarray(0, byteLength),\n    };\n}\nfunction spkiFromX509(buf) {\n    const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);\n    return (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encodeBase64)(tbsCertificate[tbsCertificate[0].raw[0] === 0xa0 ? 6 : 5].raw);\n}\nfunction getSPKI(x509) {\n    const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '');\n    const raw = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decodeBase64)(pem);\n    return (0,_lib_format_pem_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(spkiFromX509(raw), 'PUBLIC KEY');\n}\nasync function importSPKI(spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n        throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n    return (0,_runtime_asn1_js__WEBPACK_IMPORTED_MODULE_1__.fromSPKI)(spki, alg, options);\n}\nasync function importX509(x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n        throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n    const spki = getSPKI(x509);\n    return (0,_runtime_asn1_js__WEBPACK_IMPORTED_MODULE_1__.fromSPKI)(spki, alg, options);\n}\nasync function importPKCS8(pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n        throw new TypeError('\"pkcs8\" must be PCKS8 formatted string');\n    }\n    return (0,_runtime_asn1_js__WEBPACK_IMPORTED_MODULE_1__.fromPKCS8)(pkcs8, alg, options);\n}\nasync function importJWK(jwk, alg, octAsKeyObject) {\n    if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    alg || (alg = jwk.alg);\n    if (typeof alg !== 'string' || !alg) {\n        throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : (octAsKeyObject = jwk.ext !== true);\n            if (octAsKeyObject) {\n                return (0,_runtime_jwk_to_key_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({ ...jwk, alg, ext: false });\n            }\n            return (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jwk.k);\n        case 'RSA':\n            if (jwk.oth !== undefined) {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n        case 'EC':\n        case 'OKP':\n            return (0,_runtime_jwk_to_key_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({ ...jwk, alg });\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/key/import.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/aesgcmkw.js":
/*!********************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/aesgcmkw.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"wrap\": () => (/* binding */ wrap),\n/* harmony export */   \"unwrap\": () => (/* binding */ unwrap)\n/* harmony export */ });\n/* harmony import */ var _runtime_encrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/encrypt.js */ \"./node_modules/jose/dist/browser/runtime/encrypt.js\");\n/* harmony import */ var _runtime_decrypt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/decrypt.js */ \"./node_modules/jose/dist/browser/runtime/decrypt.js\");\n/* harmony import */ var _iv_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./iv.js */ \"./node_modules/jose/dist/browser/lib/iv.js\");\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n\n\n\n\nasync function wrap(alg, key, cek, iv) {\n    const jweAlgorithm = alg.substr(0, 7);\n    iv || (iv = (0,_iv_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(jweAlgorithm));\n    const { ciphertext: encryptedKey, tag } = await (0,_runtime_encrypt_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(jweAlgorithm, cek, key, iv, new Uint8Array(0));\n    return { encryptedKey, iv: (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_3__.encode)(iv), tag: (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_3__.encode)(tag) };\n}\nasync function unwrap(alg, key, encryptedKey, iv, tag) {\n    const jweAlgorithm = alg.substr(0, 7);\n    return (0,_runtime_decrypt_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/aesgcmkw.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/buffer_utils.js":
/*!************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/buffer_utils.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"encoder\": () => (/* binding */ encoder),\n/* harmony export */   \"decoder\": () => (/* binding */ decoder),\n/* harmony export */   \"concat\": () => (/* binding */ concat),\n/* harmony export */   \"p2s\": () => (/* binding */ p2s),\n/* harmony export */   \"uint64be\": () => (/* binding */ uint64be),\n/* harmony export */   \"uint32be\": () => (/* binding */ uint32be),\n/* harmony export */   \"lengthAndInput\": () => (/* binding */ lengthAndInput),\n/* harmony export */   \"concatKdf\": () => (/* binding */ concatKdf)\n/* harmony export */ });\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nfunction concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    buffers.forEach((buffer) => {\n        buf.set(buffer, i);\n        i += buffer.length;\n    });\n    return buf;\n}\nfunction p2s(alg, p2sInput) {\n    return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nfunction uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nfunction uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nfunction lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nasync function concatKdf(digest, secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    let res;\n    for (let iter = 1; iter <= iterations; iter++) {\n        const buf = new Uint8Array(4 + secret.length + value.length);\n        buf.set(uint32be(iter));\n        buf.set(secret, 4);\n        buf.set(value, 4 + secret.length);\n        if (!res) {\n            res = await digest('sha256', buf);\n        }\n        else {\n            res = concat(res, await digest('sha256', buf));\n        }\n    }\n    res = res.slice(0, bits >> 3);\n    return res;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/buffer_utils.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/cek.js":
/*!***************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/cek.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bitLength\": () => (/* binding */ bitLength),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _runtime_random_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/random.js */ \"./node_modules/jose/dist/browser/runtime/random.js\");\n\n\nfunction bitLength(alg) {\n    switch (alg) {\n        case 'A128GCM':\n            return 128;\n        case 'A192GCM':\n            return 192;\n        case 'A256GCM':\n        case 'A128CBC-HS256':\n            return 256;\n        case 'A192CBC-HS384':\n            return 384;\n        case 'A256CBC-HS512':\n            return 512;\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((alg) => (0,_runtime_random_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(new Uint8Array(bitLength(alg) >> 3)));\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/cek.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/check_iv_length.js":
/*!***************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/check_iv_length.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _iv_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iv.js */ \"./node_modules/jose/dist/browser/lib/iv.js\");\n\n\nconst checkIvLength = (enc, iv) => {\n    if (iv.length << 3 !== (0,_iv_js__WEBPACK_IMPORTED_MODULE_1__.bitLength)(enc)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWEInvalid('Invalid Initialization Vector length');\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (checkIvLength);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/check_iv_length.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/check_key_type.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/check_key_type.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _invalid_key_input_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\nconst symmetricTypeCheck = (key) => {\n    if (key instanceof Uint8Array)\n        return;\n    if (!(0,_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(key)) {\n        throw new TypeError((0,_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(key, ..._runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types, 'Uint8Array'));\n    }\n    if (key.type !== 'secret') {\n        throw new TypeError(`${_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types.join(' or ')} instances for symmetric algorithms must be of type \"secret\"`);\n    }\n};\nconst asymmetricTypeCheck = (key, usage) => {\n    if (!(0,_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(key)) {\n        throw new TypeError((0,_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(key, ..._runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError(`${_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types.join(' or ')} instances for asymmetric algorithms must not be of type \"secret\"`);\n    }\n    if (usage === 'sign' && key.type === 'public') {\n        throw new TypeError(`${_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types.join(' or ')} instances for asymmetric algorithm signing must be of type \"private\"`);\n    }\n    if (usage === 'decrypt' && key.type === 'public') {\n        throw new TypeError(`${_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types.join(' or ')} instances for asymmetric algorithm decryption must be of type \"private\"`);\n    }\n    if (key.algorithm && usage === 'verify' && key.type === 'private') {\n        throw new TypeError(`${_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types.join(' or ')} instances for asymmetric algorithm verifying must be of type \"public\"`);\n    }\n    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {\n        throw new TypeError(`${_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types.join(' or ')} instances for asymmetric algorithm encryption must be of type \"public\"`);\n    }\n};\nconst checkKeyType = (alg, key, usage) => {\n    const symmetric = alg.startsWith('HS') ||\n        alg === 'dir' ||\n        alg.startsWith('PBES2') ||\n        /^A\\d{3}(?:GCM)?KW$/.test(alg);\n    if (symmetric) {\n        symmetricTypeCheck(key);\n    }\n    else {\n        asymmetricTypeCheck(key, usage);\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (checkKeyType);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/check_key_type.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/check_p2s.js":
/*!*********************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/check_p2s.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ checkP2s)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\nfunction checkP2s(p2s) {\n    if (!(p2s instanceof Uint8Array) || p2s.length < 8) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWEInvalid('PBES2 Salt Input must be 8 or more octets');\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/check_p2s.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/crypto_key.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/crypto_key.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"checkSigCryptoKey\": () => (/* binding */ checkSigCryptoKey),\n/* harmony export */   \"checkEncCryptoKey\": () => (/* binding */ checkEncCryptoKey)\n/* harmony export */ });\n/* harmony import */ var _runtime_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/env.js */ \"./node_modules/jose/dist/browser/runtime/env.js\");\n\nfunction unusable(name, prop = 'algorithm.name') {\n    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);\n}\nfunction isAlgorithm(algorithm, name) {\n    return algorithm.name === name;\n}\nfunction getHashLength(hash) {\n    return parseInt(hash.name.substr(4), 10);\n}\nfunction getNamedCurve(alg) {\n    switch (alg) {\n        case 'ES256':\n            return 'P-256';\n        case 'ES384':\n            return 'P-384';\n        case 'ES512':\n            return 'P-521';\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction checkUsage(key, usages) {\n    if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {\n        let msg = 'CryptoKey does not support this operation, its usages must include ';\n        if (usages.length > 2) {\n            const last = usages.pop();\n            msg += `one of ${usages.join(', ')}, or ${last}.`;\n        }\n        else if (usages.length === 2) {\n            msg += `one of ${usages[0]} or ${usages[1]}.`;\n        }\n        else {\n            msg += `${usages[0]}.`;\n        }\n        throw new TypeError(msg);\n    }\n}\nfunction checkSigCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512': {\n            if (!isAlgorithm(key.algorithm, 'HMAC'))\n                throw unusable('HMAC');\n            const expected = parseInt(alg.substr(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'RS256':\n        case 'RS384':\n        case 'RS512': {\n            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))\n                throw unusable('RSASSA-PKCS1-v1_5');\n            const expected = parseInt(alg.substr(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'PS256':\n        case 'PS384':\n        case 'PS512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))\n                throw unusable('RSA-PSS');\n            const expected = parseInt(alg.substr(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case (0,_runtime_env_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJs)() && 'EdDSA': {\n            if (key.algorithm.name !== 'NODE-ED25519' && key.algorithm.name !== 'NODE-ED448')\n                throw unusable('NODE-ED25519 or NODE-ED448');\n            break;\n        }\n        case (0,_runtime_env_js__WEBPACK_IMPORTED_MODULE_0__.isCloudflareWorkers)() && 'EdDSA': {\n            if (!isAlgorithm(key.algorithm, 'NODE-ED25519'))\n                throw unusable('NODE-ED25519');\n            break;\n        }\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            if (!isAlgorithm(key.algorithm, 'ECDSA'))\n                throw unusable('ECDSA');\n            const expected = getNamedCurve(alg);\n            const actual = key.algorithm.namedCurve;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.namedCurve');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\nfunction checkEncCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM': {\n            if (!isAlgorithm(key.algorithm, 'AES-GCM'))\n                throw unusable('AES-GCM');\n            const expected = parseInt(alg.substr(1, 3), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (!isAlgorithm(key.algorithm, 'AES-KW'))\n                throw unusable('AES-KW');\n            const expected = parseInt(alg.substr(1, 3), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'ECDH-ES':\n            if (!isAlgorithm(key.algorithm, 'ECDH'))\n                throw unusable('ECDH');\n            break;\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW':\n            if (!isAlgorithm(key.algorithm, 'PBKDF2'))\n                throw unusable('PBKDF2');\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))\n                throw unusable('RSA-OAEP');\n            const expected = parseInt(alg.substr(9), 10) || 1;\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/crypto_key.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/decrypt_key_management.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/decrypt_key_management.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _runtime_aeskw_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/aeskw.js */ \"./node_modules/jose/dist/browser/runtime/aeskw.js\");\n/* harmony import */ var _runtime_ecdhes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/ecdhes.js */ \"./node_modules/jose/dist/browser/runtime/ecdhes.js\");\n/* harmony import */ var _runtime_pbes2kw_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../runtime/pbes2kw.js */ \"./node_modules/jose/dist/browser/runtime/pbes2kw.js\");\n/* harmony import */ var _runtime_rsaes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../runtime/rsaes.js */ \"./node_modules/jose/dist/browser/runtime/rsaes.js\");\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_cek_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/cek.js */ \"./node_modules/jose/dist/browser/lib/cek.js\");\n/* harmony import */ var _key_import_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../key/import.js */ \"./node_modules/jose/dist/browser/key/import.js\");\n/* harmony import */ var _check_key_type_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./check_key_type.js */ \"./node_modules/jose/dist/browser/lib/check_key_type.js\");\n/* harmony import */ var _is_object_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n/* harmony import */ var _aesgcmkw_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./aesgcmkw.js */ \"./node_modules/jose/dist/browser/lib/aesgcmkw.js\");\n\n\n\n\n\n\n\n\n\n\n\nasync function decryptKeyManagement(alg, key, encryptedKey, joseHeader) {\n    (0,_check_key_type_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(alg, key, 'decrypt');\n    switch (alg) {\n        case 'dir': {\n            if (encryptedKey !== undefined)\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('Encountered unexpected JWE Encrypted Key');\n            return key;\n        }\n        case 'ECDH-ES':\n            if (encryptedKey !== undefined)\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('Encountered unexpected JWE Encrypted Key');\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            if (!(0,_is_object_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(joseHeader.epk))\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid(`JOSE Header \"epk\" (Ephemeral Public Key) missing or invalid`);\n            if (!_runtime_ecdhes_js__WEBPACK_IMPORTED_MODULE_1__.ecdhAllowed(key))\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JOSENotSupported('ECDH-ES with the provided key is not allowed or not supported by your javascript runtime');\n            const epk = await (0,_key_import_js__WEBPACK_IMPORTED_MODULE_7__.importJWK)(joseHeader.epk, alg);\n            let partyUInfo;\n            let partyVInfo;\n            if (joseHeader.apu !== undefined) {\n                if (typeof joseHeader.apu !== 'string')\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid(`JOSE Header \"apu\" (Agreement PartyUInfo) invalid`);\n                partyUInfo = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__.decode)(joseHeader.apu);\n            }\n            if (joseHeader.apv !== undefined) {\n                if (typeof joseHeader.apv !== 'string')\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid(`JOSE Header \"apv\" (Agreement PartyVInfo) invalid`);\n                partyVInfo = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__.decode)(joseHeader.apv);\n            }\n            const sharedSecret = await _runtime_ecdhes_js__WEBPACK_IMPORTED_MODULE_1__.deriveKey(epk, key, alg === 'ECDH-ES' ? joseHeader.enc : alg, alg === 'ECDH-ES' ? (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_6__.bitLength)(joseHeader.enc) : parseInt(alg.substr(-5, 3), 10), partyUInfo, partyVInfo);\n            if (alg === 'ECDH-ES')\n                return sharedSecret;\n            if (encryptedKey === undefined)\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('JWE Encrypted Key missing');\n            return (0,_runtime_aeskw_js__WEBPACK_IMPORTED_MODULE_0__.unwrap)(alg.substr(-6), sharedSecret, encryptedKey);\n        }\n        case 'RSA1_5':\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (encryptedKey === undefined)\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('JWE Encrypted Key missing');\n            return (0,_runtime_rsaes_js__WEBPACK_IMPORTED_MODULE_3__.decrypt)(alg, key, encryptedKey);\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW': {\n            if (encryptedKey === undefined)\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('JWE Encrypted Key missing');\n            if (typeof joseHeader.p2c !== 'number')\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid(`JOSE Header \"p2c\" (PBES2 Count) missing or invalid`);\n            if (typeof joseHeader.p2s !== 'string')\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid(`JOSE Header \"p2s\" (PBES2 Salt) missing or invalid`);\n            return (0,_runtime_pbes2kw_js__WEBPACK_IMPORTED_MODULE_2__.decrypt)(alg, key, encryptedKey, joseHeader.p2c, (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__.decode)(joseHeader.p2s));\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (encryptedKey === undefined)\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('JWE Encrypted Key missing');\n            return (0,_runtime_aeskw_js__WEBPACK_IMPORTED_MODULE_0__.unwrap)(alg, key, encryptedKey);\n        }\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW': {\n            if (encryptedKey === undefined)\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('JWE Encrypted Key missing');\n            if (typeof joseHeader.iv !== 'string')\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid(`JOSE Header \"iv\" (Initialization Vector) missing or invalid`);\n            if (typeof joseHeader.tag !== 'string')\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid(`JOSE Header \"tag\" (Authentication Tag) missing or invalid`);\n            const iv = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__.decode)(joseHeader.iv);\n            const tag = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__.decode)(joseHeader.tag);\n            return (0,_aesgcmkw_js__WEBPACK_IMPORTED_MODULE_10__.unwrap)(alg, key, encryptedKey, iv, tag);\n        }\n        default: {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JOSENotSupported('Invalid or unsupported \"alg\" (JWE Algorithm) header value');\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (decryptKeyManagement);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/decrypt_key_management.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/encrypt_key_management.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/encrypt_key_management.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _runtime_aeskw_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/aeskw.js */ \"./node_modules/jose/dist/browser/runtime/aeskw.js\");\n/* harmony import */ var _runtime_ecdhes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/ecdhes.js */ \"./node_modules/jose/dist/browser/runtime/ecdhes.js\");\n/* harmony import */ var _runtime_pbes2kw_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../runtime/pbes2kw.js */ \"./node_modules/jose/dist/browser/runtime/pbes2kw.js\");\n/* harmony import */ var _runtime_rsaes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../runtime/rsaes.js */ \"./node_modules/jose/dist/browser/runtime/rsaes.js\");\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _lib_cek_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/cek.js */ \"./node_modules/jose/dist/browser/lib/cek.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _key_export_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../key/export.js */ \"./node_modules/jose/dist/browser/key/export.js\");\n/* harmony import */ var _check_key_type_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./check_key_type.js */ \"./node_modules/jose/dist/browser/lib/check_key_type.js\");\n/* harmony import */ var _aesgcmkw_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./aesgcmkw.js */ \"./node_modules/jose/dist/browser/lib/aesgcmkw.js\");\n\n\n\n\n\n\n\n\n\n\nasync function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {\n    let encryptedKey;\n    let parameters;\n    let cek;\n    (0,_check_key_type_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(alg, key, 'encrypt');\n    switch (alg) {\n        case 'dir': {\n            cek = key;\n            break;\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            if (!_runtime_ecdhes_js__WEBPACK_IMPORTED_MODULE_1__.ecdhAllowed(key)) {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_6__.JOSENotSupported('ECDH-ES with the provided key is not allowed or not supported by your javascript runtime');\n            }\n            const { apu, apv } = providedParameters;\n            let { epk: ephemeralKey } = providedParameters;\n            ephemeralKey || (ephemeralKey = await _runtime_ecdhes_js__WEBPACK_IMPORTED_MODULE_1__.generateEpk(key));\n            const { x, y, crv, kty } = await (0,_key_export_js__WEBPACK_IMPORTED_MODULE_7__.exportJWK)(ephemeralKey);\n            const sharedSecret = await _runtime_ecdhes_js__WEBPACK_IMPORTED_MODULE_1__.deriveKey(key, ephemeralKey, alg === 'ECDH-ES' ? enc : alg, alg === 'ECDH-ES' ? (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_5__.bitLength)(enc) : parseInt(alg.substr(-5, 3), 10), apu, apv);\n            parameters = { epk: { x, y, crv, kty } };\n            if (apu)\n                parameters.apu = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__.encode)(apu);\n            if (apv)\n                parameters.apv = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__.encode)(apv);\n            if (alg === 'ECDH-ES') {\n                cek = sharedSecret;\n                break;\n            }\n            cek = providedCek || (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(enc);\n            const kwAlg = alg.substr(-6);\n            encryptedKey = await (0,_runtime_aeskw_js__WEBPACK_IMPORTED_MODULE_0__.wrap)(kwAlg, sharedSecret, cek);\n            break;\n        }\n        case 'RSA1_5':\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            cek = providedCek || (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(enc);\n            encryptedKey = await (0,_runtime_rsaes_js__WEBPACK_IMPORTED_MODULE_3__.encrypt)(alg, key, cek);\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW': {\n            cek = providedCek || (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(enc);\n            const { p2c, p2s } = providedParameters;\n            ({ encryptedKey, ...parameters } = await (0,_runtime_pbes2kw_js__WEBPACK_IMPORTED_MODULE_2__.encrypt)(alg, key, cek, p2c, p2s));\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            cek = providedCek || (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(enc);\n            encryptedKey = await (0,_runtime_aeskw_js__WEBPACK_IMPORTED_MODULE_0__.wrap)(alg, key, cek);\n            break;\n        }\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW': {\n            cek = providedCek || (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(enc);\n            const { iv } = providedParameters;\n            ({ encryptedKey, ...parameters } = await (0,_aesgcmkw_js__WEBPACK_IMPORTED_MODULE_9__.wrap)(alg, key, cek, iv));\n            break;\n        }\n        default: {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_6__.JOSENotSupported('Invalid or unsupported \"alg\" (JWE Algorithm) header value');\n        }\n    }\n    return { cek, encryptedKey, parameters };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (encryptKeyManagement);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/encrypt_key_management.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/epoch.js":
/*!*****************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/epoch.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((date) => Math.floor(date.getTime() / 1000));\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/epoch.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/format_pem.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/format_pem.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((b64, descriptor) => {\n    const newlined = (b64.match(/.{1,64}/g) || []).join('\\n');\n    return `-----BEGIN ${descriptor}-----\\n${newlined}\\n-----END ${descriptor}-----`;\n});\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/format_pem.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/invalid_key_input.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/invalid_key_input.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((actual, ...types) => {\n    let msg = 'Key must be ';\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    }\n    else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}.`;\n    }\n    else {\n        msg += `of type ${types[0]}.`;\n    }\n    if (actual == null) {\n        msg += ` Received ${actual}`;\n    }\n    else if (typeof actual === 'function' && actual.name) {\n        msg += ` Received function ${actual.name}`;\n    }\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor && actual.constructor.name) {\n            msg += ` Received an instance of ${actual.constructor.name}`;\n        }\n    }\n    return msg;\n});\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/invalid_key_input.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/is_disjoint.js":
/*!***********************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/is_disjoint.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst isDisjoint = (...headers) => {\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) {\n        return true;\n    }\n    let acc;\n    for (const header of sources) {\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters) {\n            if (acc.has(parameter)) {\n                return false;\n            }\n            acc.add(parameter);\n        }\n    }\n    return true;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isDisjoint);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/is_disjoint.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/is_object.js":
/*!*********************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/is_object.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isObject)\n/* harmony export */ });\nfunction isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nfunction isObject(input) {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/is_object.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/iv.js":
/*!**************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/iv.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bitLength\": () => (/* binding */ bitLength),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _runtime_random_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/random.js */ \"./node_modules/jose/dist/browser/runtime/random.js\");\n\n\nfunction bitLength(alg) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A128GCMKW':\n        case 'A192GCM':\n        case 'A192GCMKW':\n        case 'A256GCM':\n        case 'A256GCMKW':\n            return 96;\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            return 128;\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((alg) => (0,_runtime_random_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(new Uint8Array(bitLength(alg) >> 3)));\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/iv.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/jwt_claims_set.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/jwt_claims_set.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _epoch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./epoch.js */ \"./node_modules/jose/dist/browser/lib/epoch.js\");\n/* harmony import */ var _secs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./secs.js */ \"./node_modules/jose/dist/browser/lib/secs.js\");\n/* harmony import */ var _is_object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n\n\n\n\n\nconst normalizeTyp = (value) => value.toLowerCase().replace(/^application\\//, '');\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((protectedHeader, encodedPayload, options = {}) => {\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('unexpected \"typ\" JWT header value', 'typ', 'check_failed');\n    }\n    let payload;\n    try {\n        payload = JSON.parse(_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__.decoder.decode(encodedPayload));\n    }\n    catch (_a) {\n    }\n    if (!(0,_is_object_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(payload)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { issuer } = options;\n    if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('unexpected \"iss\" claim value', 'iss', 'check_failed');\n    }\n    const { subject } = options;\n    if (subject && payload.sub !== subject) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('unexpected \"sub\" claim value', 'sub', 'check_failed');\n    }\n    const { audience } = options;\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('unexpected \"aud\" claim value', 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = (0,_secs_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = (0,_epoch_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(currentDate || new Date());\n    if (payload.iat !== undefined || options.maxTokenAge) {\n        if (typeof payload.iat !== 'number') {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('\"iat\" claim must be a number', 'iat', 'invalid');\n        }\n        if (payload.exp === undefined && payload.iat > now + tolerance) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n        }\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('\"nbf\" claim must be a number', 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('\"exp\" claim must be a number', 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTExpired('\"exp\" claim timestamp check failed', 'exp', 'check_failed');\n        }\n    }\n    if (options.maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof options.maxTokenAge === 'number' ? options.maxTokenAge : (0,_secs_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(options.maxTokenAge);\n        if (age - tolerance > max) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n        }\n    }\n    return payload;\n});\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/jwt_claims_set.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/secs.js":
/*!****************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/secs.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((str) => {\n    const matched = REGEX.exec(str);\n    if (!matched) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[1]);\n    const unit = matched[2].toLowerCase();\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            return Math.round(value);\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            return Math.round(value * minute);\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            return Math.round(value * hour);\n        case 'day':\n        case 'days':\n        case 'd':\n            return Math.round(value * day);\n        case 'week':\n        case 'weeks':\n        case 'w':\n            return Math.round(value * week);\n        default:\n            return Math.round(value * year);\n    }\n});\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/secs.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/validate_algorithms.js":
/*!*******************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/validate_algorithms.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst validateAlgorithms = (option, algorithms) => {\n    if (algorithms !== undefined &&\n        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {\n        throw new TypeError(`\"${option}\" option must be an array of strings`);\n    }\n    if (!algorithms) {\n        return undefined;\n    }\n    return new Set(algorithms);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validateAlgorithms);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/validate_algorithms.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/validate_crit.js":
/*!*************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/validate_crit.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\nfunction validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {\n    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    }\n    if (!protectedHeader || protectedHeader.crit === undefined) {\n        return new Set();\n    }\n    if (!Array.isArray(protectedHeader.crit) ||\n        protectedHeader.crit.length === 0 ||\n        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    }\n    let recognized;\n    if (recognizedOption !== undefined) {\n        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n    }\n    else {\n        recognized = recognizedDefault;\n    }\n    for (const parameter of protectedHeader.crit) {\n        if (!recognized.has(parameter)) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        }\n        if (joseHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        }\n        else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n        }\n    }\n    return new Set(protectedHeader.crit);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validateCrit);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/validate_crit.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/aeskw.js":
/*!*********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/aeskw.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"wrap\": () => (/* binding */ wrap),\n/* harmony export */   \"unwrap\": () => (/* binding */ unwrap)\n/* harmony export */ });\n/* harmony import */ var _bogus_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bogus.js */ \"./node_modules/jose/dist/browser/runtime/bogus.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/crypto_key.js */ \"./node_modules/jose/dist/browser/lib/crypto_key.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\n\nfunction checkKeySize(key, alg) {\n    if (key.algorithm.length !== parseInt(alg.substr(1, 3), 10)) {\n        throw new TypeError(`Invalid key size for alg: ${alg}`);\n    }\n}\nfunction getCryptoKey(key, alg, usage) {\n    if ((0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_1__.isCryptoKey)(key)) {\n        (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_2__.checkEncCryptoKey)(key, alg, usage);\n        return key;\n    }\n    if (key instanceof Uint8Array) {\n        return _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.importKey('raw', key, 'AES-KW', true, [usage]);\n    }\n    throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_4__.types, 'Uint8Array'));\n}\nconst wrap = async (alg, key, cek) => {\n    const cryptoKey = await getCryptoKey(key, alg, 'wrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.importKey('raw', cek, ..._bogus_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n    return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.wrapKey('raw', cryptoKeyCek, cryptoKey, 'AES-KW'));\n};\nconst unwrap = async (alg, key, encryptedKey) => {\n    const cryptoKey = await getCryptoKey(key, alg, 'unwrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.unwrapKey('raw', encryptedKey, cryptoKey, 'AES-KW', ..._bogus_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n    return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.exportKey('raw', cryptoKeyCek));\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/aeskw.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/asn1.js":
/*!********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/asn1.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"toSPKI\": () => (/* binding */ toSPKI),\n/* harmony export */   \"toPKCS8\": () => (/* binding */ toPKCS8),\n/* harmony export */   \"fromPKCS8\": () => (/* binding */ fromPKCS8),\n/* harmony export */   \"fromSPKI\": () => (/* binding */ fromSPKI)\n/* harmony export */ });\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env.js */ \"./node_modules/jose/dist/browser/runtime/env.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _base64url_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _lib_format_pem_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/format_pem.js */ \"./node_modules/jose/dist/browser/lib/format_pem.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\n\n\n\nconst genericExport = async (keyType, keyFormat, key) => {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_1__.isCryptoKey)(key)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_6__.types));\n    }\n    if (!key.extractable) {\n        throw new TypeError('CryptoKey is not extractable');\n    }\n    if (key.type !== keyType) {\n        throw new TypeError(`key is not a ${keyType} key`);\n    }\n    return (0,_lib_format_pem_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((0,_base64url_js__WEBPACK_IMPORTED_MODULE_3__.encodeBase64)(new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);\n};\nconst toSPKI = (key) => {\n    return genericExport('public', 'spki', key);\n};\nconst toPKCS8 = (key) => {\n    return genericExport('private', 'pkcs8', key);\n};\nconst getNamedCurve = (keyData) => {\n    const keyDataStr = keyData.toString();\n    switch (true) {\n        case keyDataStr.includes(new Uint8Array([\n            0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce,\n            0x3d, 0x03, 0x01, 0x07,\n        ]).toString()):\n            return 'P-256';\n        case keyDataStr.includes(new Uint8Array([\n            0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00,\n            0x22,\n        ]).toString()):\n            return 'P-384';\n        case keyDataStr.includes(new Uint8Array([\n            0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00,\n            0x23,\n        ]).toString()):\n            return 'P-521';\n        case ((0,_env_js__WEBPACK_IMPORTED_MODULE_0__.isCloudflareWorkers)() || (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJs)()) &&\n            keyDataStr.includes(new Uint8Array([0x06, 0x03, 0x2b, 0x65, 0x70]).toString()):\n            return 'Ed25519';\n        case (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJs)() &&\n            keyDataStr.includes(new Uint8Array([0x06, 0x03, 0x2b, 0x65, 0x71]).toString()):\n            return 'Ed448';\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JOSENotSupported('Invalid or unsupported EC Key Curve or OKP Key Sub Type');\n    }\n};\nconst genericImport = async (replace, keyFormat, pem, alg, options) => {\n    var _a;\n    let algorithm;\n    let keyUsages;\n    const keyData = new Uint8Array(atob(pem.replace(replace, ''))\n        .split('')\n        .map((c) => c.charCodeAt(0)));\n    const isPublic = keyFormat === 'spki';\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = { name: 'RSA-PSS', hash: `SHA-${alg.substr(-3)}` };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.substr(-3)}` };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: `SHA-${parseInt(alg.substr(-3), 10) || 1}`,\n            };\n            keyUsages = isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];\n            break;\n        case 'ES256':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ES384':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ES512':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW':\n            algorithm = { name: 'ECDH', namedCurve: getNamedCurve(keyData) };\n            keyUsages = isPublic ? [] : ['deriveBits'];\n            break;\n        case ((0,_env_js__WEBPACK_IMPORTED_MODULE_0__.isCloudflareWorkers)() || (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJs)()) && 'EdDSA':\n            const namedCurve = getNamedCurve(keyData).toUpperCase();\n            algorithm = { name: `NODE-${namedCurve}`, namedCurve: `NODE-${namedCurve}` };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JOSENotSupported('Invalid or unsupported \"alg\" (Algorithm) value');\n    }\n    return _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);\n};\nconst fromPKCS8 = (pem, alg, options) => {\n    return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g, 'pkcs8', pem, alg, options);\n};\nconst fromSPKI = (pem, alg, options) => {\n    return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g, 'spki', pem, alg, options);\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/asn1.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/base64url.js":
/*!*************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/base64url.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"encodeBase64\": () => (/* binding */ encodeBase64),\n/* harmony export */   \"encode\": () => (/* binding */ encode),\n/* harmony export */   \"decodeBase64\": () => (/* binding */ decodeBase64),\n/* harmony export */   \"decode\": () => (/* binding */ decode)\n/* harmony export */ });\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n\nconst encodeBase64 = (input) => {\n    let unencoded = input;\n    if (typeof unencoded === 'string') {\n        unencoded = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.encoder.encode(unencoded);\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(''));\n};\nconst encode = (input) => {\n    return encodeBase64(input).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n};\nconst decodeBase64 = (encoded) => {\n    return new Uint8Array(atob(encoded)\n        .split('')\n        .map((c) => c.charCodeAt(0)));\n};\nconst decode = (input) => {\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, '');\n    try {\n        return decodeBase64(encoded);\n    }\n    catch (_a) {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/base64url.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/bogus.js":
/*!*********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/bogus.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst bogusWebCrypto = [\n    { hash: 'SHA-256', name: 'HMAC' },\n    true,\n    ['sign'],\n];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bogusWebCrypto);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/bogus.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/check_cek_length.js":
/*!********************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/check_cek_length.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\nconst checkCekLength = (cek, expected) => {\n    if (cek.length << 3 !== expected) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWEInvalid('Invalid Content Encryption Key length');\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (checkCekLength);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/check_cek_length.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/check_key_length.js":
/*!********************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/check_key_length.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((alg, key) => {\n    if (alg.startsWith('RS') || alg.startsWith('PS')) {\n        const { modulusLength } = key.algorithm;\n        if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n        }\n    }\n});\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/check_key_length.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/decrypt.js":
/*!***********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/decrypt.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_check_iv_length_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/check_iv_length.js */ \"./node_modules/jose/dist/browser/lib/check_iv_length.js\");\n/* harmony import */ var _check_cek_length_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./check_cek_length.js */ \"./node_modules/jose/dist/browser/runtime/check_cek_length.js\");\n/* harmony import */ var _timing_safe_equal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./timing_safe_equal.js */ \"./node_modules/jose/dist/browser/runtime/timing_safe_equal.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/crypto_key.js */ \"./node_modules/jose/dist/browser/lib/crypto_key.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\n\n\n\n\n\nasync function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n    if (!(cek instanceof Uint8Array)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(cek, 'Uint8Array'));\n    }\n    const keySize = parseInt(enc.substr(1, 3), 10);\n    const encKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['decrypt']);\n    const macKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.importKey('raw', cek.subarray(0, keySize >> 3), {\n        hash: `SHA-${keySize << 1}`,\n        name: 'HMAC',\n    }, false, ['sign']);\n    const macData = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.concat)(aad, iv, ciphertext, (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.uint64be)(aad.length << 3));\n    const expectedTag = new Uint8Array((await _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));\n    let macCheckPassed;\n    try {\n        macCheckPassed = (0,_timing_safe_equal_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(tag, expectedTag);\n    }\n    catch (_a) {\n    }\n    if (!macCheckPassed) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_4__.JWEDecryptionFailed();\n    }\n    let plaintext;\n    try {\n        plaintext = new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.decrypt({ iv, name: 'AES-CBC' }, encKey, ciphertext));\n    }\n    catch (_b) {\n    }\n    if (!plaintext) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_4__.JWEDecryptionFailed();\n    }\n    return plaintext;\n}\nasync function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n    let encKey;\n    if (cek instanceof Uint8Array) {\n        encKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.importKey('raw', cek, 'AES-GCM', false, ['decrypt']);\n    }\n    else {\n        (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_6__.checkEncCryptoKey)(cek, enc, 'decrypt');\n        encKey = cek;\n    }\n    try {\n        return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.decrypt({\n            additionalData: aad,\n            iv,\n            name: 'AES-GCM',\n            tagLength: 128,\n        }, encKey, (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.concat)(ciphertext, tag)));\n    }\n    catch (_a) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_4__.JWEDecryptionFailed();\n    }\n}\nconst decrypt = async (enc, cek, ciphertext, iv, tag, aad) => {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_5__.isCryptoKey)(cek) && !(cek instanceof Uint8Array)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(cek, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_8__.types, 'Uint8Array'));\n    }\n    (0,_lib_check_iv_length_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(enc, iv);\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            if (cek instanceof Uint8Array)\n                (0,_check_cek_length_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cek, parseInt(enc.substr(-3), 10));\n            return cbcDecrypt(enc, cek, ciphertext, iv, tag, aad);\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            if (cek instanceof Uint8Array)\n                (0,_check_cek_length_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cek, parseInt(enc.substr(1, 3), 10));\n            return gcmDecrypt(enc, cek, ciphertext, iv, tag, aad);\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_4__.JOSENotSupported('Unsupported JWE Content Encryption Algorithm');\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (decrypt);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/decrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/digest.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/digest.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n\nconst digest = async (algorithm, data) => {\n    const subtleDigest = `SHA-${algorithm.substr(-3)}`;\n    return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtle.digest(subtleDigest, data));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (digest);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/digest.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/ecdhes.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/ecdhes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deriveKey\": () => (/* binding */ deriveKey),\n/* harmony export */   \"generateEpk\": () => (/* binding */ generateEpk),\n/* harmony export */   \"ecdhAllowed\": () => (/* binding */ ecdhAllowed)\n/* harmony export */ });\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/crypto_key.js */ \"./node_modules/jose/dist/browser/lib/crypto_key.js\");\n/* harmony import */ var _digest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./digest.js */ \"./node_modules/jose/dist/browser/runtime/digest.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\n\n\nconst deriveKey = async (publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) => {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_1__.isCryptoKey)(publicKey)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(publicKey, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_5__.types));\n    }\n    (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_2__.checkEncCryptoKey)(publicKey, 'ECDH-ES');\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_1__.isCryptoKey)(privateKey)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(privateKey, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_5__.types));\n    }\n    (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_2__.checkEncCryptoKey)(privateKey, 'ECDH-ES', 'deriveBits', 'deriveKey');\n    const value = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.concat)((0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.lengthAndInput)(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.encoder.encode(algorithm)), (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.lengthAndInput)(apu), (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.lengthAndInput)(apv), (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.uint32be)(keyLength));\n    if (!privateKey.usages.includes('deriveBits')) {\n        throw new TypeError('ECDH-ES private key \"usages\" must include \"deriveBits\"');\n    }\n    const sharedSecret = new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.deriveBits({\n        name: 'ECDH',\n        public: publicKey,\n    }, privateKey, Math.ceil(parseInt(privateKey.algorithm.namedCurve.substr(-3), 10) / 8) <<\n        3));\n    return (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatKdf)(_digest_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"], sharedSecret, keyLength, value);\n};\nconst generateEpk = async (key) => {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_1__.isCryptoKey)(key)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_5__.types));\n    }\n    return (await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.generateKey({ name: 'ECDH', namedCurve: key.algorithm.namedCurve }, true, ['deriveBits'])).privateKey;\n};\nconst ecdhAllowed = (key) => {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_1__.isCryptoKey)(key)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_5__.types));\n    }\n    return ['P-256', 'P-384', 'P-521'].includes(key.algorithm.namedCurve);\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/ecdhes.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/encrypt.js":
/*!***********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/encrypt.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_check_iv_length_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/check_iv_length.js */ \"./node_modules/jose/dist/browser/lib/check_iv_length.js\");\n/* harmony import */ var _check_cek_length_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./check_cek_length.js */ \"./node_modules/jose/dist/browser/runtime/check_cek_length.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/crypto_key.js */ \"./node_modules/jose/dist/browser/lib/crypto_key.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\n\n\n\n\nasync function cbcEncrypt(enc, plaintext, cek, iv, aad) {\n    if (!(cek instanceof Uint8Array)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(cek, 'Uint8Array'));\n    }\n    const keySize = parseInt(enc.substr(1, 3), 10);\n    const encKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['encrypt']);\n    const macKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subtle.importKey('raw', cek.subarray(0, keySize >> 3), {\n        hash: `SHA-${keySize << 1}`,\n        name: 'HMAC',\n    }, false, ['sign']);\n    const ciphertext = new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subtle.encrypt({\n        iv,\n        name: 'AES-CBC',\n    }, encKey, plaintext));\n    const macData = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.concat)(aad, iv, ciphertext, (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.uint64be)(aad.length << 3));\n    const tag = new Uint8Array((await _webcrypto_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));\n    return { ciphertext, tag };\n}\nasync function gcmEncrypt(enc, plaintext, cek, iv, aad) {\n    let encKey;\n    if (cek instanceof Uint8Array) {\n        encKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subtle.importKey('raw', cek, 'AES-GCM', false, ['encrypt']);\n    }\n    else {\n        (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_4__.checkEncCryptoKey)(cek, enc, 'encrypt');\n        encKey = cek;\n    }\n    const encrypted = new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subtle.encrypt({\n        additionalData: aad,\n        iv,\n        name: 'AES-GCM',\n        tagLength: 128,\n    }, encKey, plaintext));\n    const tag = encrypted.slice(-16);\n    const ciphertext = encrypted.slice(0, -16);\n    return { ciphertext, tag };\n}\nconst encrypt = async (enc, plaintext, cek, iv, aad) => {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_3__.isCryptoKey)(cek) && !(cek instanceof Uint8Array)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(cek, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_7__.types, 'Uint8Array'));\n    }\n    (0,_lib_check_iv_length_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(enc, iv);\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            if (cek instanceof Uint8Array)\n                (0,_check_cek_length_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cek, parseInt(enc.substr(-3), 10));\n            return cbcEncrypt(enc, plaintext, cek, iv, aad);\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            if (cek instanceof Uint8Array)\n                (0,_check_cek_length_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cek, parseInt(enc.substr(1, 3), 10));\n            return gcmEncrypt(enc, plaintext, cek, iv, aad);\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_6__.JOSENotSupported('Unsupported JWE Content Encryption Algorithm');\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (encrypt);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/encrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/env.js":
/*!*******************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/env.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isCloudflareWorkers\": () => (/* binding */ isCloudflareWorkers),\n/* harmony export */   \"isNodeJs\": () => (/* binding */ isNodeJs)\n/* harmony export */ });\nfunction isCloudflareWorkers() {\n    return typeof WebSocketPair === 'function';\n}\nfunction isNodeJs() {\n    try {\n        return process.versions.node !== undefined;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/env.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/fetch_jwks.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/fetch_jwks.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env.js */ \"./node_modules/jose/dist/browser/runtime/env.js\");\n\n\nconst fetchJwks = async (url, timeout) => {\n    let controller;\n    let id;\n    let timedOut = false;\n    if (typeof AbortController === 'function') {\n        controller = new AbortController();\n        id = setTimeout(() => {\n            timedOut = true;\n            controller.abort();\n        }, timeout);\n    }\n    const response = await fetch(url.href, {\n        signal: controller ? controller.signal : undefined,\n        redirect: 'manual',\n        method: 'GET',\n        ...(!(0,_env_js__WEBPACK_IMPORTED_MODULE_1__.isCloudflareWorkers)()\n            ? {\n                referrerPolicy: 'no-referrer',\n                credentials: 'omit',\n                mode: 'cors',\n            }\n            : undefined),\n    }).catch((err) => {\n        if (timedOut)\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWKSTimeout();\n        throw err;\n    });\n    if (id !== undefined)\n        clearTimeout(id);\n    if (response.status !== 200) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JOSEError('Expected 200 OK from the JSON Web Key Set HTTP response');\n    }\n    try {\n        return await response.json();\n    }\n    catch (_a) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JOSEError('Failed to parse the JSON Web Key Set HTTP response as JSON');\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fetchJwks);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/fetch_jwks.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/generate.js":
/*!************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/generate.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generateSecret\": () => (/* binding */ generateSecret),\n/* harmony export */   \"generateKeyPair\": () => (/* binding */ generateKeyPair)\n/* harmony export */ });\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env.js */ \"./node_modules/jose/dist/browser/runtime/env.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./random.js */ \"./node_modules/jose/dist/browser/runtime/random.js\");\n\n\n\n\nasync function generateSecret(alg, options) {\n    var _a;\n    let length;\n    let algorithm;\n    let keyUsages;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            length = parseInt(alg.substr(-3), 10);\n            algorithm = { name: 'HMAC', hash: `SHA-${length}`, length };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            length = parseInt(alg.substr(-3), 10);\n            return (0,_random_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(new Uint8Array(length >> 3));\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW':\n            length = parseInt(alg.substring(1, 4), 10);\n            algorithm = { name: 'AES-KW', length };\n            keyUsages = ['wrapKey', 'unwrapKey'];\n            break;\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW':\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            length = parseInt(alg.substring(1, 4), 10);\n            algorithm = { name: 'AES-GCM', length };\n            keyUsages = ['encrypt', 'decrypt'];\n            break;\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n    }\n    return _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.generateKey(algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);\n}\nfunction getModulusLengthOption(options) {\n    var _a;\n    const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;\n    if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported('Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used');\n    }\n    return modulusLength;\n}\nasync function generateKeyPair(alg, options) {\n    var _a, _b;\n    let algorithm;\n    let keyUsages;\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = {\n                name: 'RSA-PSS',\n                hash: `SHA-${alg.substr(-3)}`,\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = {\n                name: 'RSASSA-PKCS1-v1_5',\n                hash: `SHA-${alg.substr(-3)}`,\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: `SHA-${parseInt(alg.substr(-3), 10) || 1}`,\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['decrypt', 'unwrapKey', 'encrypt', 'wrapKey'];\n            break;\n        case 'ES256':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'ES384':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'ES512':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case ((0,_env_js__WEBPACK_IMPORTED_MODULE_0__.isCloudflareWorkers)() || (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJs)()) && 'EdDSA':\n            switch (options === null || options === void 0 ? void 0 : options.crv) {\n                case undefined:\n                case 'Ed25519':\n                    algorithm = { name: 'NODE-ED25519', namedCurve: 'NODE-ED25519' };\n                    keyUsages = ['sign', 'verify'];\n                    break;\n                case (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJs)() && 'Ed448':\n                    algorithm = { name: 'NODE-ED448', namedCurve: 'NODE-ED448' };\n                    keyUsages = ['sign', 'verify'];\n                    break;\n                default:\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported('Invalid or unsupported crv option provided, supported values are Ed25519 and Ed448');\n            }\n            break;\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW':\n            algorithm = { name: 'ECDH', namedCurve: (_a = options === null || options === void 0 ? void 0 : options.crv) !== null && _a !== void 0 ? _a : 'P-256' };\n            keyUsages = ['deriveKey', 'deriveBits'];\n            break;\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n    }\n    return (_webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.generateKey(algorithm, (_b = options === null || options === void 0 ? void 0 : options.extractable) !== null && _b !== void 0 ? _b : false, keyUsages));\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/generate.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/get_sign_verify_key.js":
/*!***********************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/get_sign_verify_key.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getCryptoKey)\n/* harmony export */ });\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/crypto_key.js */ \"./node_modules/jose/dist/browser/lib/crypto_key.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\nfunction getCryptoKey(alg, key, usage) {\n    if ((0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_0__.isCryptoKey)(key)) {\n        (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_1__.checkSigCryptoKey)(key, alg, usage);\n        return key;\n    }\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) {\n            throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_3__.types));\n        }\n        return _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtle.importKey('raw', key, { hash: `SHA-${alg.substr(-3)}`, name: 'HMAC' }, false, [usage]);\n    }\n    throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_3__.types, 'Uint8Array'));\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/get_sign_verify_key.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/is_key_like.js":
/*!***************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/is_key_like.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"types\": () => (/* binding */ types)\n/* harmony export */ });\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((key) => {\n    return (0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_0__.isCryptoKey)(key);\n});\nconst types = ['CryptoKey'];\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/is_key_like.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/jwk_to_key.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/jwk_to_key.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env.js */ \"./node_modules/jose/dist/browser/runtime/env.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _base64url_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n\n\n\n\nfunction subtleMapping(jwk) {\n    let algorithm;\n    let keyUsages;\n    switch (jwk.kty) {\n        case 'oct': {\n            switch (jwk.alg) {\n                case 'HS256':\n                case 'HS384':\n                case 'HS512':\n                    algorithm = { name: 'HMAC', hash: `SHA-${jwk.alg.substr(-3)}` };\n                    keyUsages = ['sign', 'verify'];\n                    break;\n                case 'A128CBC-HS256':\n                case 'A192CBC-HS384':\n                case 'A256CBC-HS512':\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`);\n                case 'A128GCM':\n                case 'A192GCM':\n                case 'A256GCM':\n                case 'A128GCMKW':\n                case 'A192GCMKW':\n                case 'A256GCMKW':\n                    algorithm = { name: 'AES-GCM' };\n                    keyUsages = ['encrypt', 'decrypt'];\n                    break;\n                case 'A128KW':\n                case 'A192KW':\n                case 'A256KW':\n                    algorithm = { name: 'AES-KW' };\n                    keyUsages = ['wrapKey', 'unwrapKey'];\n                    break;\n                case 'PBES2-HS256+A128KW':\n                case 'PBES2-HS384+A192KW':\n                case 'PBES2-HS512+A256KW':\n                    algorithm = { name: 'PBKDF2' };\n                    keyUsages = ['deriveBits'];\n                    break;\n                default:\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'RSA': {\n            switch (jwk.alg) {\n                case 'PS256':\n                case 'PS384':\n                case 'PS512':\n                    algorithm = { name: 'RSA-PSS', hash: `SHA-${jwk.alg.substr(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RS256':\n                case 'RS384':\n                case 'RS512':\n                    algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${jwk.alg.substr(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RSA-OAEP':\n                case 'RSA-OAEP-256':\n                case 'RSA-OAEP-384':\n                case 'RSA-OAEP-512':\n                    algorithm = {\n                        name: 'RSA-OAEP',\n                        hash: `SHA-${parseInt(jwk.alg.substr(-3), 10) || 1}`,\n                    };\n                    keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];\n                    break;\n                default:\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'EC': {\n            switch (jwk.alg) {\n                case 'ES256':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES384':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES512':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: 'ECDH', namedCurve: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case ((0,_env_js__WEBPACK_IMPORTED_MODULE_0__.isCloudflareWorkers)() || (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJs)()) && 'OKP':\n            if (jwk.alg !== 'EdDSA') {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            switch (jwk.crv) {\n                case 'Ed25519':\n                    algorithm = { name: 'NODE-ED25519', namedCurve: 'NODE-ED25519' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJs)() && 'Ed448':\n                    algorithm = { name: 'NODE-ED448', namedCurve: 'NODE-ED448' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                default:\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported('Invalid or unsupported JWK \"crv\" (Subtype of Key Pair) Parameter value');\n            }\n            break;\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n    }\n    return { algorithm, keyUsages };\n}\nconst parse = async (jwk) => {\n    var _a, _b;\n    const { algorithm, keyUsages } = subtleMapping(jwk);\n    const rest = [\n        algorithm,\n        (_a = jwk.ext) !== null && _a !== void 0 ? _a : false,\n        (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages,\n    ];\n    if (algorithm.name === 'PBKDF2') {\n        return _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.importKey('raw', (0,_base64url_js__WEBPACK_IMPORTED_MODULE_3__.decode)(jwk.k), ...rest);\n    }\n    const keyData = { ...jwk };\n    delete keyData.alg;\n    return _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.importKey('jwk', keyData, ...rest);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/jwk_to_key.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/key_to_jwk.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/key_to_jwk.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _base64url_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\nconst keyToJWK = async (key) => {\n    if (key instanceof Uint8Array) {\n        return {\n            kty: 'oct',\n            k: (0,_base64url_js__WEBPACK_IMPORTED_MODULE_2__.encode)(key),\n        };\n    }\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_0__.isCryptoKey)(key)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_3__.types, 'Uint8Array'));\n    }\n    if (!key.extractable) {\n        throw new TypeError('non-extractable CryptoKey cannot be exported as a JWK');\n    }\n    const { ext, key_ops, alg, use, ...jwk } = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtle.exportKey('jwk', key);\n    return jwk;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (keyToJWK);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/key_to_jwk.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/pbes2kw.js":
/*!***********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/pbes2kw.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"encrypt\": () => (/* binding */ encrypt),\n/* harmony export */   \"decrypt\": () => (/* binding */ decrypt)\n/* harmony export */ });\n/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./random.js */ \"./node_modules/jose/dist/browser/runtime/random.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _base64url_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _aeskw_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./aeskw.js */ \"./node_modules/jose/dist/browser/runtime/aeskw.js\");\n/* harmony import */ var _lib_check_p2s_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/check_p2s.js */ \"./node_modules/jose/dist/browser/lib/check_p2s.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/crypto_key.js */ \"./node_modules/jose/dist/browser/lib/crypto_key.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\n\n\n\n\n\nfunction getCryptoKey(key, alg) {\n    if (key instanceof Uint8Array) {\n        return _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.importKey('raw', key, 'PBKDF2', false, ['deriveBits']);\n    }\n    if ((0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_5__.isCryptoKey)(key)) {\n        (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_6__.checkEncCryptoKey)(key, alg, 'deriveBits', 'deriveKey');\n        return key;\n    }\n    throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_8__.types, 'Uint8Array'));\n}\nasync function deriveKey(p2s, alg, p2c, key) {\n    (0,_lib_check_p2s_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(p2s);\n    const salt = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__.p2s)(alg, p2s);\n    const keylen = parseInt(alg.substr(13, 3), 10);\n    const subtleAlg = {\n        hash: `SHA-${alg.substr(8, 3)}`,\n        iterations: p2c,\n        name: 'PBKDF2',\n        salt,\n    };\n    const wrapAlg = {\n        length: keylen,\n        name: 'AES-KW',\n    };\n    const cryptoKey = await getCryptoKey(key, alg);\n    if (cryptoKey.usages.includes('deriveBits')) {\n        return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.deriveBits(subtleAlg, cryptoKey, keylen));\n    }\n    if (cryptoKey.usages.includes('deriveKey')) {\n        return _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ['wrapKey', 'unwrapKey']);\n    }\n    throw new TypeError('PBKDF2 key \"usages\" must include \"deriveBits\" or \"deriveKey\"');\n}\nconst encrypt = async (alg, key, cek, p2c = Math.floor(Math.random() * 2049) + 2048, p2s = (0,_random_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(new Uint8Array(16))) => {\n    const derived = await deriveKey(p2s, alg, p2c, key);\n    const encryptedKey = await (0,_aeskw_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(alg.substr(-6), derived, cek);\n    return { encryptedKey, p2c, p2s: (0,_base64url_js__WEBPACK_IMPORTED_MODULE_2__.encode)(p2s) };\n};\nconst decrypt = async (alg, key, encryptedKey, p2c, p2s) => {\n    const derived = await deriveKey(p2s, alg, p2c, key);\n    return (0,_aeskw_js__WEBPACK_IMPORTED_MODULE_3__.unwrap)(alg.substr(-6), derived, encryptedKey);\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/pbes2kw.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/random.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/random.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getRandomValues.bind(_webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]));\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/random.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/rsaes.js":
/*!*********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/rsaes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"encrypt\": () => (/* binding */ encrypt),\n/* harmony export */   \"decrypt\": () => (/* binding */ decrypt)\n/* harmony export */ });\n/* harmony import */ var _subtle_rsaes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subtle_rsaes.js */ \"./node_modules/jose/dist/browser/runtime/subtle_rsaes.js\");\n/* harmony import */ var _bogus_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bogus.js */ \"./node_modules/jose/dist/browser/runtime/bogus.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/crypto_key.js */ \"./node_modules/jose/dist/browser/lib/crypto_key.js\");\n/* harmony import */ var _check_key_length_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./check_key_length.js */ \"./node_modules/jose/dist/browser/runtime/check_key_length.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\n\n\n\nconst encrypt = async (alg, key, cek) => {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_2__.isCryptoKey)(key)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_6__.types));\n    }\n    (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_3__.checkEncCryptoKey)(key, alg, 'encrypt', 'wrapKey');\n    (0,_check_key_length_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(alg, key);\n    if (key.usages.includes('encrypt')) {\n        return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].subtle.encrypt((0,_subtle_rsaes_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(alg), key, cek));\n    }\n    if (key.usages.includes('wrapKey')) {\n        const cryptoKeyCek = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].subtle.importKey('raw', cek, ..._bogus_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n        return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].subtle.wrapKey('raw', cryptoKeyCek, key, (0,_subtle_rsaes_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(alg)));\n    }\n    throw new TypeError('RSA-OAEP key \"usages\" must include \"encrypt\" or \"wrapKey\" for this operation');\n};\nconst decrypt = async (alg, key, encryptedKey) => {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_2__.isCryptoKey)(key)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_6__.types));\n    }\n    (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_3__.checkEncCryptoKey)(key, alg, 'decrypt', 'unwrapKey');\n    (0,_check_key_length_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(alg, key);\n    if (key.usages.includes('decrypt')) {\n        return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].subtle.decrypt((0,_subtle_rsaes_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(alg), key, encryptedKey));\n    }\n    if (key.usages.includes('unwrapKey')) {\n        const cryptoKeyCek = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].subtle.unwrapKey('raw', encryptedKey, key, (0,_subtle_rsaes_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(alg), ..._bogus_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n        return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].subtle.exportKey('raw', cryptoKeyCek));\n    }\n    throw new TypeError('RSA-OAEP key \"usages\" must include \"decrypt\" or \"unwrapKey\" for this operation');\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/rsaes.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/sign.js":
/*!********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/sign.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _subtle_dsa_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subtle_dsa.js */ \"./node_modules/jose/dist/browser/runtime/subtle_dsa.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _check_key_length_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./check_key_length.js */ \"./node_modules/jose/dist/browser/runtime/check_key_length.js\");\n/* harmony import */ var _get_sign_verify_key_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get_sign_verify_key.js */ \"./node_modules/jose/dist/browser/runtime/get_sign_verify_key.js\");\n\n\n\n\nconst sign = async (alg, key, data) => {\n    const cryptoKey = await (0,_get_sign_verify_key_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(alg, key, 'sign');\n    (0,_check_key_length_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(alg, cryptoKey);\n    const signature = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.sign((0,_subtle_dsa_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(alg, cryptoKey.algorithm.namedCurve), cryptoKey, data);\n    return new Uint8Array(signature);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sign);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/sign.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/subtle_dsa.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/subtle_dsa.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ subtleDsa)\n/* harmony export */ });\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env.js */ \"./node_modules/jose/dist/browser/runtime/env.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\n\nfunction subtleDsa(alg, namedCurve) {\n    const length = parseInt(alg.substr(-3), 10);\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            return { hash: `SHA-${length}`, name: 'HMAC' };\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            return { hash: `SHA-${length}`, name: 'RSA-PSS', saltLength: length >> 3 };\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            return { hash: `SHA-${length}`, name: 'RSASSA-PKCS1-v1_5' };\n        case 'ES256':\n        case 'ES384':\n        case 'ES512':\n            return { hash: `SHA-${length}`, name: 'ECDSA', namedCurve };\n        case ((0,_env_js__WEBPACK_IMPORTED_MODULE_0__.isCloudflareWorkers)() || (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.isNodeJs)()) && 'EdDSA':\n            return { name: namedCurve, namedCurve };\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/subtle_dsa.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/subtle_rsaes.js":
/*!****************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/subtle_rsaes.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ subtleRsaEs)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\nfunction subtleRsaEs(alg) {\n    switch (alg) {\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            return 'RSA-OAEP';\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/subtle_rsaes.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/timing_safe_equal.js":
/*!*********************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/timing_safe_equal.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst timingSafeEqual = (a, b) => {\n    if (!(a instanceof Uint8Array)) {\n        throw new TypeError('First argument must be a buffer');\n    }\n    if (!(b instanceof Uint8Array)) {\n        throw new TypeError('Second argument must be a buffer');\n    }\n    if (a.length !== b.length) {\n        throw new TypeError('Input buffers must have the same length');\n    }\n    const len = a.length;\n    let out = 0;\n    let i = -1;\n    while (++i < len) {\n        out |= a[i] ^ b[i];\n    }\n    return out === 0;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (timingSafeEqual);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/timing_safe_equal.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/verify.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/verify.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _subtle_dsa_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subtle_dsa.js */ \"./node_modules/jose/dist/browser/runtime/subtle_dsa.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _check_key_length_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./check_key_length.js */ \"./node_modules/jose/dist/browser/runtime/check_key_length.js\");\n/* harmony import */ var _get_sign_verify_key_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get_sign_verify_key.js */ \"./node_modules/jose/dist/browser/runtime/get_sign_verify_key.js\");\n\n\n\n\nconst verify = async (alg, key, signature, data) => {\n    const cryptoKey = await (0,_get_sign_verify_key_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(alg, key, 'verify');\n    (0,_check_key_length_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(alg, cryptoKey);\n    const algorithm = (0,_subtle_dsa_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(alg, cryptoKey.algorithm.namedCurve);\n    try {\n        return await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.verify(algorithm, cryptoKey, signature, data);\n    }\n    catch (_a) {\n        return false;\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (verify);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/verify.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/webcrypto.js":
/*!*************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/webcrypto.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"isCryptoKey\": () => (/* binding */ isCryptoKey)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (crypto);\nfunction isCryptoKey(key) {\n    try {\n        return (key != null &&\n            typeof key.extractable === 'boolean' &&\n            typeof key.algorithm.name === 'string' &&\n            typeof key.type === 'string');\n    }\n    catch (_a) {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/webcrypto.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/zlib.js":
/*!********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/zlib.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"inflate\": () => (/* binding */ inflate),\n/* harmony export */   \"deflate\": () => (/* binding */ deflate)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\nconst inflate = async () => {\n    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.');\n};\nconst deflate = async () => {\n    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.');\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/zlib.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/util/base64url.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/util/base64url.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"encode\": () => (/* binding */ encode),\n/* harmony export */   \"decode\": () => (/* binding */ decode)\n/* harmony export */ });\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n\nconst encode = _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode;\nconst decode = _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode;\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/util/base64url.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/util/decode_protected_header.js":
/*!************************************************************************!*\
  !*** ./node_modules/jose/dist/browser/util/decode_protected_header.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decodeProtectedHeader\": () => (/* binding */ decodeProtectedHeader)\n/* harmony export */ });\n/* harmony import */ var _base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64url.js */ \"./node_modules/jose/dist/browser/util/base64url.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n\n\n\nfunction decodeProtectedHeader(token) {\n    let protectedB64u;\n    if (typeof token === 'string') {\n        const parts = token.split('.');\n        if (parts.length === 3 || parts.length === 5) {\n            ;\n            [protectedB64u] = parts;\n        }\n    }\n    else if (typeof token === 'object' && token) {\n        if ('protected' in token) {\n            protectedB64u = token.protected;\n        }\n        else {\n            throw new TypeError('Token does not contain a Protected Header');\n        }\n    }\n    try {\n        if (typeof protectedB64u !== 'string' || !protectedB64u) {\n            throw new Error();\n        }\n        const result = JSON.parse(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__.decoder.decode((0,_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(protectedB64u)));\n        if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(result)) {\n            throw new Error();\n        }\n        return result;\n    }\n    catch (_a) {\n        throw new TypeError('Invalid Token or Protected Header formatting');\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/util/decode_protected_header.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/util/errors.js":
/*!*******************************************************!*\
  !*** ./node_modules/jose/dist/browser/util/errors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"JOSEError\": () => (/* binding */ JOSEError),\n/* harmony export */   \"JWTClaimValidationFailed\": () => (/* binding */ JWTClaimValidationFailed),\n/* harmony export */   \"JWTExpired\": () => (/* binding */ JWTExpired),\n/* harmony export */   \"JOSEAlgNotAllowed\": () => (/* binding */ JOSEAlgNotAllowed),\n/* harmony export */   \"JOSENotSupported\": () => (/* binding */ JOSENotSupported),\n/* harmony export */   \"JWEDecryptionFailed\": () => (/* binding */ JWEDecryptionFailed),\n/* harmony export */   \"JWEInvalid\": () => (/* binding */ JWEInvalid),\n/* harmony export */   \"JWSInvalid\": () => (/* binding */ JWSInvalid),\n/* harmony export */   \"JWTInvalid\": () => (/* binding */ JWTInvalid),\n/* harmony export */   \"JWKInvalid\": () => (/* binding */ JWKInvalid),\n/* harmony export */   \"JWKSInvalid\": () => (/* binding */ JWKSInvalid),\n/* harmony export */   \"JWKSNoMatchingKey\": () => (/* binding */ JWKSNoMatchingKey),\n/* harmony export */   \"JWKSMultipleMatchingKeys\": () => (/* binding */ JWKSMultipleMatchingKeys),\n/* harmony export */   \"JWKSTimeout\": () => (/* binding */ JWKSTimeout),\n/* harmony export */   \"JWSSignatureVerificationFailed\": () => (/* binding */ JWSSignatureVerificationFailed)\n/* harmony export */ });\nclass JOSEError extends Error {\n    constructor(message) {\n        var _a;\n        super(message);\n        this.code = 'ERR_JOSE_GENERIC';\n        this.name = this.constructor.name;\n        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);\n    }\n    static get code() {\n        return 'ERR_JOSE_GENERIC';\n    }\n}\nclass JWTClaimValidationFailed extends JOSEError {\n    constructor(message, claim = 'unspecified', reason = 'unspecified') {\n        super(message);\n        this.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n        this.claim = claim;\n        this.reason = reason;\n    }\n    static get code() {\n        return 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    }\n}\nclass JWTExpired extends JOSEError {\n    constructor(message, claim = 'unspecified', reason = 'unspecified') {\n        super(message);\n        this.code = 'ERR_JWT_EXPIRED';\n        this.claim = claim;\n        this.reason = reason;\n    }\n    static get code() {\n        return 'ERR_JWT_EXPIRED';\n    }\n}\nclass JOSEAlgNotAllowed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    }\n    static get code() {\n        return 'ERR_JOSE_ALG_NOT_ALLOWED';\n    }\n}\nclass JOSENotSupported extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_NOT_SUPPORTED';\n    }\n    static get code() {\n        return 'ERR_JOSE_NOT_SUPPORTED';\n    }\n}\nclass JWEDecryptionFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_DECRYPTION_FAILED';\n        this.message = 'decryption operation failed';\n    }\n    static get code() {\n        return 'ERR_JWE_DECRYPTION_FAILED';\n    }\n}\nclass JWEInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWE_INVALID';\n    }\n}\nclass JWSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWS_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWS_INVALID';\n    }\n}\nclass JWTInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWT_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWT_INVALID';\n    }\n}\nclass JWKInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWK_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWK_INVALID';\n    }\n}\nclass JWKSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWKS_INVALID';\n    }\n}\nclass JWKSNoMatchingKey extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_NO_MATCHING_KEY';\n        this.message = 'no applicable key found in the JSON Web Key Set';\n    }\n    static get code() {\n        return 'ERR_JWKS_NO_MATCHING_KEY';\n    }\n}\nclass JWKSMultipleMatchingKeys extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n        this.message = 'multiple matching keys found in the JSON Web Key Set';\n    }\n    static get code() {\n        return 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    }\n}\nclass JWKSTimeout extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_TIMEOUT';\n        this.message = 'request timed out';\n    }\n    static get code() {\n        return 'ERR_JWKS_TIMEOUT';\n    }\n}\nclass JWSSignatureVerificationFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n        this.message = 'signature verification failed';\n    }\n    static get code() {\n        return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/util/errors.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;